\chapter{``Zam'' Standard Extension for Misaligned Atomics, v0.1}
\label{sec:zam}

This chapter defines the ``Zam'' extension, which extends the ``A'' extension by standardizing support for misaligned atomic memory operations (AMOs).
On platforms implementing ``Zam'', misaligned AMOs need only execute atomically with respect
to other accesses (including non-atomic loads and stores) to the same address and of the same size.
More precisely, execution environments implementing ``Zam'' are subject to the following axiom:

\newcommand{\misalignedatomicityaxiom}{If $r$ and $w$ are paired misaligned load and store instructions from a hart $h$ with the same address and of the same size, then there can be no store instruction $s$ from a hart other than $h$ with the same address and of the same size as $r$ and $w$ such that a store operation generated by $s$ lies in between memory operations generated by $r$ and $w$ in the global memory order.  Furthermore, there can be no load instruction $l$ from a hart other than $h$ with the same address and of the same size as $r$ and $w$ such that a load operation generated by $l$ lies between two memory operations generated by $r$ or by $w$ in the global memory order.}

\vspace{-0.2in}
\paragraph{Atomicity Axiom for misaligned atomics}
\label{rvwmo:ax:misaligned}
\misalignedatomicityaxiom

This restricted form of atomicity is intended to balance the needs of applications which require support for misaligned atomics and the ability of the implementation to actually provide the necessary degree of atomicity.

Aligned instructions under ``Zam'' continue to behave as they normally do under RVWMO.

\begin{commentary}
  The intention of ``Zam'' is that it can be implemented in one of two ways:
  \begin{enumerate}
    \item On hardware that natively supports atomic misaligned accesses to the address and size in question (e.g., for misaligned accesses within a single cache line): by simply following the same rules that would be applied for aligned AMOs.
    \item On hardware that does not natively support misaligned accesses to the address and size in question: by trapping on all instructions (including loads) with that address and size and executing them (via any number of memory operations) inside a mutex that is a function of the given memory address and access size.  AMOs may be emulated by splitting them into separate load and store operations, but all preserved program order rules (e.g., incoming and outgoing syntactic dependencies) must behave as if the AMO is still a single memory operation.
  \end{enumerate}
\end{commentary}
