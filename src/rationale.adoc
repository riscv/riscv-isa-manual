[appendix]
== Historical Rationale for Extensions
[[chap:rationale]]

This appendix contains the rationale for RISC-V ISA extensions at the time they
were ratified.
Unlike the ISA specification, this appendix is ordered chronologically, so as
to convey the motivation and architectural reasoning underpinning each
extension at the time of ratification.
For extensions ratified prior to the conception of this appendix (ca. 2025),
the rationale will be added over time.
In cases where the rationale was not recorded, the authors and editors will
synthesize it from the historical record.

=== "Zihintpause" Extension for Pause Hint

The PAUSE instruction hints to a hart that it should temporarily reduce its
rate of execution.
It is normally used to save energy and execution resources while polling, e.g.
while waiting for a spinlock to become free.

Much of the debate surrounding this extension centered on whether a facility
similar to x86's MONITOR/MWAIT should instead be provided.
We concluded that, even if such a facility were to be defined for RISC-V,
it would not supplant PAUSE.
PAUSE is more appropriate when polling for non-memory events, when polling for
multiple events, or when software does not know precisely what events it is
polling for.
(Perhaps surprisingly, the latter case is ubiquitous, in part because it is
the mechanism expected by the Linux kernel's `cpu_relax` API.)

=== "Zicond" Extension for Integer Conditional Operations

Replacing unpredictable branches with conditional-select or conditional-move
instructions can mitigate a class of costly branch mispredictions.
Unfortunately, conditional-select instructions require three source operands.
These instructions are a logical addition to ISAs that include three-source
integer instructions for other reasons, but are too costly otherwise.

Some ISAs have instead furnished conditional-move instructions, which consume
less encoding space and avoid the extra register read in simple
microarchitectures.
Unfortunately, in register-renamed microarchitectures, these instructions incur
costs simlar to conditional select, or require additional microarchitectural
structures and micro-op-issue constraints.

The Zicond extension was defined to solve the same problem as conditional
select and conditional move, but with very little incremental cost for complex
microarchitectures.
It provides conditional-zero instructions, which read two source operands and,
based upon the zeroness of the second operand, produce either the first operand
or zero.
These instructions can be used as part of a three-instruction sequence to
synthesize conditional select.
Several common conditional-execution idioms require only two instructions,
as would be the case with conditional select or move, including
conditional addition, subtraction, and bitwise AND, OR, and XOR.

Two conditional-zero instructions are included: one that writes zero if the
comparand is zero, and one that does so if the comparand is nonzero.
Variants that perform magnitude comparisons with zero were considered but
ultimately excluded for insufficient quantitative justification.
