[[smepmp]]
== "Smepmp" Extension for PMP Enhancements for memory access and execution prevention in Machine mode, Version 1.0
=== Introduction

The Smepmp extension enhances the xref:pmp[xrefstyle=basic] mechanism to improve Machine mode's security, by providing stronger memory isolation and privilege separation. It enables preventing the execution of code from memory regions not explicitly marked as executable by Machine mode, and restricts Machine mode's access to memory regions designated for Supervisor and User modes. These capabilities help to mitigate control-flow subversion attacks that exploit execution of unauthorized code with Machine mode privileges, and provide security guarantees consistent with the mechanism described in <<sum>> for memory access and execution prevention between Supervisor and User mode.

Additionally, this extension provides a set of mechanisms that allow for more flexible and efficient use of the PMP configuration registers, especially during early boot.

All mechanisms defined in this extension utilize the xref:mseccfg[xrefstyle=basic], and the existing PMP registers. No new CSRs are defined. All mseccfg fields defined here are WARL.

For a more thorough discussion on the subject, please refer to the link:https://github.com/riscvarchive/riscv-tee/blob/main/Smepmp/Smepmp.pdf[ePMP proposal document].

[NOTE]
.Terms used in this specification for clarity
====
* *PMP Entry*: A pair of ``pmpcfg[i]`` / ``pmpaddr[i]`` registers.
* *PMP Rule*: The contents of a pmpcfg register and its associated pmpaddr register(s), that encode a valid protected physical memory region, according to <<pmpcfg-a>>, where ``pmpcfg[i].A != OFF``, and if ``pmpcfg[i].A == TOR``, ``pmpaddr[i-1] < pmpaddr[i]``.
* *Locked*: A PMP rule/entry where the ``pmpcfg.L`` bit is set and the locking behavior mandated in <<pmp-locking>> applies.
====

[[smepmp-mml]]
=== Machine Mode Lockdown (MML)

The ``mseccfg.MML`` bit changes the interpretation of the ``pmpcfg.L`` bit defined in <<pmp-locking>>. It is a sticky bit: once set, it cannot be unset until xref:reset[xrefstyle=basic].

* When ``mseccfg.MML=0``, PMP operates according to the original specification, where the ``pmpcfg.L`` bit marks a rule as *Locked* and applicable in all privilege modes.

* When ``mseccfg.MML=1``, the semantics of PMP rules change as follows:

** ``pmpcfg.L`` denotes an M-mode-only rule when set (applies only to accesses from M-mode), or an S/U-mode-only rule when clear (applies only to accesses from S/U-mode). When ``pmpcfg.L`` is set the rule is also *Locked*, unless ``mseccfg.RLB`` is also set.

** The formerly reserved encoding `pmpcfg.RW=01` (with various `pmpcfg.L` and `pmpcfg.X` settings) now encodes Shared-Region rules (that apply to accesses from all privilege modes) with varying permissions. If ``mseccfg.MML`` is not set, the encoding remains reserved for future standard use.

The following truth table shows the updated behavior in detail:

[cols="^1,^1,^1,^1,^3,^3",stripes=even,options="header"]
|===
4+|Bits on _pmpcfg_ register {set:cellbgcolor:green} 2+|Result
|L|R|W|X|M Mode|S/U Mode
|{set:cellbgcolor:!} 0|0|0|0 2+|Inaccessible region (Access Exception)
|0|0|0|1|Access Exception|Execute-only region
|0|0|1|0 2+|Shared data region: Read/write on M mode, read-only on S/U mode
|0|0|1|1 2+|Shared data region: Read/write for both M and S/U modes
|0|1|0|0|Access Exception|Read-only region
|0|1|0|1|Access Exception|Read/Execute region
|0|1|1|0|Access Exception|Read/Write region
|0|1|1|1|Access Exception|Read/Write/Execute region
|1|0|0|0 2+|*Locked* inaccessible region (Access Exception)
|1|0|0|1|*Locked* Execute-only region|Access Exception
|1|0|1|0 2+|*Locked* Shared code region: Execute only on both M and S/U mode.
|1|0|1|1 2+|*Locked* Shared code region: Execute only on S/U mode, read/execute on M mode.
|1|1|0|0|*Locked* Read-only region|Access Exception
|1|1|0|1|*Locked* Read/Execute region|Access Exception
|1|1|1|0|*Locked* Read/Write region|Access Exception
|1|1|1|1 2+|*Locked* Shared data region: Read only on both M and S/U mode.
|===

[TIP]
====
Shared data regions may be used to expose static platform-specific information (e.g. ACPI tables or the device tree), used by both Machine and Supervisor modes, or exchange data between them without the overhead of copying them.

Shared code regions may be used for exposing vendor-specific functionality (e.g. with custom instructions) to Supervisor/User modes, without exposing that code, or risking the posibility of modifications (no write access).
====

Additionally, when `mseccfg.MML=1`:

* Machine-mode code execution is only permitted from memory regions with a matching M-mode-only rule or a *Locked* Shared-Region rule with executable privileges. Attempting to execute from a region without a matching rule or with a matching S/U-mode-only rule raises an access exception.

* Adding a rule with executable privileges that is either M-mode-only or a *Locked* Shared-Region is not possible; such pmpcfg writes are ignored, leaving pmpcfg unchanged, unless ``mseccfg.RLB`` is also set.

[TIP]
====
The first restriction ensures that execution prevention is always in effect after the MML bit is set, and the lockdown is enabled.

The second restriction is a proactive measure to ensure that no new code can be injected (e.g. by a third-party malicious firmware component or some other vulnerability) after the firmware is initialized.
====

=== Machine-Mode Allowlist Policy (MMAP)

The ``msec.MMAP`` bit changes the default PMP policy for Machine mode when accessing memory regions that don't have a matching PMP rule. It is a sticky bit: once set, it cannot be unset until xref:reset[xrefstyle=basic].

* When mseccfg.MMAP=0, Machine mode can access memory regions without a matching PMP rule (default behavior).

* When mseccfg.MMAP=1, Machine mode cannot access memory regions without a matching PMP rule.

[TIP]
====
This mechanism not only provides a more strict access policy for Machine mode which otherwise has access everywhere unless restricted, it also allows for more efficient use of the available PMP registers, since there is no need to waste a rule for every region that should be blocked, such as regions used by peripherals / processors on the system, or e.g. the boot ROM after the handoff to firmware.
====

=== Rule Locking Bypass (RLB)

The ``mseccfg.RLB`` bit provides a mechanism to temporarily modify *Locked* PMP rules:

* When mseccfg.RLB=1, *Locked* PMP rules may be modified and *locked* PMP entries may be edited.

* When mseccfg.RLB=0 and pmpcfg.L=1 in any rule or entry (including disabled entries), then mseccfg.RLB remains 0 and any further modifications to mseccfg.RLB are ignored until xref:reset[xrefstyle=basic].

[CAUTION]
====
*Be aware that RLB introduces a security vulnerability if left set after the boot process is over and in general it should be used with caution, even when used temporarily.* This feature is intended to be used as a debug mechanism, or as a temporary workaround during the boot process for simplifying software, and optimizing the allocation of memory and PMP rules. If developers / vendors have no use for such functionality, they should never set ``mseccfg.RLB`` and if possible hard-wire it to 0. In any case *RLB should be disabled and locked as soon as possible*.
====

[NOTE]
====
If ``mseccfg.RLB`` is not used and left unset, it will be locked as soon as a PMP rule/entry with the ``pmpcfg.L`` bit set is configured.
====

=== Smepmp software discovery

Since all fields defined on ``mseccfg`` under this proposal are either locked when set (``MMAP``/``MML``) or locked when cleared (``RLB``), software cannot dynamically query them to reliably determine the presence of Smepmp. It is expected that implementation-specific boot code will set ``mseccfg.MMAP`` and/or ``mseccfg.MML`` during early boot stages, before transferring control to the generic firmware implementation (e.g. OpenSBI). The firmware can then determine the presence of Smepmp by reading ``mseccfg`` and verifying the state of ``mseccfg.MMAP`` and ``mseccfg.MML``. Alternatively a software-defined discovery mechanism may be used.


=== Notable implementation considerations

* For adding shared code regions, ``mseccfg.RLB`` needs to be implemented, or else such rules can only be added together with ``mseccfg.MML`` being set, as part of a pre-defined ruleset on reset. That's because the reserved encoding ``pmpcfg.RW=01`` being used for shared region rules is only defined when ``mseccfg.MML`` is set, and <<smepmp-mml>> prevents the addition of rules with executable privileges on M-mode after ``mseccfg.MML`` is set unless ``mseccfg.RLB`` is also set.

* The RLB feature should be used with caution, primarily during debugging or early boot, and should be disabled as soon as possible in production environments.

* Since PMP rules with a higher priority override rules with a lower priority, *Locked* rules must precede non-Locked rules. Otherwise the unlocked rules with a higher priority may be modified afterwards and compromise the ruleset.

* For optimal security, systems should initialize both mseccfg.MMAP and mseccfg.MML to 1 as early as possible during boot.

=== Visual representation of Smepmp

image::smepmp-visual-representation.png[]
