\chapter{``Zfinx'' Standard Extension for Floating-Point in Integer Registers, Version 0.1}
\label{sec:zfinx}

This chapter defines the ``Zfinx'' extension (pronounced ``z-f-in-x''), which
provides instructions similar to those in the standard floating-point
extensions, but that operate on the {\tt x} registers instead of the {\tt f}
registers.

\begin{commentary}
The baseline F extension uses separate {\tt f} registers for floating-point
computation.
This design reduces register pressure and simplifies the provision of
register-file ports for wide superscalars.
However, the additional \wunits{128}{B} of architectural state increases the
minimal implementation cost.
By eliminating the {\tt f} registers, the Zfinx extension substantially
reduces the cost of simple RISC-V implementations with floating-point
instruction-set support.

Unlike most RISC-V extensions, the addition of Zfinx is not backwards
compatible: software that uses floating-point instructions but assumes the
absence of the Zfinx extension will not, in general, execute correctly on
implementations with the Zfinx extension.
\end{commentary}

The Zfinx extension adds all of the instructions that the F extension
adds, {\em except} for the transfer instructions FLW, FSW, FMV.W.X,
FMV.X.W, C.FLW[SP], and C.FSW[SP].

\begin{commentary}
Zfinx software uses integer loads and stores to transfer floating-point values
from and to memory.
Transfers between registers use either integer arithmetic or floating-point
sign-injection instructions.
\end{commentary}

The Zfinx variants of these F-extension instructions have the same semantics,
except that whenever such an instruction would have accessed an {\tt f}
register, it instead accesses the {\tt x} register with the same number.

\section{NaN Boxing of Narrower Values}

Floating-point operands of width \mbox{{\em w} $<$ XLEN bits} occupy bits
\mbox{{\em w}-1:0} of an {\tt x} register.
Floating-point operations on {\em w}-bit operands ignore operand bits
\mbox{XLEN-1:{\em w}}.

Floating-point operations that produce \mbox{{\em w} $<$ XLEN-bit} results
fill bits \mbox{XLEN-1:{\em w}} of the result with ones.

\begin{commentary}
To avoid the need for dedicated floating-point load instructions that fill the
MSBs of an {\tt x} register with ones, we abandon the usual NaN-boxing
requirement for floating-point operands.
We retain the NaN-boxing of results to keep Zfinx as similar as possible and
to ease debugging.
\end{commentary}

\section{Zdinx}

The Zdinx extension provides analogous double-precision floating-point
instructions.
The Zdinx extension requires the Zfinx extension.

The Zdinx extension adds all of the instructions that the D extension
adds, {\em except} for the transfer instructions FLD, FSD, FMV.D.X,
FMV.X.D, C.FLD[SP], and C.FSD[SP].

The Zdinx variants of these D-extension instructions have the same semantics,
except that whenever such an instruction would have accessed an {\tt f}
register, it instead accesses the {\tt x} register with the same number.

\section{Processing of Wider Values}

Double-precision operands in RV32Zdinx
are held in aligned {\tt x}-register pairs, i.e.,
register numbers must be even.
Use of misaligned (odd-numbered) registers for double-width floating-point
operands is {\em reserved}.

Regardless of endianness, the lower-numbered register holds the low-order
bits, and the higher-numbered register holds the high-order bits: e.g., bits
31:0 of a double-precision operand in RV32Zdinx might be held in register
{\tt x14}, with bits 63:32 of that operand held in {\tt x15}.

When a double-width floating-point result is written to {\tt x0}, the entire
write takes no effect: e.g., for RV32Zdinx, writing a double-precision result
to {\tt x0} does not cause {\tt x1} to be written.

When {\tt x0} is used as a double-width floating-point operand, the entire
operand is zero---i.e., {\tt x1} is not accessed.

\begin{commentary}
Load-pair and store-pair instructions are not provided, so transferring
double-precision operands in RV32Zdinx from or to memory requires
two loads or stores.
Register moves need only a single FSGNJ.D instruction, however.
\end{commentary}

\section{Zqinx}

The Zqinx extension is defined analogously to the Zdinx extension.
For RV64, quad-precision operands require two-register alignment.
For RV32, quad-precision operands require four-register alignment.

\section{Privileged Architecture Implications}

In the standard privileged architecture defined in Volume II, the
{\tt mstatus} field FS is hardwired to 0 if the Zfinx extension is
implemented, and FS no longer affects the trapping behavior of
floating-point instructions or {\tt fcsr} accesses.

The {\tt misa} bits F, D, and Q are hardwired to 0 when the Zfinx
extension is implemented.

\begin{commentary}
A future discoverability mechanism might be used to probe the existence
of the Zfinx, Zhinx, Zdinx, and Zqinx extensions.
\end{commentary}
