[[Zicond]]
== "Zicond" Extension for Integer Conditional Operations, Version 1.0.0

The Zicond extension defines two R-type instructions that support branchless
conditional operations.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

|{check}
|{check}
|czero.eqz _rd_, _rs1_, _rs2_
|<<#insns-czero-eqz>>

|{check}
|{check}
|czero.nez _rd_, _rs1_, _rs2_
|<<#insns-czero-nez>>

|===

=== Instructions (in alphabetical order)

[#insns-czero-eqz,reftext="Conditional zero, if condition is equal to zero"]
==== czero.eqz

Synopsis::
Moves zero to a register _rd_, if the condition _rs2_ is equal to zero, otherwise moves _rs1_ to _rd_.

Mnemonic::
czero.eqz _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['CZERO.EQZ']},
    { bits:  5, name: 'rs1', attr: ['value'] },
    { bits:  5, name: 'rs2', attr: ['condition'] },
    { bits:  7, name: 0x7, attr: ['CZERO'] },
]}
....

Description::
[[norm:czero-eqz_op]]
If _rs2_ contains the value zero, this instruction writes the value zero to _rd_.  Otherwise, this instruction copies the contents of _rs1_ to _rd_.

This instruction carries a syntactic dependency from both _rs1_ and _rs2_ to _rd_.
[[norm:czero-eqz_inst_ctime]]
Furthermore, if the Zkt extension is implemented, this instruction's timing is independent of the data values in _rs1_ and _rs2_.

SAIL code::
[source,sail]
--
  let condition = X(rs2);
  result : xlenbits = if (condition == zeros()) then zeros()
                                                else X(rs1);
  X(rd) = result;
--

<<<

[#insns-czero-nez,reftext="Conditional zero, if condition is nonzero"]
==== czero.nez

Synopsis::
Moves zero to a register _rd_, if the condition _rs2_ is nonzero, otherwise moves _rs1_ to _rd_.

Mnemonic::
czero.nez _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x7, attr: ['CZERO.NEZ']},
    { bits:  5, name: 'rs1', attr: ['value'] },
    { bits:  5, name: 'rs2', attr: ['condition'] },
    { bits:  7, name: 0x7, attr: ['CZERO'] },
]}
....

Description::
[[norm:czero-nez_op]]
If _rs2_ contains a nonzero value, this instruction writes the value zero to _rd_.  Otherwise, this instruction copies the contents of _rs1_ to _rd_.

This instruction carries a syntactic dependency from both _rs1_ and _rs2_ to _rd_.
[[norm:czero-nez_zkt_timing]]
Furthermore, if the Zkt extension is implemented, this instruction's timing is independent of the data values in _rs1_ and _rs2_.

SAIL code::
[source,sail]
--
  let condition = X(rs2);
  result : xlenbits = if (condition != zeros()) then zeros()
                                                else X(rs1);
  X(rd) = result;
--

=== Usage examples

The instructions from this extension can be used to construct sequences that perform conditional-arithmetic, conditional-bitwise-logical, and conditional-select operations.

==== Instruction sequences

[%header,cols="4,.^3l,^2"]
|===
|Operation
|Instruction sequence
|Length

|*Conditional add, if zero* +
`rd = (rc == 0) ? (rs1 + rs2) : rs1`
|czero.nez  rd, rs2, rc
add        rd, rs1, rd
.8+.^|2 insns

|*Conditional add, if non-zero* +
`rd = (rc != 0) ? (rs1 + rs2) : rs1`
|czero.eqz  rd, rs2, rc
add        rd, rs1, rd

|*Conditional subtract, if zero* +
`rd = (rc == 0) ? (rs1 - rs2) : rs1`
|czero.nez  rd, rs2, rc
sub        rd, rs1, rd

|*Conditional subtract, if non-zero* +
`rd = (rc != 0) ? (rs1 - rs2) : rs1`
|czero.eqz  rd, rs2, rc
sub        rd, rs1, rd

|*Conditional bitwise-or, if zero* +
`rd = (rc == 0) ? (rs1 \| rs2) : rs1`
|czero.nez  rd, rs2, rc
or         rd, rs1, rd

|*Conditional bitwise-or, if non-zero* +
`rd = (rc != 0) ? (rs1 \| rs2) : rs1`
|czero.eqz  rd, rs2, rc
or         rd, rs1, rd

|*Conditional bitwise-xor, if zero* +
`rd = (rc == 0) ? (rs1 ^ rs2) : rs1`
|czero.nez  rd, rs2, rc
xor        rd, rs1, rd

|*Conditional bitwise-xor, if non-zero* +
`rd = (rc != 0) ? (rs1 ^ rs2) : rs1`
|czero.eqz  rd, rs2, rc
xor        rd, rs1, rd

|*Conditional bitwise-and, if zero* +
`rd = (rc == 0) ? (rs1 & rs2) : rs1`
|and        rd, rs1, rs2
czero.eqz  rtmp, rs1, rc
or         rd, rd, rtmp
.4+.^|3 insns +
(requires 1 temporary)

|*Conditional bitwise-and, if non-zero* +
`rd = (rc != 0) ? (rs1 & rs2) : rs1`
|and        rd, rs1, rs2
czero.nez  rtmp, rs1, rc
or         rd, rd, rtmp

|*Conditional select, if zero* +
`rd = (rc == 0) ? rs1 : rs2`
|czero.nez  rd, rs1, rc
czero.eqz  rtmp, rs2, rc
add        rd, rd, rtmp

|*Conditional select, if non-zero* +
`rd = (rc != 0) ? rs1 : rs2`
|czero.eqz  rd, rs1, rc
czero.nez  rtmp, rs2, rc
add        rd, rd, rtmp

|===
