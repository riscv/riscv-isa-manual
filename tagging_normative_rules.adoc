= How to Tag Normative Rules in the ISA Manuals

The ISA manuals contain a mix of normative and informative (AKA non-normative) content.
We use AsciiDoctor's anchor facility to tag normative text which is extracted by tools
provided in the link:https://github.com/riscv/docs-resources[docs-resources GitHub repository]
to create machine-readable and human-readable representations of normative rules.

== READ THIS FIRST

Read link:https://github.com/riscv/docs-resources/blob/main/normative-rules.md[How to Tag Normative Rules in RISC-V International Standards] for information that applies to all RISC-V International standards. This document provides information such as:

* What exactly is a "normative rule"? What is a "parameter"?
* How does one add normative rule tags to the AsciiDoc files using the AsciiDoc anchor facility?
* Ins and outs and gotchas when using the AsciiDoc anchor facility.
* How are the normative rules extracted from the AsciiDoc files?

== Normative Rules Overview

Normative rules reference tags in the AsciiDoc source files.
The tag name matches the rule name in simple 1-1 cases (except the tag contains norm: and the rule does not).
The normative rules are defined on a per-document basis with a YAML file listing the rules, their tags, and an optional short summary or longer full description only if the tagged text isn't clear.
The Makefile in riscv-isa-manual generates a JSON file (machine-readable) and HTML file (human-readble) in the build directory containing all of the normative rules for the document.

== Naming Normative Rules

Normative rules should have unique, short names that are easy to put in table cells.
Normative rules related to an instruction, CSR, or CSR field should start with the instruction, CSR, or field name.  Dots in the instruction or CSR field are replaced with dashes to keep tools happy.

.Normative Rule Naming Convention
[options="header"]
|===
|Scenario|Format|Example
|Simple instruction|<instr>_op, <inst>_enc|add_op, c-add_op, add_enc
|Additional instruction rules|<instr>_<short-descriptor>|sll_op, sll_shamt_rv32, sll_shamt_rv64
|CSR|<csr_name>_sz, <csr_name>_acc, <csr_name>_mode, <csr_name>_op|mscratch_sz, mscratch_acc, mscratch_mode
|CSR bitfield|<csr_name>-<field_name>_sz, <csr_name>-<field_name>_acc, <csr_name>-<field_name>_op|mstatus-mpp_sz, mstatus-mpp_acc, mstatus-mpp_op
|Categories|<category>_<short_description>|br_targ, ldst_ea, R-type_operands
|Extension|<ext>_<short-description>|Sv_bare, Sv48_gigapage, Sv57_terapage, pmp_addr_match
|===

There should be at least two normative rules (op & enc) per instruction, even if there is a single tag describing multiple instructions. _op defines the instruction operation. _enc defines instruction type and op/func fields.

Each CSR typically has at least the following rules, with text from the spec defining the size, access type, privilege mode, and operation.

* sz (size in bits)
* acc (read/write access type; relates to rw, ro, ro-h, rw-r, rw-rh from UDB)
* mode (associated privilege mode)
* op (operation, optional for CSRs such as mscratch that do not affect system behavior)

Each CSR with bitfields should have at least the following rules for each field:

* sz (size in bits)
* acc (some fields like mstatus.SD may be read-only even if the overall CSR is read/write)
* op

Reserved instructions, CSR fields, etc. use _rsv suffix.

=== Naming Parameters

Each parameter name should exactly match the https://github.com/riscv-software-src/riscv-unified-db[UDB] name if one exists except that the name is lower case.
https://riscv-software-src.github.io/riscv-unified-db/example_cfg/html/example_rv64_with_overlay/config.html[Use this link] to find most UDB parameters.
If there isn't a UDB name, create your own name.
Do NOT add any suffix/prefix (e.g., "_param") to parameter rule names. Parameters are identified with "kind: parameter" in the normative rule definition files (see <<Normative Rule Definitions>>).

== Tagging Normative Rules in ISA Manuals

The ISA manual builds upon the anchor naming convention of a "norm:" prefix by following it with a name.  If there is a 1:1 relationship between the rule and the tag (the common case), then the name is simply the rule name.  If there is a many:1 or 1:many relationship, then see examples below.

== Normative Rule Definitions

Normative rules are defined in "Normative Rule Definition" YAML files.
Each normative rule must have a unique rule name, a list of one or more tags, a short summary only if neccessary,
and/or a longer description only if necessary.

By convention, there is one normative rule definition file for each chapter in the ISA manuals.
The definition files live in the "normative_rule_defs" directory and have the same name
as their corresponding ISA manual chapter in the "src" directory but with a .yaml suffix instead of .adoc.
For example, the https://github.com/riscv/riscv-isa-manual/blob/main/src/rv64.adoc[rv64.adoc] chapter of the Unprivileged ISA Manual has a corresponding https://github.com/riscv/riscv-isa-manual/blob/main/normative_rule_defs/rv64.yaml[rv64.yaml] file located in the "normative_rule_defs" directory.

The vast majority of normative rules for a chapter just refer to tagged text in that chapter.
However, there are cases where a normative rule needs to refer to text in multiple chapters.
In this case the normative rule is defined in only one of the definition files and we refer to that
as the "primary definition file" for that normative rule.

The exact schema for normative rule definition YAML files is located in in
https://github.com/riscv/docs-resources/blob/main/schemas/defs-schema.json[defs-schema.json].

=== Identifying Parameters

Parameters are identified by setting the "kind: parameter" property in the definition of the normative rule.

=== Example of Definition File

.rv64.yaml
[source,yaml]
----
$schema: "normative_rules_schema.json#"

chapter_name: RV64I Base ISA

normative_rule_definitions:
  # 1-to-1 rule to tag
  - name: rv64_x_sz
    tag: "norm:rv64_x_sz"
  # many-to-1 rules to tag
  - names: [sll_shamt_rv64, srl_shamt_rv64, sra_shamt_rv64]
    tag: "norm:shamt_rv64"
  # 1-to-many rule to tags where multiple tags are needed to create a complete self-contained rule
  - name: lh_rv64i_op
    summary: lh 64-bit sign extension
    tags: ["norm:lw_rv64i_op", "norm:subword_rv64i_load"]
  # another 1-to-many rule to tags where multiple tags are needed to create a complete self-contained rule
  - name: lhu_rv64i_op
    summary: lhu 64-bit zero extension
    tags:["norm:lw_rv64i_op", "norm:lwu_rv64i_op", "norm:subword_rv64i_load"]
  - name: my_parameter
    summary: A bogus example for doc purposes
    tags: ["norm:my_parameter"]
    kind: parameter
----

These rules reference the following tags in the AsciiDoc chapter of the ISA manual:

.rv64.adoc
[source,adoc]
----
[[norm:rv64_x_sz]]
RV64I widens the integer registers and supported user address space to
64 bits (XLEN=64 in <<gprs>>).

SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register _rs1_ by the shift amount held in
register _rs2_. [#norm:shamt_rv64]#In RV64I, only the low 6 bits of _rs2_ are considered
for the shift amount.#

[#norm:lw_rv64i_op]#The LW instruction loads a 32-bit value from memory and sign-extends
this to 64 bits before storing it in register _rd_ for RV64I.#
[#norm:lwu_rv64i_op]#The LWU instruction, on the other hand, zero-extends the 32-bit value from
memory for RV64I.# [#norm:subword_rv64i_load]#LH and LHU are defined analogously for 16-bit values, as are LB and LBU for 8-bit values.#
----
