{
  "tags": {
    "norm:execution_environment_implementation_flexibility": "The implementation of a RISC-V\nexecution environment can be pure hardware, pure software, or a\ncombination of hardware and software. For example, opcode traps and\nsoftware emulation can be used to implement functionality not provided\nin hardware.",
    "norm:base_integer_variants": "There are two primary base\ninteger variants, RV32I and RV64I, described in\n&lt;&lt;rv32&gt;&gt; and &lt;&lt;rv64&gt;&gt;, which provide 32-bit\nor 64-bit address spaces respectively.",
    "norm:xlen_definition": "We use the term XLEN to refer to\nthe width of an integer register in bits (either 32 or 64).",
    "norm:twos_complement_signed_integers": "The base integer instruction sets use a two's-complement\nrepresentation for signed integer values.",
    "norm:rv32i_xreg_sz": "For RV32I, the 32 x registers are each 32 bits wide,\ni.e., XLEN=32.",
    "norm:x0eq0": "Register x0 is hardwired with all bits equal to 0.",
    "norm:rv32i_rv64i_other_xregs": "General purpose registers x1-x31 hold values that various\ninstructions interpret as a collection of Boolean values, or as two's\ncomplement signed binary integers or unsigned binary integers.",
    "norm:pcreg_op": "There is one additional unprivileged register: the program counter pc holds the address of the current instruction.",
    "norm:taken_cti_misaligned_exc": "An instruction-address-misaligned exception is generated on a taken branch\nor unconditional jump if the target address is not IALIGN-bit aligned.\nThis exception is reported on the branch or jump instruction, not on the target instruction.",
    "norm:cond_br_no_ia_misaligned_exc_not_taken": "No instruction-address-misaligned exception is generated\nfor a conditional branch that is not taken.",
    "norm:imm_always_sex": "Except for the 5-bit immediates used in CSR instructions (&lt;&lt;csrinsts&gt;&gt;),\nimmediates are always sign-extended",
    "norm:addi_op": "ADDI adds the sign-extended 12-bit immediate to register rs1.",
    "norm:addi_overflow": "Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.",
    "norm:slti_sltiu_op": "SLTI (set less than immediate) places the value 1 in register rd if\nregister rs1 is less than the sign-extended immediate when both are\ntreated as signed numbers, else 0 is written to rd. SLTIU is similar\nbut compares the values as unsigned numbers (i.e., the immediate is\nfirst sign-extended to XLEN bits then treated as an unsigned number).",
    "norm:andi_ori_xori_op": "ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and\nXOR on register rs1 and the sign-extended 12-bit immediate and place\nthe result in rd.",
    "norm:slli_op": "SLLI is a logical left shift (zeros are shifted into the lower bits);",
    "norm:srli_op": "SRLI is a logical right shift (zeros are shifted into the upper bits);",
    "norm:srai_op": "SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).",
    "norm:lui_op": "LUI places the 32-bit U-immediate value into the\ndestination register rd, filling in the lowest 12 bits with zeros.",
    "norm:auipc_op": "AUIPC forms a 32-bit offset from\nthe U-immediate, filling in the lowest 12 bits with zeros, adds this\noffset to the address of the AUIPC instruction, then places the result\nin register rd.",
    "norm:R-type_operands": "All operations read\nthe rs1 and rs2 registers as source operands and write the result into register rd.",
    "norm:add_op": "ADD performs the addition of rs1 and rs2.",
    "norm:sub_op": "SUB performs the subtraction of rs2 from rs1.",
    "norm:add_sub_overflow": "Overflows are ignored and the low XLEN bits of results are written to the destination rd.",
    "norm:slt_sltu_op": "SLT and SLTU perform signed and unsigned compares respectively, writing 1 to rd if\nrs1 &lt; rs2, 0 otherwise.",
    "norm:and_or_xor_op": "AND, OR, and XOR perform bitwise logical operations.",
    "norm:sll_srl_sra_op": "SLL, SRL, and SRA perform logical left, logical right, and arithmetic\nright shifts on the value in register rs1 by the shift amount held in\nthe lower 5 bits of register rs2.",
    "norm:nop_op": "The NOP instruction does not change any architecturally visible state,\nexcept for advancing the pc and incrementing any applicable\nperformance counters.",
    "norm:nop_enc": "NOP is encoded as ADDI x0, x0, 0.",
    "norm:no_cti_delay_slots": "Control transfer instructions in RV32I\ndo not have architecturally visible delay slots.",
    "norm:ia_fault_exc_on_target": "If an instruction access-fault or instruction page-fault exception\noccurs on the target of a jump or taken branch, the exception is\nreported on the target instruction, not on the jump or branch instruction.",
    "norm:jal_target": "The offset is sign-extended and added to the address of the jump instruction to\nform the jump target address.",
    "norm:jal_op": "JAL stores the address of the instruction\nfollowing the jump ('pc'+4) into register rd.",
    "norm:jalr_target": "The target address is obtained by adding the\nsign-extended 12-bit I-immediate to the register rs1, then setting the\nleast-significant bit of the result to zero.",
    "norm:jalr_op": "The address of the\ninstruction following the jump (pc+4) is written to register rd.",
    "norm:jump_misaligned_exception": "The JAL and JALR instructions will generate an instruction-address-misaligned exception if the target address is not aligned to a four-byte boundary.",
    "norm:jump_misaligned_c_no_exception": "Instruction-address-misaligned exceptions are not possible on machines with IALIGN=16, e.g., those with the compressed instruction-set extension, C.",
    "norm:br_target": "The 12-bit B-immediate encodes signed offsets in multiples of 2 bytes. The offset\nis sign-extended and added to the address of the branch instruction to give the target address.",
    "norm:beq_bne_op": "BEQ and BNE take the branch if registers rs1 and rs2 are equal or unequal respectively.",
    "norm:blt_bltu_op": "BLT and BLTU take the branch if rs1 is less than rs2, using signed and\nunsigned comparison respectively.",
    "norm:bge_bgeu_op": "BGE and BGEU take the branch if rs1 is greater than or equal to rs2,\nusing signed and unsigned comparison respectively.",
    "norm:branch_misaligned_taken_exception": "The conditional branch instructions will generate an\ninstruction-address-misaligned exception if the target address is not\naligned to a four-byte boundary and the branch condition evaluates to\ntrue.",
    "norm:branch_misaligned_untaken_exception": "If the branch condition evaluates to false, the\ninstruction-address-misaligned exception will not be raised.",
    "norm:branch_misaligned_c_no_exception": "Instruction-address-misaligned exceptions are not possible on machines with IALIGN=16, e.g., those with the compressed instruction-set extension, C.",
    "norm:load_exc_x0": "Loads with a destination of\nx0 must still raise any exceptions and cause any other side effects\neven though the load value is discarded.",
    "norm:ENDIANNESS_LITTLE_OR_BIG": "The EEI will define whether the memory system is little-endian or big-endian.",
    "norm:ldst_endian_byte_invariant": "In RISC-V, endianness is byte-address invariant.",
    "norm:ldst_endian_byte_op": "In a system for which endianness is byte-address invariant, the following property holds: if a byte is stored to memory at some address in some endianness, then a byte-sized load from that address in any endianness returns the stored value.",
    "norm:ldst_little_endian_op": "In a little-endian configuration, multibyte stores write the least-significant register byte at the lowest memory byte address, followed by the other register bytes in ascending order of their significance. Loads similarly transfer the contents of the lesser memory byte addresses to the less-significant register bytes.",
    "norm:ldst_big_endian_op": "In a big-endian configuration, multibyte stores write the most-significant register byte at the lowest memory byte address, followed by the other register bytes in descending order of their significance. Loads similarly transfer the contents of the greater memory byte addresses to the less-significant register bytes.",
    "norm:ldst_ea": "The effective address is obtained by adding register rs1 to the\nsign-extended 12-bit offset.",
    "norm:load_op": "Loads copy a value from memory to register rd.",
    "norm:store_op": "Stores copy the value in register rs2 to memory.",
    "norm:lw_op": "The LW instruction loads a 32-bit value from memory into rd.",
    "norm:lh_op": "LH loads a 16-bit value from memory, then sign-extends to 32-bits before storing\nin rd.",
    "norm:lhu_op": "LHU loads a 16-bit value from memory but then zero extends to\n32-bits before storing in rd.",
    "norm:lb_lbu_op": "LB and LBU are defined analogously for 8-bit values.",
    "norm:sw_sh_sb_op": "The SW, SH, and SB instructions store 32-bit, 16-bit, and\n8-bit values from the low bits of register rs2 to memory.",
    "norm:ldst_no_exc_aligned": "loads and stores whose effective addresses are\nnaturally aligned shall not raise an address-misaligned exception.",
    "norm:misaligned_ldst_eei_dependent_behavior": "Loads and stores whose effective address is not naturally aligned to the\nreferenced datatype (i.e., the effective address is not divisible by the\nsize of the access in bytes) have behavior dependent on the EEI.",
    "norm:misaligned_ldst_fully_hw_supported": "misaligned loads and stores can be handled in hardware",
    "norm:misaligned_ldst_invisible_trap": "via an invisible trap into the execution environment implementation",
    "norm:misaligned_ldst_hw_or_invisible_trap_func_of_addr": "combination of hardware and invisible trap depending on address.",
    "norm:misaligned_ldst_fully_hw_supported_or_visible_trap": "loads and stores that are not naturally aligned\nmay either complete execution successfully or raise an exception.",
    "norm:ldst_addr_misaligned_or_access_fault_exc": "The exception raised can be either an\naddress-misaligned exception or an access-fault exception.\nFor a memory access that would otherwise be able\nto complete except for the misalignment, an access-fault exception can\nbe raised instead of an address-misaligned exception if the misaligned\naccess should not be emulated, e.g., if accesses to the memory region\nhave side effects.",
    "norm:misaligned_ldst_contained_or_fatal_trap": "When an EEI does not guarantee misaligned loads and\nstores are handled invisibly, the EEI must define if exceptions caused\nby address misalignment result in a contained trap (allowing software\nrunning inside the execution environment to handle the trap) or a fatal\ntrap (terminating execution).",
    "norm:ldst_atomicity_for_aligned": "naturally aligned\nloads and stores are guaranteed to execute atomically",
    "norm:fence_op": "A FENCE\n(with fm=0000) orders all memory operations in its predecessor set\nbefore all memory operations in its successor set.",
    "norm:fence-tso_op": "FENCE.TSO orders\nall load operations in its predecessor set before all memory operations\nin its successor set, and all store operations in its predecessor set\nbefore all store operations in its successor set. This leaves non-AMO\nstore operations in the FENCE.TSO's predecessor set unordered with\nnon-AMO loads in its successor set.",
    "norm:fence-tso_ordering_rw_rw_ok": "Because FENCE RW,RW imposes a superset of the orderings that FENCE.TSO imposes, it is correct to ignore the fm field and implement FENCE.TSO as FENCE RW,RW.",
    "norm:fence_unused_flds_rsv": "The unused fields in the FENCE\ninstructions--rs1 and rd--are reserved\nfor finer-grain fences in future extensions. For forward compatibility,\nbase implementations shall ignore these fields",
    "norm:fence_cons_ok": "We chose a relaxed memory model to allow high performance from simple machine implementations and from likely future coprocessor or accelerator extensions. We separate out I/O ordering from memory R/W ordering to avoid unnecessary serialization within a device-driver hart and also to support alternative non-memory paths to control added coprocessors or I/O devices. Simple implementations may additionally ignore the predecessor and successor fields and always execute a conservative FENCE on all operations.",
    "norm:ecall_op1": "The ECALL instruction is used to make a service request to the execution environment.",
    "norm:ebreak_op1": "The EBREAK instruction is used to return control to a debugging environment.",
    "norm:hints_op": "HINTs do not change any architecturally\nvisible state, except for advancing the pc and any applicable\nperformance counters. Implementations are always allowed to ignore the\nencoded hints.",
    "norm:hints_enc": "Most RV32I HINTs are encoded as integer computational instructions with\nrd=x0. The other RV32I HINTs are encoded as FENCE instructions with\na null predecessor or successor set and with fm=0.",
    "norm:diff-rv32e-rv32i": "RV32E and RV64E use the same instruction-set encoding as RV32I and RV64I respectively, except that only registers x0-x15 are provided. All encodings specifying the other registers x16-x31 are reserved.",
    "norm:rv64i_xreg_sz": "RV64I widens the integer registers and supported user address space to\n64 bits (XLEN=64 in &lt;&lt;gprs&gt;&gt;).",
    "norm:rv64_w_sex": "These \"*W\"\ninstructions ignore the upper 32 bits of their inputs and always produce\n32-bit signed values, sign-extending them to 64 bits, i.e. bits XLEN-1\nthrough 31 are equal.",
    "norm:addiw_op": "ADDIW is an RV64I instruction that adds the sign-extended 12-bit\nimmediate to register rs1 and produces the proper sign extension of a\n32-bit result in rd.",
    "norm:addiw_overflow": "Overflows are ignored and the result is the low\n32 bits of the result sign-extended to 64 bits.",
    "norm:slliw_srliw_sraiw_op": "SLLIW, SRLIW, and SRAIW are RV64I-only instructions that are analogously\ndefined but operate on 32-bit values and sign-extend their 32-bit\nresults to 64 bits.",
    "norm:slliw_srliw_sraiw_imm5_rsv": "SLLIW, SRLIW, and SRAIW encodings with\nimm[5] {ne} 0 are reserved.",
    "norm:lui_op_rv64i": "LUI places the\n32-bit U-immediate into register rd, filling in the lowest 12 bits\nwith zeros. The 32-bit result is sign-extended to 64 bits.",
    "norm:auipc_op_rv64i": "AUIPC forms a 32-bit offset from the U-immediate, filling in the lowest\n12 bits with zeros, sign-extends the result to 64 bits, adds it to the\naddress of the AUIPC instruction, then places the result in register rd.",
    "norm:addw_subw_op": "ADDW and SUBW are RV64I-only instructions that are defined analogously\nto ADD and SUB but operate on 32-bit values and produce signed 32-bit results.",
    "norm:addw_subw_overflow": "Overflows are ignored, and the low 32-bits of the result is\nsign-extended to 64-bits and written to the destination register.",
    "norm:sll_srl_sra_sh_amt_rv64i": "In RV64I, only the low 6 bits of rs2 are considered\nfor the shift amount.",
    "norm:sllw_srlw_sraw_op": "SLLW, SRLW, and SRAW are RV64I-only instructions that are analogously\ndefined but operate on 32-bit values and sign-extend their 32-bit\nresults to 64 bits. The shift amount is given by rs2[4:0].",
    "norm:ld_op_rv64i": "The LD instruction loads a 64-bit value from memory into register rd\nfor RV64I.",
    "norm:lw_op_rv64i": "The LW instruction loads a 32-bit value from memory and sign-extends\nthis to 64 bits before storing it in register rd for RV64I.",
    "norm:lwu_op": "The LWU instruction, on the other hand, zero-extends the 32-bit value from\nmemory for RV64I.",
    "norm:lh_lhu_lb_lbu_op_rv64i": "LH and LHU are defined analogously for 16-bit values,\nas are LB and LBU for 8-bit values.",
    "norm:sd_sw_sh_sb_op_rv64i": "The SD, SW, SH, and SB instructions\nstore 64-bit, 32-bit, 16-bit, and 8-bit values from the low bits of\nregister rs2 to memory respectively.",
    "norm:fence_i_op": "A FENCE.I instruction orders all explicit memory accesses that precede the FENCE.I in program order before all instruction fetches that follow the FENCE.I in program order.",
    "norm:fence_i_rsv": "The unused fields in the FENCE.I instruction, funct12, rs1, and rd, are reserved for finer-grain fences in future extensions. For forward compatibility, base implementations shall ignore these fields, and standard software shall zero these fields.",
    "norm:csrrw_op": "The CSRRW (Atomic Read/Write CSR) instruction atomically swaps values in the CSRs and integer registers. CSRRW reads the old value of the CSR, zero-extends the value to XLEN bits, then writes it to integer register rd. The initial value in rs1 is written to the CSR. If rd=x0, then the instruction shall not read the CSR and shall not cause any of the side effects that might occur on a CSR read.",
    "norm:csrrs_op": "The CSRRS (Atomic Read and Set Bits in CSR) instruction reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be set in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be set in the CSR, if that CSR bit is writable.",
    "norm:csrrc_op": "The CSRRC (Atomic Read and Clear Bits in CSR) instruction reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be cleared in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be cleared in the CSR, if that CSR bit is writable.",
    "norm:csrrs_csrrc_rs1_x0": "For both CSRRS and CSRRC, if rs1=x0, then the instruction will not write to the CSR at all, and so shall not cause any of the side effects that might otherwise occur on a CSR write, nor raise illegal-instruction exceptions on accesses to read-only CSRs. Both CSRRS and CSRRC always read the addressed CSR and cause any read side effects regardless of rs1 and rd fields. Note that if rs1 specifies a register other than x0, and that register holds a zero value, the instruction will not action any attendant per-field side effects, but will action any side effects caused by writing to the entire CSR.",
    "norm:csrrw_rs1_x0": "A CSRRW with rs1=x0 will attempt to write zero to the destination CSR.",
    "norm:csrrsi_csrrci_uimm_zero": "For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these\ninstructions will not write to the CSR, and shall not cause any of the\nside effects that might otherwise occur on a CSR write, nor raise\nillegal-instruction exceptions on accesses to read-only CSRs.",
    "norm:csrrwi_rd_x0": "For\nCSRRWI, if rd=x0, then the instruction shall not read the CSR and\nshall not cause any of the side effects that might occur on a CSR read.",
    "norm:csrrwi_csrrsi_csrrci_ops": "The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS, and CSRRC respectively, except they update the CSR using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field instead of a value from an integer register. For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions will not write to the CSR, and shall not cause any of the side effects that might otherwise occur on a CSR write, nor raise illegal-instruction exceptions on accesses to read-only CSRs. For CSRRWI, if rd=x0, then the instruction shall not read the CSR and shall not cause any of the side effects that might occur on a CSR read. Both CSRRSI and CSRRCI will always read the CSR and cause any read side effects regardless of rd and rs1 fields.",
    "norm:csr_side_effects": "summarizes the behavior of the CSR instructions with respect to whether they read and/or write the CSR.",
    "norm:csr_rs1_uimm_side_effect": "The CSRRS[I] and CSRRC[I] instructions\nonly action side effects for fields for which the rs1 or uimm argument\nhas at least one bit set corresponding to that field.",
    "norm:csr_access_order": "In particular,\nunless specified otherwise, a CSR access is performed after the\nexecution of any prior instructions in program order whose behavior\nmodifies or is modified by the CSR state and before the execution of any\nsubsequent instructions in program order whose behavior modifies or is\nmodified by the CSR state.",
    "norm:csrr_order": "an explicit CSR read returns the\nCSR state before the execution of the instruction",
    "norm:csrw_order": "an explicit CSR\nwrite suppresses and overrides any implicit writes or modifications to\nthe same CSR by the same instruction.",
    "norm:csr_side_effects_synchronous": "Likewise, any side effects from an explicit CSR access are normally\nobserved to occur synchronously in program order. Unless specified\notherwise, the full consequences of any such side effects are observable\nby the very next instruction, and no consequences may be observed\nout-of-order by preceding instructions.",
    "norm:csr_weakly_ordered": "For the RVWMO memory consistency model (&lt;&lt;memorymodel&gt;&gt;), CSR accesses are weakly\nordered by default, so other harts or devices may observe CSR accesses\nin an order different from program order.",
    "norm:csr_memory_access_ordering": "In addition, CSR accesses are\nnot ordered with respect to explicit memory accesses, unless a CSR\naccess modifies the execution behavior of the instruction that performs\nthe explicit memory access or unless a CSR access and an explicit memory\naccess are ordered by either the syntactic dependencies defined by the\nmemory model or the ordering requirements defined by the Memory-Ordering\nPMAs section in Volume II of this manual.",
    "norm:csr_fence_ordering": "To enforce ordering in all\nother cases, software should execute a FENCE instruction between the\nrelevant accesses. For the purposes of the FENCE instruction, CSR read\naccesses are classified as device input (I), and CSR write accesses are\nclassified as device output (O).",
    "norm:csr_strongly_ordered": "The hardware platform may define that accesses to certain CSRs are\nstrongly ordered, as defined by the Memory-Ordering PMAs section in\nVolume II of this manual. Accesses to strongly ordered CSRs have\nstronger ordering constraints with respect to accesses to both weakly\nordered CSRs and accesses to memory-mapped I/O regions.",
    "norm:zihpm_op_sz_mode_acc_count": "RISC-V ISAs provide a set of up to thirty-two 64-bit performance\ncounters and timers",
    "norm:zihpm_op_sz_mode_acc_priv": "accessible via unprivileged XLEN-bit\nread-only CSR registers 0xC00–0xC1F",
    "norm:zihpm_op_sz_mode_acc_xlen32": "when XLEN=32, the upper 32 bits\nare accessed via CSR registers 0xC80–0xC9F",
    "norm:zihpm_op_sz_mode_acc_partition": "These counters are\ndivided between the \"Zicntr\" and \"Zihpm\" extensions.",
    "norm:zicntr_rdcycle_op": "The RDCYCLE pseudoinstruction reads the low XLEN bits of the cycle\nCSR which holds a count of the number of clock cycles executed by the\nprocessor core on which the hart is running from an arbitrary start time\nin the past.",
    "norm:zicntr_rdcycleh_op": "RDCYCLEH is only present when XLEN=32 and reads bits 63-32\nof the same cycle counter.",
    "norm:zicntr_rdtime_op": "The RDTIME pseudoinstruction reads the low XLEN bits of the \"time\" CSR,\nwhich counts wall-clock real time that has passed from an arbitrary\nstart time in the past.",
    "norm:zicntr_rdtimeh_op": "RDTIMEH is only present when XLEN=32 and reads\nbits 63-32 of the same real-time counter.",
    "norm:zicntr_time_hart_sync": "The real-time clocks of all harts must be synchronized to within one\ntick of the real-time clock.",
    "norm:zicntr_rdinstret_op": "The RDINSTRET pseudoinstruction reads the low XLEN bits of the\ninstret CSR, which counts the number of instructions retired by this\nhart from some arbitrary start point in the past.",
    "norm:zicntr_rdinstreth_op": "RDINSTRETH is only\npresent when XLEN=32 and reads bits 63-32 of the same instruction\ncounter.",
    "norm:hpmcounter_op_sz_mode": "The Zihpm extension comprises up to 29 additional unprivileged 64-bit\nhardware performance counters, hpmcounter3-hpmcounter31.",
    "norm:hpm_counter_op_sz_mode_xlen32": "When\nXLEN=32, the upper 32 bits of these performance counters are accessible\nvia additional CSRs hpmcounter3h- hpmcounter31h.",
    "norm:hpm_counter_op_sz_mode_dependency": "The Zihpm extension\ndepends on the Zicsr extension.",
    "norm:hpm_platform_specific_impl": "The implemented number and width of these additional counters, and the\nset of events they count, are platform-specific.",
    "norm:hpm_unimplemented_counter_access": "Accessing an\nunimplemented counter may cause an illegal-instruction exception or may\nreturn a constant value.",
    "norm:hpm_misconfigured_event_behavior": "If the configuration used to select the events\ncounted by a counter is misconfigured, the counter may return a constant\nvalue.",
    "norm:NTL-target_definition": "The NTL instructions do not change architectural state, nor do they alter the\narchitecturally visible effects of the target instruction.",
    "norm:NTL-P1_op": "The NTL.P1 instruction indicates that the target instruction does not\nexhibit temporal locality within the capacity of the innermost level of\nprivate cache in the memory hierarchy.",
    "norm:NTL-P1_enc": "NTL.P1 is encoded as\nADD x0, x0, x2.",
    "norm:NTL-PALL_op": "The NTL.PALL instruction indicates that the target instruction does not\nexhibit temporal locality within the capacity of any level of private\ncache in the memory hierarchy.",
    "norm:NTL-PALL_enc": "NTL.PALL is encoded as ADD x0, x0, x3.",
    "norm:NTL-S1_op": "The NTL.S1 instruction indicates that the target instruction does not\nexhibit temporal locality within the capacity of the innermost level of\nshared cache in the memory hierarchy.",
    "norm:NTL-S1_enc": "NTL.S1 is encoded as\nADD x0, x0, x4.",
    "norm:NTL-ALL_op": "The NTL.ALL instruction indicates that the target instruction does not\nexhibit temporal locality within the capacity of any level of cache in\nthe memory hierarchy.",
    "norm:NTL-ALL_enc": "NTL.ALL is encoded as ADD x0, x0, x5.",
    "norm:NTL-compressed_variants": "If the C or Zca extension is provided, compressed variants of these HINTs are\nalso provided: C.NTL.P1 is encoded as C.ADD x0, x2; C.NTL.PALL is\nencoded as C.ADD x0, x3; C.NTL.S1 is encoded as C.ADD x0, x4; and\nC.NTL.ALL is encoded as C.ADD x0, x5.",
    "norm:NTL_range": "The NTL instructions affect all memory-access instructions except the\ncache-management instructions in the Zicbom extension.",
    "norm:NTL_Zicob_prefetch_outer": "When an NTL instruction is applied to a prefetch hint in the Zicbop\nextension, it indicates that a cache line should be prefetched into a\ncache that is outer from the level specified by the NTL.",
    "norm:NTL_trap_behavior": "In the event that a trap is taken on the target instruction,\nimplementations are discouraged from applying the NTL to the first\ninstruction in the trap handler. Instead, implementations are\nrecommended to ignore the HINT in this case.",
    "norm:NTL-LR_SC_exception": "Since the NTL instructions are encoded as ADDs, they can be used within LR/SC loops without voiding the forward-progress guarantee. But, since using other loads and stores within an LR/SC loop does void the forward-progress guarantee, the only reason to use an NTL within such a loop is to modify the LR or the SC.",
    "norm:pause_op": "The PAUSE instruction is a HINT that indicates the current hart's rate\nof instruction retirement should be temporarily reduced or paused. The\nduration of its effect must be bounded and may be zero.",
    "norm:pause_enc_fence": "PAUSE is encoded as a FENCE instruction with pred=W, succ=0, fm=0,\nrd=x0, and rs1=x0.",
    "norm:Zimop_mop-r_op": "The Zimop extension defines 32 MOP instructions named MOP.R.n, where\nn is an integer between 0 and 31, inclusive.\nUnless redefined by another extension, these instructions simply write 0 to\nx[rd].",
    "norm:Zimop_mop-r_enc": "",
    "norm:Zimop_mop-rr_op": "The Zimop extension additionally defines 8 MOP instructions named\nMOP.RR.n, where n is an integer between 0 and 7, inclusive.\nUnless redefined by another extension, these instructions simply\nwrite 0 to x[rd].",
    "norm:Zimop_mop-rr_enc": "",
    "norm:Zcmop_op": "This section defines the \"Zcmop\" extension, which defines eight 16-bit MOP\ninstructions named C.MOP.n, where n is an odd integer between 1 and\n15, inclusive.",
    "norm:Zcmop_enc": "C.MOP.n is encoded in the reserved encoding space\ncorresponding to C.LUI xn, 0, as shown in &lt;&lt;norm:c-mop_enc&gt;&gt;.",
    "norm:Zcmop_instr_write": "Unlike the MOPs defined in the Zimop extension, the C.MOP.n instructions\nare defined to not write any register.",
    "norm:c-mop_enc": "Mnemonic|Encoding|Redefinable to read register\n===\nC.MOP.1|0110000010000001|x1¶C.MOP.3|0110000110000001|x3¶C.MOP.5|0110001010000001|x5¶C.MOP.7|0110001110000001|x7¶C.MOP.9|0110010010000001|x9¶C.MOP.11|0110010110000001|x11¶C.MOP.13|0110011010000001|x13¶C.MOP.15|0110011110000001|x15\n===",
    "norm:czero-eqz_op": "If rs2 contains the value zero, this instruction writes the value zero to rd.  Otherwise, this instruction copies the contents of rs1 to rd.",
    "norm:czero-eqz_inst_ctime": "Furthermore, if the Zkt extension is implemented, this instruction&#8217;s timing is independent of the data values in rs1 and rs2.",
    "norm:czero-nez_op": "If rs2 contains a nonzero value, this instruction writes the value zero to rd.  Otherwise, this instruction copies the contents of rs1 to rd.",
    "norm:czero-nez_zkt_timing": "Furthermore, if the Zkt extension is implemented, this instruction&#8217;s timing is independent of the data values in rs1 and rs2.",
    "norm:mul_op": "MUL performs an XLEN-bit×XLEN-bit multiplication of\nrs1 by rs2 and places the lower XLEN bits in the destination\nregister.",
    "norm:mulh_mulhu_mulhsu_op": "MULH, MULHU, and MULHSU perform the same multiplication but\nreturn the upper XLEN bits of the full 2×XLEN-bit\nproduct, for signed×signed,\nunsigned×unsigned, and rs1×unsigned rs2 multiplication.",
    "norm:mulw_op": "MULW is an RV64 instruction that multiplies the lower 32 bits of the\nsource registers, placing the sign extension of the lower 32 bits of the\nresult into the destination register.",
    "norm:div_divu_op": "DIV and DIVU perform an XLEN bits by XLEN bits signed and unsigned\ninteger division of rs1 by rs2, rounding towards zero.",
    "norm:rem_remu_op": "REM and REMU\nprovide the remainder of the corresponding division operation.",
    "norm:rem_result_sign": "For REM,\nthe sign of a nonzero result equals the sign of the dividend.",
    "norm:divw_divuw_op": "DIVW and DIVUW are RV64 instructions that divide the lower 32 bits of\nrs1 by the lower 32 bits of rs2, treating them as signed and\nunsigned integers, placing the 32-bit quotient in rd,\nsign-extended to 64 bits.",
    "norm:remw_remuw_op": "REMW and REMUW are RV64 instructions that\nprovide the corresponding signed and unsigned remainder\noperations.",
    "norm:remw_remuw_result_sign": "Both REMW and REMUW always sign-extend the 32-bit result\nto 64 bits, including on a divide by zero.",
    "norm:div_by_zero": "The quotient of division by zero has all bits\nset",
    "norm:rem_by_zero": "the remainder of division by zero equals the dividend.",
    "norm:signed_div_overflow": "Signed division overflow occurs only when the most-negative integer is divided\nby −1. The quotient of a signed division with overflow is\nequal to the dividend, and the remainder is zero.",
    "norm:a_aq_rl_bits": "each atomic\ninstruction has two bits, aq and rl, used to specify additional\nmemory ordering constraints as viewed by other RISC-V harts.",
    "norm:a_domain_specific_ordering": "The bits\norder accesses to one of the two address domains, memory or I/O,\ndepending on which address domain the atomic instruction is accessing.\nNo ordering constraint is implied to accesses to the other domain, and a\nFENCE instruction should be used to order across both domains.",
    "norm:a_no_aq_rl": "If both bits are clear, no additional ordering constraints are imposed\non the atomic memory operation.",
    "norm:a_acquire_semantics": "If only the aq bit is set, the atomic\nmemory operation is treated as an acquire access, i.e., no following\nmemory operations on this RISC-V hart can be observed to take place\nbefore the acquire memory operation.",
    "norm:a_release_semantics": "If only the rl bit is set, the\natomic memory operation is treated as a release access, i.e., the\nrelease memory operation cannot be observed to take place before any\nearlier memory operations on this RISC-V hart.",
    "norm:a_seq_cst_semantics": "If both the aq and rl\nbits are set, the atomic memory operation is sequentially consistent\nand cannot be observed to happen before any earlier memory operations or\nafter any later memory operations in the same RISC-V hart and to the\nsame address domain.",
    "norm:lr_w_op": "LR.W loads a word from the address in rs1, places the\nsign-extended value in rd, and registers a reservation set—a set of\nbytes that subsumes the bytes in the addressed word.",
    "norm:sc_w_success": "SC.W conditionally\nwrites a word in rs2 to the address in rs1: the SC.W succeeds only\nif the reservation is still valid and the reservation set contains the\nbytes being written. If the SC.W succeeds, the instruction writes the\nword in rs2 to memory, and it writes zero to rd.",
    "norm:sc_w_failure": "If the SC.W fails,\nthe instruction does not write to memory, and it writes a nonzero value\nto rd.",
    "norm:sc_retire_permission": "No SC.W instruction shall retire unless it passes memory permission checks,",
    "norm:sc_failed_side_effects": "but it is UNSPECIFIED whether any side effects of implicit address translation\nand protection memory accesses (such as setting a page-table entry D bit)\noccur on a failed SC.W.",
    "norm:sc_failed_as_store": "For the purposes of memory protection, a failed SC.W may be\ntreated like a store.",
    "norm:sc_reservation_invalidate": "Regardless of success or failure, executing an\nSC.W instruction invalidates any reservation held by this hart.",
    "norm:lr_sc_rv64": "LR.D and\nSC.D act analogously on doublewords and are only available on RV64. For\nRV64, LR.W and SC.W sign-extend the value placed in rd.",
    "norm:sc_failure_code": "The failure code with value 1 encodes an unspecified failure. Other\nfailure codes are reserved at this time. Portable software should only\nassume the failure code will be non-zero.",
    "norm:lr_sc_alignment": "For LR and SC, the Zalrsc extension requires that the address held in rs1\nbe naturally aligned to the size of the operand (i.e., eight-byte\naligned for doublewords and four-byte aligned for words). If the\naddress is not naturally aligned, an address-misaligned exception or an\naccess-fault exception will be generated. The access-fault exception can\nbe generated for a memory access that would otherwise be able to\ncomplete except for the misalignment, if the misaligned access should\nnot be emulated.",
    "norm:lr_reservation_set_size": "An implementation can register an arbitrarily large reservation set on\neach LR, provided the reservation set includes all bytes of the\naddressed data word or doubleword.",
    "norm:sc_pairs_latest_lr": "An SC can only pair with the most\nrecent LR in program order.",
    "norm:sc_success_conditions": "An SC may succeed only if no store from\nanother hart to the reservation set can be observed to have occurred\nbetween the LR and the SC, and if there is no other SC between the LR\nand itself in program order.",
    "norm:sc_device_write_failure": "An SC may succeed only if no write from a\ndevice other than a hart to the bytes accessed by the LR instruction can\nbe observed to have occurred between the LR and SC.",
    "norm:sc_addr_not_in_reservation_fail": "The SC must fail if the address is not within the reservation set of the\nmost recent LR in program order.",
    "norm:sc_other_hart_store_fail": "The SC must fail if a store to the\nreservation set from another hart can be observed to occur between the\nLR and SC.",
    "norm:sc_other_device_write_fail": "The SC must fail if a write from some other device to the\nbytes accessed by the LR can be observed to occur between the LR and SC.",
    "norm:sc_intervening_sc_fail": "An SC must fail\nif there is another SC (to any address) between the LR and the SC in\nprogram order.",
    "norm:lr_sc_atomicity_axiom": "The precise statement of the atomicity requirements for\nsuccessful LR/SC sequences is defined by the Atomicity Axiom in\n&lt;&lt;rvwmo&gt;&gt;.",
    "norm:sc_not_observable_before_lr": "An SC instruction can never be observed by another RISC-V hart before\nthe LR instruction that established the reservation.",
    "norm:lr_sc_aq_rl_software_rule": "Software should not set the rl bit on an LR instruction unless the\naq bit is also set, nor should software set the aq bit on an SC\ninstruction unless the rl bit is also set. LR.rl and SC.aq\ninstructions are not guaranteed to provide any stronger ordering than\nthose with both bits clear, but may result in lower performance.",
    "norm:constrained_lrsc_loop_size": "The loop comprises only an LR/SC sequence and code to retry the\nsequence in the case of failure, and must comprise at most 16\ninstructions placed sequentially in memory.",
    "norm:constrained_lrsc_instruction_set": "An LR/SC sequence begins with an LR instruction and ends with an SC\ninstruction. The dynamic code executed between the LR and SC\ninstructions can only contain instructions from the base ''I''\ninstruction set, excluding loads, stores, backward jumps, taken backward\nbranches, JALR, FENCE, and SYSTEM instructions.",
    "norm:constrained_lrsc_compressed_allowed": "Compressed forms of the aforementioned ''I'' instructions in the\nC (hence Zca) and Zcb extensions are also permitted.",
    "norm:constrained_lrsc_retry_code": "The code to retry a failing LR/SC sequence can contain backwards jumps\nand/or branches to repeat the LR/SC sequence, but otherwise has the same\nconstraint as the code between the LR and SC.",
    "norm:lrsc_eventuality_region": "The LR and SC addresses must lie within a memory region with the\nLR/SC eventuality property. The execution environment is responsible\nfor communicating which regions have this property.",
    "norm:lrsc_same_address_and_size": "The SC must be to the same effective address and of the same data size\nas the latest LR executed by the same hart.",
    "norm:unconstrained_lrsc_no_progress": "LR/SC sequences that do not lie within constrained LR/SC loops are\nunconstrained. Unconstrained LR/SC sequences might succeed on some\nattempts on some implementations, but might never succeed on other\nimplementations.",
    "norm:amo_operand_size": "AMOs\ncan either operate on doublewords (RV64 only) or words in memory. For\nRV64, 32-bit AMOs always sign-extend the value placed in rd, and\nignore the upper 32 bits of the original value of rs2.",
    "norm:amo_alignment": "For AMOs, the Zaamo extension requires that the address held in rs1 be\nnaturally aligned to the size of the operand (i.e., eight-byte aligned\nfor doublewords and four-byte aligned for words).",
    "norm:amo_misaligned_atomicity_granule": "The misaligned atomicity granule PMA, defined in Volume II of this manual,\noptionally relaxes this alignment requirement.\nIf present, the misaligned atomicity granule PMA specifies the size\nof a misaligned atomicity granule, a power-of-two number of bytes.\nThe misaligned atomicity granule PMA applies only to AMOs, loads and stores\ndefined in the base ISAs, and loads and stores of no more than XLEN bits\ndefined in the F, D, and Q extensions, and compressed encodings thereof.\nFor an instruction in that set, if all accessed bytes lie within the same\nmisaligned atomicity granule, the instruction will not raise an exception for\nreasons of address alignment, and the instruction will give rise to only one\nmemory operation for the purposes of RVWMO--i.e., it will execute atomically.",
    "norm:amo_release_consistency": "To help implement multiprocessor synchronization, the AMOs optionally\nprovide release consistency semantics. If the aq bit is set, then no\nlater memory operations in this RISC-V hart can be observed to take\nplace before the AMO. Conversely, if the rl bit is set, then other\nRISC-V harts will not observe the AMO before memory accesses preceding\nthe AMO in this RISC-V hart. Setting both the aq and the rl bit on\nan AMO makes the sequence sequentially consistent, meaning that it\ncannot be reordered with earlier or later memory operations from the\nsame hart.",
    "norm:Zawrs_wrs-nto_stall_exec": "Then a subsequent WRS.NTO instruction would cause the hart to temporarily\nstall execution in a low-power state until a store occurs to the reservation set\nor an interrupt is observed.",
    "norm:Zawrs_wrs-sto_stall_duration": "WRS.STO (WRS-with-short-timeout) is\nprovided that works like WRS.NTO but bounds the stall duration to an\nimplementation-define short timeout such that the stall is terminated on the\ntimeout if no other conditions have occurred to terminate the stall.",
    "norm:Zawrs_stall_terminate": "While stalled, an implementation is permitted to occasionally terminate the\nstall and complete execution for any reason.",
    "norm:Zawrs_exec_resume_rules": "WRS.NTO and WRS.STO instructions follow the rules of the WFI instruction\nfor resuming execution on a pending  interrupt.",
    "norm:Zawrs_priv_illegal_instr_excp": "When the TW (Timeout Wait) bit in mstatus is set and WRS.NTO is executed\nin any privilege mode other than M mode, and it does not complete within an\nimplementation-specific bounded time limit, the WRS.NTO instruction will cause\nan illegal-instruction exception.",
    "norm:Zawrs_virtual_instr_excp": "When executing in VS or VU mode, if the VTW bit is set in hstatus, the\nTW bit in mstatus is clear, and the WRS.NTO does not complete within an\nimplementation-specific bounded time limit, the WRS.NTO instruction will cause\na virtual-instruction  exception.",
    "norm:Zacas_rv32_amocas-w_op": "For RV32, AMOCAS.W atomically loads a 32-bit data value from address in rs1,\ncompares the loaded value to the 32-bit value held in rd, and if the comparison\nis bitwise equal, then stores the 32-bit value held in rs2 to the original\naddress in rs1. The value loaded from memory is placed into register rd.",
    "norm:Zacas_rv32_amocas-d_op": "For RV32, AMOCAS.D atomically loads 64-bits of a data value from address in\nrs1, compares the loaded value to a 64-bit value held in a register pair\nconsisting of rd and rd+1, and if the comparison is bitwise equal, then\nstores the 64-bit value held in the register pair rs2 and rs2+1 to the\noriginal address in rs1. The value loaded from memory is placed into the\nregister pair rd and rd+1.",
    "norm:Zacas_rv32_amocas-d_frst_pair_entry_reg_even": "The instruction requires the first register in\nthe pair to be even numbered; encodings with odd numbered registers specified\nin rs2 and rd are reserved.",
    "norm:Zacas_rv32_amocas-d_rs2_frst_reg_x0": "When the first register of a source register\npair is x0, then both halves of the pair read as zero.",
    "norm:Zacas_rv32_amocas-d_rd_frst_reg_x0": "When the first\nregister of a destination register pair is x0, then the entire register\nresult is discarded and neither destination register is written.",
    "norm:Zacas_rv64_amocas-w_op": "For RV64, AMOCAS.W atomically loads a 32-bit data value from address in\nrs1, compares the loaded value to the lower 32 bits of the value held in rd,\nand if the comparison is bitwise equal, then stores the lower 32 bits of the\nvalue held in rs2 to the original address in rs1. The 32-bit value loaded\nfrom memory is sign-extended and is placed into register rd.",
    "norm:Zacas_rv64_amocas-d_op": "For RV64, AMOCAS.D atomically loads 64-bits of a data value from address in\nrs1, compares the loaded value to a 64-bit value held in rd, and if the\ncomparison is bitwise equal, then stores the 64-bit value held in rs2 to the\noriginal address in rs1. The value loaded from memory is placed into register\nrd.",
    "norm:Zacas_rv64_amocas-q_op": "AMOCAS.Q (RV64 only) atomically loads 128-bits of a data value from address in\nrs1, compares the loaded value to a 128-bit value held in a register pair\nconsisting of rd and rd+1, and if the comparison is bitwise equal, then\nstores the 128-bit value held in the register pair rs2 and rs2+1 to the\noriginal address in rs1. The value loaded from memory is placed into the\nregister pair rd and rd+1.",
    "norm:Zacas_rv64_amocas-q_frst_pair_entry_reg_even": "The instruction requires the first register in\nthe pair to be even numbered; encodings with odd numbered registers specified in\nrs2 and rd are reserved.",
    "norm:Zacas_rv64_amocas-q_rs2_frst_reg_x0": "When the first register of a source register pair\nis x0, then both halves of the pair read as zero.",
    "norm:Zacas_rv64_amocas-q_rd_frst_reg_x0": "When the first register of a\ndestination register pair is x0, then the entire register result is discarded\nand neither destination register is written.",
    "norm:Zacas_amocas_rs1_addr_alignment": "AMOCAS.W/D/Q requires that the address\nheld in rs1 be naturally aligned to the size of the operand (i.e., 16-byte\naligned for quadwords, eight-byte aligned for doublewords, and four-byte\naligned for words).",
    "norm:Zacas_amocas_mem_op_success_aq_rl": "The memory operation performed by an\nAMOCAS.W/D/Q, when successful, has acquire semantics if aq bit is 1 and has\nrelease semantics if rl bit is 1.",
    "norm:Zacas_amocas_mem_op_fail_aq_rl": "The memory operation performed by an\nAMOCAS.W/D/Q, when not successful, has acquire semantics if aq bit is 1 but\ndoes not have release semantics, regardless of rl.",
    "norm:Zacas_amocas_w_permission": "An AMOCAS.W/D/Q instruction always requires write permissions.",
    "norm:Zabha_rd_sign_extension": "Byte and halfword AMOs always sign-extend the value placed in rd, and ignore\nthe image:../../build/images-out/stem-2aa35a881e52a6683f571d117edc7f47.svg[width=136,height=12] bits of the original value in rs2.",
    "norm:Zabha_amocas-BH_ignore_bits": "The\nAMOCAS.[B|H] instructions similarly ignore the image:../../build/images-out/stem-2aa35a881e52a6683f571d117edc7f47.svg[width=136,height=12]\nbits of the original value in rd.",
    "norm:Zabha_rs1_align_addr": "Similar to the AMOs specified in the A extension, the Zabha extension mandates\nthat the address contained in the rs1 register must be naturally aligned to\nthe size of the operand.",
    "norm:zalasr_def": "The Zalasr (Load-Acquire and Store-Release) extension provides load-acquire and store-release instructions in RISC-V.\nThese can be important for high performance designs by enabling finer-grained synchronisation than is possible with fences alone, by providing a unidirectional fence.",
    "norm:zalasr_builds_on_amo": "The Zalasr extension builds on the atomic support provided by the Zaamo (Atomic Memory Operations), Zalrsc (Load-Reserved and Store-Conditional), and Zabha (Byte and Halfword Atomic Memory Operations) extensions by providing additional atomic operations (although it can be implemented independently of them).",
    "norm:zalasr_atomic_ordered": "The Zalasr instructions are atomic loads and stores that support ordering annotations.",
    "norm:zalasr_signext_rd": "The Zalasr instructions always sign-extend the value placed in rd",
    "norm:zalasr_ignore_rs2_upper": "ignore the upper bits of the value of rs2.",
    "norm:zalasr_natural_align": "The instructions in the Zalasr extension require that the address held in rs1 be naturally aligned to the size in bytes (2^width^) of the operand.",
    "norm:zalasr_misaligned_exception": "If the address is not naturally aligned, an address-misaligned exception or an access-fault exception will be generated.",
    "norm:zalasr_misaligned_pma_relax": "The misaligned atomicity granule PMA, defined in Volume II of this manual, optionally relaxes this alignment requirement.",
    "norm:zalasr_misaligned_single_op": "If all accessed bytes lie within the same misaligned atomicity granule, the instruction will not raise an exception for reasons of address alignment, and the instruction will give rise to only one memory operation for the purposes of RVWMO—i.e., it will execute atomically.",
    "norm:ldaq_atomic_load_enc": "Encoding",
    "norm:ldaq_atomic_load_op": "This instruction loads 2^width^ bytes of memory from rs1 atomically and writes the result into rd.",
    "norm:ldaq_signext_rule": "If the size (2^width+3^) is less than XLEN, it is sign-extended to fill the destination register.",
    "norm:ldaq_aq_required": "This load must have the ordering annotation aq",
    "norm:ldaq_rl_optional": "may have ordering annotation rl encoded in the instruction.",
    "norm:ldaq_rcsc_semantics": "The instruction always has an \"acquire-RCsc\" annotation, and if the bit rl is set the instruction has a \"release-RCsc\" annotation.",
    "norm:ldaq_no_aq_reserved": "The versions without the aq bit set are RESERVED.",
    "norm:ldaq_rv64_only": "LD.{AQ, AQRL} is RV64-only.",
    "norm:sdrl_atomic_store_enc": "Encoding",
    "norm:sdrl_atomic_store_op": "This instruction stores 2^width^ bytes of memory from rs1 atomically.",
    "norm:sdrl_rl_required": "This store must have ordering annotation rl",
    "norm:sdrl_aq_optional": "may have ordering annotation aq encoded in the instruction.",
    "norm:sdrl_rcsc_semantics": "The instruction always has an \"release-RCsc\" annotation, and if the bit aq is set the instruction has a \"acquire-RCsc\" annotation.",
    "norm:sdrl_no_rl_reserved": "The versions without the rl bit set are RESERVED.",
    "norm:sdrl_rv64_only": "SD.{RL, AQRL} is RV64-only.",
    "norm:rvwmo_single_hart_op": "Under RVWMO, code running on a single hart appears to execute in order\nfrom the perspective of other memory instructions in the same hart, but\nmemory instructions from another hart may observe the memory\ninstructions from the first hart being executed in a different order.",
    "norm:rvwmo_only_mainmem": "This chapter defines the memory model for regular main memory\noperations. The interaction of the memory model with I/O memory,\ninstruction fetches, FENCE.I, page-table walks, and SFENCE.VMA is not\n(yet) formalized.",
    "norm:rvwmo_excludes_overlap_widths": "Memory consistency models supporting overlapping\nmemory accesses of different widths simultaneously remain an active area of academic\nresearch and are not yet fully understood. The specifics of how memory\naccesses of different sizes interact under RVWMO are specified to the\nbest of our current abilities",
    "norm:rvwmo_single_copy_atomic": "All memory operations are single-copy atomic:\nthey can never be observed in a partially complete state.",
    "norm:rvwmo_aligned_memop": "Each aligned memory instruction that accesses XLEN or\nfewer bits gives rise to exactly one memory operation, unless specified otherwise.",
    "norm:rvwmo_aligned_amo_memop": "An aligned AMO gives rise to a single memory operation that\nis both a load operation and a store operation simultaneously.",
    "norm:rvwmo_sc_fail_no_memop": "An unsuccessful SC instruction does not give rise to any memory operations.",
    "norm:rvwmo_v_p_multi_memops": "ISA extensions such as V (Vector) and the upcoming P (SIMD)\nmay give rise to multiple memory operations.",
    "norm:rvwmo_misaligned_ldst_memops": "A misaligned load or store instruction may be decomposed\ninto a set of component memory operations of any granularity.",
    "norm:rvwmo_fp_gt_xlen_memops": "A floating-point load or store of more than XLEN bits may\nalso be decomposed into a set of component memory operations of any granularity.",
    "norm:rvwmo_order_multi_memops": "The memory operations generated by such instructions\nare not ordered with respect to each other in program order, but they are ordered normally with\nrespect to the memory operations generated by preceding and subsequent\ninstructions in program order.",
    "norm:rvwmo_misaligned_in_atomic_pma": "if misaligned atomics are supported via the\nmisaligned atomicity granule PMA, then AMOs within an atomicity granule are not decomposed, nor are\nloads and stores defined in the base ISAs, nor are loads and stores of no more\nthan XLEN bits defined in the F, D, and Q extensions.",
    "norm:rvwmo_ppo_lead-in": "The complete definition of preserved program order is as follows (and note that AMOs are simultaneously both loads and stores): memory operation a precedes memory operation b in preserved program order (and hence also in the global memory order) if a precedes b in program order, a and b both access regular main memory (rather than I/O regions), and any of the following hold:",
    "norm:rvwmo_ppo_overlap": "Overlapping-Address Orderings",
    "norm:rvwmo_ppo_overlap1": "b is a store, and a and b access overlapping memory addresses",
    "norm:rvwmo_ppo_overlap2": "a and b are loads, x is a byte read by both a and\nb, there is no store to x between a and b in program order, and a and b return values for x\nwritten by different memory operations",
    "norm:rvwmo_ppo_overlap3": "a is generated by an AMO or SC instruction, b is a load, and\nb returns a value written by a",
    "norm:rvwmo_ppo_sync": "Explicit Synchronization",
    "norm:rvwmo_ppo_sync1": "There is a FENCE instruction that orders a before b",
    "norm:rvwmo_ppo_sync2": "a has an acquire annotation annotation",
    "norm:rvwmo_ppo_sync3": "b has a release annotation",
    "norm:rvwmo_ppo_sync4": "a and b both have RCsc annotations",
    "norm:rvwmo_ppo_sync5": "a is paired with b",
    "norm:rvwmo_ppo_dep": "Syntactic Dependencies",
    "norm:rvwmo_ppo_dep1": "b has a syntactic address dependency on a",
    "norm:rvwmo_ppo_dep2": "b has a syntactic data dependency on a",
    "norm:rvwmo_ppo_dep3": "b is a store, and b has a syntactic control dependency on a",
    "norm:rvwmo_ppo_pipe": "Pipeline Dependencies",
    "norm:rvwmo_ppo_pipe1": "b is a load, and there exists some store m between a and b\nin program order such that m has an address or data dependency on a,\nand b returns a value written by m",
    "norm:rvwmo_ppo_pipe2": "b is a store, and there exists some instruction m between a\nand b in program order such that m has an address dependency on a",
    "norm:rvwmo_obeyed": "An execution of a RISC-V program obeys the RVWMO memory consistency model only if there exists a global memory order conforming to preserved program order and satisfying the load value axiom, the atomicity axiom, and the progress axiom.",
    "norm:rvwmo_ld_val_axiom_lead-in": "Each byte of each load i returns the value written to that byte by the store that is the latest in global memory order among the following stores:",
    "norm:rvwmo_ld_val_axiom_list": "Stores that write that byte and that precede i in the global memory order\nStores that write that byte and that precede i in program order",
    "norm:rvwmo_atomicity_axiom": "If r and w are paired load and store operations generated by aligned LR and SC instructions in a hart h, s is a store to byte x, and r returns a value written by s, then s must precede w in the global memory order, and there can be no store from a hart other than h to byte x following s and preceding w in the global memory order.",
    "norm:rvwmo_progress_axiom": "No memory operation may be preceded in the global memory order by an infinite sequence of other memory operations.",
    "norm:rvtso_adj_rvwmo": "RVTSO makes the following adjustments to RVWMO:",
    "norm:ztso_ld": "All load operations behave as if they have an acquire-RCpc annotation",
    "norm:ztso_sd": "All store operations behave as if they have a release-RCpc annotation.",
    "norm:ztso_amo": "All AMOs behave as if they have both acquire-RCsc and release-RCsc\nannotations.",
    "norm:ztso_vect_mem": "Additionally, if the Ztso extension is implemented, then vector memory\ninstructions in the V extension and Zve family of extensions follow RVTSO at\nthe instruction level.",
    "norm:PPO_overlap_1": "if a precedes b in program order,\nthen a will precede b in the global memory order if:",
    "norm:PPO_overlap_2": "a is an invalidate, clean, or flush, b is a load, and a and b access\noverlapping memory addresses",
    "norm:invalidate_load_val1": "If no clean or flush operations on x precede i in the global memory order,\neither the initial value of x or the value of any store to x that precedes\ni",
    "norm:invalidate_load_val2": "If no store to x precedes a clean or flush operation on x in the global\nmemory order and if the clean or flush operation on x precedes i in the\nglobal memory order, either the initial value of x or the value of any store\nto x that precedes i",
    "norm:invalidate_load_val3": "If a store to x precedes a clean or flush operation on x in the global\nmemory order and if the clean or flush operation on x precedes i in the\nglobal memory order, either the value of the latest store to x that precedes\nthe latest clean or flush operation on x or the value of any store to x\nthat both precedes i and succeeds the latest clean or flush operation on x\nthat precedes i",
    "norm:invalidate_load_val4": "The value of any store to x by a non-coherent agent regardless of the above\nconditions",
    "norm:PMP_same": "The PMP access control bits shall be the same for all physical addresses in\nthe cache block, and if write permission is granted by the PMP access control\nbits, read permission shall also be granted",
    "norm:PMA_same": "The PMAs shall be the same for all physical addresses in the cache block,\nand if write permission is granted by the supported access type PMAs, read\npermission shall also be granted",
    "norm:cbo_rsv": "If the above constraints are not met, the behavior of a CBO instruction is\nUNSPECIFIED.",
    "norm:cbm_access": "A cache-block management instruction is permitted to access the specified cache\nblock whenever a load instruction or store instruction is permitted to access\nthe corresponding physical addresses.",
    "norm:cbm_unperm_fault": "If\naccess to the cache block is not permitted, a cache-block management instruction\nraises a store page-fault or store guest-page-fault exception if address\ntranslation does not permit any access or raises a store access-fault exception\notherwise.",
    "norm:cbm_unperm_translate": "During address translation, the instruction also checks the accessed\nbit and may either raise an exception or set the bit as required.",
    "norm:cbz_access": "A cache-block zero instruction is permitted to access the specified cache block\nwhenever a store instruction is permitted to access the corresponding physical\naddresses and when the PMAs indicate that cache-block zero instructions are a\nsupported access type.",
    "norm:cbz_unperm_fault": "If access to the cache block is not permitted, a\ncache-block zero instruction raises a store page-fault or store guest-page-fault\nexception if address translation does not permit write access or raises a store\naccess-fault exception otherwise.",
    "norm:cbz_unperm_translate": "During address translation, the instruction\nalso checks the accessed and dirty bits and may either raise an exception or set\nthe bits as required.",
    "norm:cbp_access": "A cache-block prefetch instruction is permitted to access the specified cache\nblock whenever a load instruction, store instruction, or instruction fetch is\npermitted to access the corresponding physical addresses.",
    "norm:cbp_unperm_noexcep": "If access to the cache\nblock is not permitted, a cache-block prefetch instruction does not raise any\nexceptions and shall not access any caches or memory.",
    "norm:cbp_unperm_translate": "During address\ntranslation, the instruction does not check the accessed and dirty bits and\nneither raises an exception nor sets the bits.",
    "norm:fault_excep_csr": "When a page-fault, guest-page-fault, or access-fault exception is taken, the\nrelevant *tval CSR is written with the faulting effective address (i.e. the\nvalue of rs1).",
    "norm:no_addr_misaligned_excep": "CMO instructions do not generate address-misaligned exceptions.",
    "norm:h_trans_cache": "For the purposes of writing the mtinst or htinst register on a trap, the following standard transformation is defined for cache-block management instructions and cache-block zero instructions:",
    "norm:cbo-inval": "A CBO.INVAL instruction executes or raises either an illegal-instruction exception or a virtual-instruction exception based on the state of the xenvcfg.CBIE fields:",
    "norm:cbo-clean_cbo-flush": "A CBO.CLEAN or CBO.FLUSH instruction executes or raises an illegal-instruction or virtual-instruction exception based on the state of the xenvcfg.CBCFE bits:",
    "norm:cbo-zero_basedon_xenvcfg-CBZE": "Finally, a CBO.ZERO instruction executes or raises an illegal-instruction or virtual-instruction exception based on the state of the xenvcfg.CBZE bits:",
    "norm:cbxe_unaffected": "The CBIE/CBCFE/CBZE fields in each xenvcfg register do not affect the read and write behavior of the same fields in the other xenvcfg registers.",
    "norm:cbo-zero_specified_block": "These instructions operate on the cache block, or the memory locations\ncorresponding to the cache block, whose effective address is specified in rs1.",
    "norm:prefetch_operating_block": "These instructions operate on the cache block whose effective address is the sum\nof the base address specified in rs1 and the sign-extended offset encoded in\nimm[11:0], where imm[4:0] shall equal 0b00000.",
    "norm:cbo-clean_op": "A cbo.clean instruction performs a clean operation on the cache block whose\neffective address is the base address specified in rs1.",
    "norm:cbo-clean_offset": "The offset operand may\nbe omitted; otherwise, any expression that computes the offset shall evaluate to\nzero.",
    "norm:cbo-flush_op": "A cbo.flush instruction performs a flush operation on the cache block whose\nthat contains the address specified in rs1.",
    "norm:cbo-flush_unaligned": "It is not required that rs1 is\naligned to the size of a cache block.",
    "norm:cbo-inval_op": "A cbo.inval instruction performs an invalidate operation on the cache block\nthat contains the address specified in rs1.",
    "norm:cbo-inval_unaligned": "It is not required that rs1 is\naligned to the size of a cache block.",
    "norm:cbo-zero_op": "A cbo.zero instruction performs stores of zeros to the full set of bytes\ncorresponding to the cache block that contains the address specified in rs1.",
    "norm:cbo-zero_unaligned": "It is not required that rs1 is aligned to the size of a cache block.",
    "norm:cbo-zero_offset": "The assembly offset operand may be omitted. If it isn&#8217;t then any expression that computes the offset shall evaluate to zero.",
    "norm:prefetch-i_op": "A prefetch.i instruction indicates to hardware that the cache block whose effective address is the sum of the base address specified in rs1 and the sign-extended offset encoded in imm[11:0], where imm[4:0] equals 0b00000, is likely to be accessed by an instruction fetch in the near future.",
    "norm:prefetch-r_op": "A prefetch.r instruction indicates to hardware that the cache block whose effective address is the sum of the base address specified in rs1 and the sign-extended offset encoded in imm[11:0], where imm[4:0] equals 0b00000, is likely to be accessed by a data read (i.e. load) in the near future.",
    "norm:prefetch-w_op": "A prefetch.w instruction indicates to hardware that the cache block whose effective address is the sum of the base address specified in rs1 and the sign-extended offset encoded in imm[11:0], where imm[4:0] equals 0b00000, is likely to be accessed by a data write (i.e. store) in the near future.",
    "norm:f_ieee_compliance": "single-precision floating-point computational instructions compliant\nwith the IEEE 754-2008 arithmetic standard [.citation]",
    "norm:f_depends_zicsr": "The F extension depends on the \"Zicsr\" extension for control and status register access.",
    "norm:flen": "The F extension adds 32 floating-point registers, f0-f31, each 32\nbits wide",
    "norm:fcsr_op_sz_acc": "The floating-point control and status register, fcsr, is a RISC-V control and status register (CSR). It is a 32-bit read/write register that selects the dynamic rounding mode for floating-point arithmetic operations and holds the accrued exception flags, as shown in .",
    "norm:fflags_frm_op_sz_acc": "The fields within the fcsr can also be accessed individually through different CSR addresses, and separate assembler pseudoinstructions are defined for these accesses. The FRRM instruction reads the Rounding Mode field frm (fcsr bits 7&#8212;&#8203;5) and copies it into the least-significant three bits of integer register rd, with zero in all other bits. FSRM swaps the value in frm by copying the original value into integer register rd, and then writing a new value obtained from the three least-significant bits of integer register rs1 into frm. FRFLAGS and FSFLAGS are defined analogously for the Accrued Exception Flags field fflags (fcsr bits 4&#8212;&#8203;0).",
    "norm:fcsr_rsv": "Bits 31&#8212;&#8203;8 of the fcsr are reserved for other standard extensions. If these extensions are not present, implementations shall ignore writes to these bits and supply a zero value when read. Standard software should preserve the contents of these bits.",
    "norm:roundingmode_dynamic": "Floating-point operations use either a static rounding mode encoded in\nthe instruction, or a dynamic rounding mode held in frm. Rounding\nmodes are encoded as shown in &lt;&lt;norm:dyn_round_enc&gt;&gt;. A value of 111 in the\ninstruction's rm field selects the dynamic rounding mode held in\nfrm",
    "norm:roundingmode_rsv": "The behavior of floating-point instructions that depend on\nrounding mode when executed with a reserved rounding mode is reserved, including both static reserved rounding modes (101-110) and dynamic reserved rounding modes (101-111). Some instructions, including widening conversions, have the rm field but are nevertheless mathematically unaffected by the rounding mode; software should set their rm field to\nRNE (000) but implementations must treat the rm field as usual (in\nparticular, with regard to decoding legal vs. reserved encodings).",
    "norm:dyn_round_enc": "Rounding Mode|Mnemonic|Meaning\n===\n000|RNE|Round to Nearest, ties to Even¶001|RTZ|Round towards Zero¶010|RDN|Round Down (towards −∞)¶011|RUP|Round Up (towards +∞)¶100|RMM|Round to Nearest, ties to Max Magnitude¶101||Reserved for future use.¶110||Reserved for future use.¶111|DYN|In instruction&#8217;s rm field, selects dynamic rounding mode; In Rounding Mode register, reserved.\n===",
    "norm:fcsr-fflags_op": "The accrued exception flags indicate the exception conditions that have\narisen on any floating-point arithmetic instruction since the field was\nlast reset by software, as shown in &lt;&lt;bitdef&gt;&gt;",
    "norm:F_canonical_NaN": "Except when otherwise stated, if the result of a floating-point operation is NaN, it is the canonical NaN. The canonical NaN has a positive sign and all significand bits clear except the MSB, a.k.a. the quiet bit. For single-precision floating-point, this corresponds to the pattern 0x7fc00000.",
    "norm:ieee_std_subnormal": "Operations on subnormal numbers are handled in accordance with the IEEE 754-2008 standard.",
    "norm:ieee_std_tininess": "In the parlance of the IEEE standard, tininess is detected after rounding.",
    "norm:fsw_flw_op": "Floating-point loads and stores use the same base+offset addressing mode as the integer base ISAs, with a base address in register rs1 and a 12-bit signed byte offset. The FLW instruction loads a single-precision floating-point value from memory into floating-point register rd. FSW stores a single-precision value from floating-point register rs2 to memory.",
    "norm:fsw_flw_atomic_align": "FLW and FSW are only guaranteed to execute atomically if the effective address is naturally aligned.",
    "norm:fsw_flw_bits_maintained": "FLW and FSW do not modify the bits being transferred; in particular, the payloads of non-canonical NaNs are preserved.",
    "norm:fp_misaligned": "As described in , the execution environment defines whether misaligned floating-point loads and stores are handled invisibly or raise a contained or fatal trap.",
    "norm:fadd-s_fmul-s_op": "FADD.S and FMUL.S\nperform single-precision floating-point addition and multiplication\nrespectively, between rs1 and rs2",
    "norm:fsub-s_op": "FSUB.S performs the\nsingle-precision floating-point subtraction of rs2 from rs1",
    "norm:fdiv-s_op": "FDIV.S performs the single-precision floating-point division of rs1 by rs2",
    "norm:fsqrt-s_op": "FSQRT.S computes the square root of rs1",
    "norm:fp_rd": "In each case, the result is written to rd.",
    "norm:F_fmt_single": "The 2-bit floating-point format field fmt is encoded as shown in . It is set to S (00) for all instructions in the F extension.",
    "norm:F_rm_field": "All floating-point operations that perform rounding can select the rounding mode using the rm field with the encoding shown in .",
    "norm:fmin-s_fmax-s_op": "Floating-point minimum-number and maximum-number instructions FMIN.S and FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd",
    "norm:fmin-s_fmax-s_zero_compare": "For the purposes of these instructions only, the value −0.0 is considered to be less than the value +0.0",
    "norm:fmin-s_fmax-s_both_nan_input": "If both inputs are NaNs, the result is the canonical NaN",
    "norm:fmin-s_fmax-s_one_nan_input": "If only one operand is a NaN, the result is the non-NaN operand",
    "norm:fmin-s_fmax-s_signaling_nan_nv": "Signaling NaN inputs set the invalid operation exception flag, even when the result is not NaN",
    "norm:fma_rs3": "Floating-point fused multiply-add instructions require a new standard instruction format. R4-type instructions specify three source registers (rs1, rs2, and rs3) and a destination register (rd). This format is only used by the floating-point fused multiply-add instructions.",
    "norm:fmadd-s_op": "FMADD.S multiplies the values in rs1 and rs2, adds the value in rs3, and writes the final result to rd. FMADD.S computes (rs1×rs2)+rs3.",
    "norm:fmsub-s_op": "FMSUB.S multiplies the values in rs1 and rs2, subtracts the value in rs3, and writes the final result to rd. FMSUB.S computes (rs1×rs2)−rs3.",
    "norm:fnmsub-s_op": "FNMSUB.S multiplies the values in rs1 and rs2, negates the product, adds the value in rs3, and writes the final result to rd. FNMSUB.S computes −(rs1×rs2)+rs3.",
    "norm:fnmadd-s_op": "FNMADD.S multiplies the values in rs1 and rs2, negates the product, subtracts the value in rs3, and writes the final result to rd. FNMADD.S computes −(rs1×rs2)−rs3.",
    "norm:fma_nv_flag": "The fused multiply-add instructions must set the invalid operation exception flag when the multiplicands are ∞ and zero, even when the addend is a quiet NaN.",
    "norm:fcvt-l-s_fcvt-w-s_op": "FCVT.W.S or\nFCVT.L.S converts a floating-point number in floating-point register\nrs1 to a signed 32-bit or 64-bit integer, respectively, in integer\nregister rd",
    "norm:fcvt-s-w_fcvt-s-l_op": "FCVT.S.W or FCVT.S.L converts a 32-bit or 64-bit signed\ninteger, respectively, in integer register rs1 into a floating-point\nnumber in floating-point register rd",
    "norm:fcvt-wu-s_fcvt-lu-s_fcvt-s-wu_fcvt-s-lu_op": "FCVT.WU.S, FCVT.LU.S, FCVT.S.WU,\nand FCVT.S.LU variants convert to or from unsigned integer values. For\nXLEN&gt;32, FCVT.W[U].S sign-extends the 32-bit result to the destination register width",
    "norm:fcvt_long_float_rv64_only": "FCVT.L[U].S and FCVT.S.L[U] are RV64-only instructions",
    "norm:fcvt_unrepresentable_nv": "If the rounded result is not representable in the\ndestination format, it is clipped to the nearest value and the invalid\nflag is set",
    "norm:fcvt_int_float_valid_input": "&lt;&lt;int_conv&gt;&gt; gives the range of valid inputs\nfor FCVT.int.S and the behavior for invalid inputs",
    "norm:fcvt_round": "All floating-point to integer and integer to floating-point conversion instructions round according to the rm field. A floating-point register can be initialized to floating-point positive zero using FCVT.S.W rd, x0, which will never set any exception flags.",
    "norm:fcvt_nx": "All floating-point conversion instructions set the Inexact exception flag if the rounded result differs from the operand value and the Invalid exception flag is not set.",
    "norm:fsgnj-s_fsgnjn-s_fsgnjx-s_op": "Floating-point to floating-point sign-injection instructions, FSGNJ.S,\nFSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the\nsign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign\nbit; for FSGNJN, the result's sign bit is the opposite of rs2's sign\nbit; and for FSGNJX, the sign bit is the XOR of the sign bits of rs1\nand rs2. Sign-injection instructions do not set floating-point\nexception flags, nor do they canonicalize NaNs",
    "norm:fmv-x-w_op": "FMV.X.W moves the single-precision value in floating-point register rs1 represented in IEEE 754-2008 encoding to the lower 32 bits of integer register rd. The bits are not modified in the transfer, and in particular, the payloads of non-canonical NaNs are preserved. For RV64, the higher 32 bits of the destination register are filled with copies of the floating-point number's sign bit",
    "norm:fmv-w-x_op": "FMV.W.X moves the single-precision value encoded in IEEE 754-2008 standard encoding from the lower 32 bits of integer register rs1 to the floating-point register rd. The bits are not modified in the transfer, and in particular, the payloads of non-canonical NaNs are preserved.",
    "norm:feq-s_flt-s_fle-s_op": "Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the specified comparison between floating-point registers (rs1 = rs2, rs1 &lt; rs2, rs1 ≤ rs2) writing 1 to the integer register rd if the condition holds, and 0 otherwise.",
    "norm:flt-s_fle-s_signaling": "FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as\nsignaling comparisons: that is, they set the invalid operation\nexception flag if either input is NaN",
    "norm:feq-s_quiet": "FEQ.S performs a quiet\ncomparison: it only sets the invalid operation exception flag if either input is a signaling NaN",
    "norm:feq-s_flt-s_fle-s_NaN_input": "For all three instructions, the result is 0 if either operand is NaN",
    "norm:fclass-s_op": "The FCLASS.S instruction examines the value in floating-point register rs1 and writes to integer register rd a 10-bit mask that indicates the class of the floating-point number. The format of the mask is described in . The corresponding bit in rd will be set if the property is true and clear otherwise. All other bits in rd are cleared. Note that exactly one bit in rd will be set. FCLASS.S does not set the floating-point exception flags.",
    "norm:D_flen_64": "The D extension widens the 32 floating-point registers, f0-f31, to\n64 bits (FLEN=64 in &lt;&lt;fprs&gt;&gt;",
    "norm:fp_nan-boxing": "When multiple floating-point precisions are supported, then valid values of narrower n-bit types, n&lt;FLEN, are represented in the lower n bits of an FLEN-bit NaN value, in a process termed NaN-boxing. The upper bits of a valid NaN-boxed value must be all 1s. Valid NaN-boxed n-bit values therefore appear as negative quiet NaNs (qNaNs) when viewed as any wider m-bit value, n &lt; m ≤ FLEN. Any operation that writes a narrower result to an 'f' register must write all 1s to the uppermost FLEN-n bits to yield a legal NaN-boxedvalue.",
    "norm:FP_transfer_instrs_narrow_transfer_in": "A narrower n-bit transfer, n&lt;FLEN, into the f registers will create a valid NaN-boxed value",
    "norm:FP_transfer_instrs_narrow_transfer_out": "A narrower\nn-bit transfer out of the floating-point registers will\ntransfer the lower n bits of the register ignoring the\nupper FLEN-n bits",
    "norm:FP_nontransfer_instrs_improper_nan-boxed_input": "Apart from transfer operations described in the previous paragraph, all other floating-point operations on narrower n-bit operations, n&lt;FLEN, check if the input operands are correctly NaN-boxed, i.e., all upper FLEN-n bits are 1. If so, the n least-significant bits of the input are used as the input value, otherwise the input value is treated as an n-bit canonical NaN.",
    "norm:fld_op": "The FLD instruction loads a double-precision floating-point value from\nmemory into floating-point register rd",
    "norm:fsd_op": "FSD stores a double-precision\nvalue from the floating-point registers to memory",
    "norm:fld_fsd_atomic_align": "FLD and FSD are only guaranteed to execute atomically if the effective address is naturally aligned and XLEN≥64.",
    "norm:fld_fsd_bits_maintained": "FLD and FSD do not modify the bits being transferred; in particular, the payloads of non-canonical NaNs are preserved.",
    "norm:D_computational_instrs": "The double-precision floating-point computational instructions are defined analogously to their single-precision counterparts, but operate on double-precision operands and produce double-precision results.",
    "norm:fcvt-w-d_fcvt-l-d_op": "FCVT.W.D or\nFCVT.L.D converts a double-precision floating-point number in\nfloating-point register rs1 to a signed 32-bit or 64-bit integer,\nrespectively, in integer register rd",
    "norm:fcvt-d-w_fcvt-d-l_op": "FCVT.D.W or FCVT.D.L converts a\n32-bit or 64-bit signed integer, respectively, in integer register rs1\ninto a double-precision floating-point number in floating-point register\nrd",
    "norm:fcvt-wu-d_fcvt-lu-d_fcvt-d-wu_fcvt-d-lu_op": "FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU variants convert to\nor from unsigned integer values",
    "norm:fcvt-w-d_fcvt-wu-d_sign_ext": "For RV64, FCVT.W[U].D sign-extends the\n32-bit result",
    "norm:fcvt_long_double_rv64_only": "FCVT.L[U].D and FCVT.D.L[U] are RV64-only instructions.",
    "norm:fcvt_int_double_valid_input": "The range of valid inputs for FCVT.int.D and the behavior for invalid\ninputs are the same as for FCVT.int.S",
    "norm:fcvt-s-d_fcvt-d-s_op": "The double-precision to single-precision and single-precision to\ndouble-precision conversion instructions, FCVT.S.D and FCVT.D.S, are\nencoded in the OP-FP major opcode space and both the source and\ndestination are floating-point registers. The rs2 field encodes the\ndatatype of the source, and the fmt field encodes the datatype of the\ndestination",
    "norm:fcvt_float_rounding": "FCVT.S.D rounds according to the RM field; FCVT.D.S will\nnever round",
    "norm:fsgnj-d_fsgnjn-d_fsgnjx-d_op": "Floating-point to floating-point sign-injection instructions, FSGNJ.D, FSGNJN.D, and FSGNJX.D are defined analogously to the single-precision sign-injection instruction.",
    "norm:fmv-x-d_op": "FMV.X.D moves\nthe double-precision value in floating-point register rs1 to a\nrepresentation in IEEE 754-2008 standard encoding in integer register\nrd",
    "norm:fmv-d-x_op": "FMV.D.X moves the double-precision value encoded in IEEE 754-2008\nstandard encoding from the integer register rs1 to the floating-point\nregister rd",
    "norm:fmv_bits_preserved": "FMV.X.D and FMV.D.X do not modify the bits being transferred; in particular, the payloads of non-canonical NaNs are preserved.",
    "norm:D_compare_instrs": "The double-precision floating-point compare instructions are defined analogously to their single-precision counterparts, but operate on double-precision operands.",
    "norm:fclass-d_op": "The double-precision floating-point classify instruction, FCLASS.D, is defined analogously to its single-precision counterpart, but operates on double-precision operands.",
    "norm:Q_flen_128": "The floating-point\nregisters are now extended to hold either a single, double, or\nquad-precision floating-point value (FLEN=128).",
    "norm:fsq_flq_op": "New 128-bit variants of LOAD-FP and STORE-FP instructions are added, encoded with a new value for the funct3 width field.",
    "norm:fsq_flq_atomic_align": "FLQ and FSQ are only guaranteed to execute atomically if the effective address is naturally aligned and XLEN=128.",
    "norm:fsq_flq_bits_maintained": "FLQ and FSQ do not modify the bits being transferred; in particular, the payloads of non-canonical NaNs are preserved.",
    "norm:Q_computational_instrs": "The quad-precision floating-point computational instructions are defined analogously to their double-precision counterparts, but operate on quad-precision operands and produce quad-precision results.",
    "norm:fcvt-w-q_fcvt-l-q_op": "FCVT.W.Q or FCVT.L.Q converts a quad-precision\nfloating-point number to a signed 32-bit or 64-bit integer,\nrespectively",
    "norm:fcvt-q-w_fcvt-q-l_op": "FCVT.Q.W or FCVT.Q.L converts a 32-bit or 64-bit signed\ninteger, respectively, into a quad-precision floating-point number",
    "norm:fcvt-wu-q_fcvt-lu-q_fcvt-q-wu_fcvt-q-lu_op": "FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU, and FCVT.Q.LU variants convert to or\nfrom unsigned integer values",
    "norm:fcvt_long_quad_rv64_only": "FCVT.L[U].Q and FCVT.Q.L[U] are RV64-only\ninstructions",
    "norm:fcvt-s-q_fcvt-q-s_op": "FCVT.S.Q or\nFCVT.Q.S converts a quad-precision floating-point number to a\nsingle-precision floating-point number, or vice-versa, respectively",
    "norm:fcvt-d-q_fcvt-q-d_op": "FCVT.D.Q or FCVT.Q.D converts a quad-precision floating-point number to\na double-precision floating-point number, or vice-versa, respectively",
    "norm:fsgnj-q_fsgnjn-q_fsgnjx-q_op": "Floating-point to floating-point sign-injection instructions, FSGNJ.Q, FSGNJN.Q, and FSGNJX.Q are defined analogously to the double-precision sign-injection instruction.",
    "norm:Q_compare_instrs": "The quad-precision floating-point compare instructions are defined analogously to their double-precision counterparts, but operate on quad-precision operands.",
    "norm:fclass-q_op": "The quad-precision floating-point classify instruction, FCLASS.Q, is defined analogously to its double-precision counterpart, but operates on quad-precision operands.",
    "norm:fsh_flh_op": "New 16-bit variants of LOAD-FP and STORE-FP instructions are added, encoded with a new value for the funct3 width field.",
    "norm:fsh_flh_atomic_align": "FLH and FSH are only guaranteed to execute atomically if the effective address is naturally aligned.",
    "norm:fsh_flh_bits_maintained": "FLH and FSH do not modify the bits being transferred; in particular, the payloads of non-canonical NaNs are preserved. FLH NaN-boxes the result written to rd, whereas FSH ignores all but the lower 16 bits in rs2.",
    "norm:Zfh_computational_instrs": "The half-precision floating-point computational instructions are defined analogously to their single-precision counterparts, but operate on half-precision operands and produce half-precision results.",
    "norm:fcvt-w-h_fcvt-l-h_op": "FCVT.W.H or FCVT.L.H converts a half-precision\nfloating-point number to a signed 32-bit or 64-bit integer,\nrespectively",
    "norm:fcvt-h-w_fcvt-h-l_op": "FCVT.H.W or FCVT.H.L converts a 32-bit or 64-bit signed\ninteger, respectively, into a half-precision floating-point number",
    "norm:fcvt-wu-h_fcvt-lu-h_fcvt-h-wu_fcvt-h-lu_op": "FCVT.WU.H, FCVT.LU.H, FCVT.H.WU, and FCVT.H.LU variants convert to or\nfrom unsigned integer values",
    "norm:fcvt_long_half_rv64_only": "FCVT.L[U].H and FCVT.H.L[U] are RV64-only\ninstructions.",
    "norm:fcvt-s-h_fcvt-h-s_op": "FCVT.S.H or\nFCVT.H.S converts a half-precision floating-point number to a\nsingle-precision floating-point number, or vice-versa, respectively",
    "norm:fcvt-d-h_fcvt-h-d_op": "If\nthe D extension is present, FCVT.D.H or FCVT.H.D converts a\nhalf-precision floating-point number to a double-precision\nfloating-point number, or vice-versa, respectively",
    "norm:fcvt-q-h_fcvt-h-q_op": "If the Q extension\nis present, FCVT.Q.H or FCVT.H.Q converts a half-precision\nfloating-point number to a quad-precision floating-point number, or\nvice-versa, respectively",
    "norm:fsgnj-h_fsgnjn-h_fsgnjx-h_op": "Floating-point to floating-point sign-injection instructions, FSGNJ.H, FSGNJN.H, and FSGNJX.H are defined analogously to the single-precision sign-injection instruction.",
    "norm:fmv-x-h_op": "FMV.X.H moves the half-precision\nvalue in floating-point register rs1 to a representation in IEEE\n754-2008 standard encoding in integer register rd, filling the upper\nXLEN-16 bits with copies of the floating-point number's sign bit",
    "norm:fmv-h-x_op": "FMV.H.X moves the half-precision value encoded in IEEE 754-2008 standard encoding from the lower 16 bits of integer register rs1 to the floating-point register rd, NaN-boxing the result.",
    "norm:fmv_half_bits_preverved": "FMV.X.H and FMV.H.X do not modify the bits being transferred; in particular, the payloads of non-canonical NaNs are preserved.",
    "norm:Zfh_compare_instrs": "The half-precision floating-point compare instructions are defined analogously to their single-precision counterparts, but operate on half-precision operands.",
    "norm:fclass-h_op": "The half-precision floating-point classify instruction, FCLASS.H, is defined analogously to its single-precision counterpart, but operates on half-precision operands.",
    "norm:zfhmin": "The Zfhmin extension includes the following instructions from the Zfh extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the D extension is present, the FCVT.D.H and FCVT.H.D instructions are also included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions are additionally included.",
    "norm:bf16_subnorm": "All of the BF16 instructions in the extensions defined in this specification (i.e., Zfbfmin, Zvfbfmin, and Zvfbfwma) fully support subnormal numbers. That is, instructions are able to accept subnormal values as inputs and they can produce subnormal results.",
    "norm:fcvt-bf16-s_op": "Narrowing convert FP32 value to a BF16 value. Round according to the RM field.",
    "norm:fcvt-s-bf16_op": "Converts a BF16 value to an FP32 value. The conversion is exact.",
    "norm:vfncvtbf16-f-f-w_sew_rsv": "SEW is any value other than 16",
    "norm:vfncvtbf16-f-f-w_op": "Narrowing convert from FP32 to BF16. Round according to the frm register.",
    "norm:vfwcvtbf16-f-f-v_sew_rsv": "SEW is any value other than 16",
    "norm:vfwcvtbf16-f-f-v_op": "Widening convert from BF16 to FP32. The conversion is exact.",
    "norm:vfwmaccbf16_sew_rsv": "SEW is any value other than 16",
    "norm:vfwmaccbf16_op": "This instruction performs a widening fused multiply-accumulate operation, where each pair of BF16 values are multiplied and their unrounded product is added to the corresponding FP32 accumulate value. The sum is rounded according to the frm register.",
    "norm:vfwmaccbf16_vv": "In the vector-vector version, the BF16 elements are read from vs1 and vs2 and FP32 accumulate value is read from vd. The FP32 result is written to the destination register vd.",
    "norm:vfwmaccbf16_vf": "The vector-scalar version is similar, but instead of reading elements from vs1, a scalar BF16 value is read from the FPU register rs1.",
    "norm:fli-s_op": "The FLI.S instruction loads one of 32 single-precision floating-point constants, encoded in the rs1 field, into floating-point register rd. The correspondence of rs1 field values and single-precision floating-point values is shown in . FLI.S is encoded like FMV.W.X, but with rs2=1.",
    "norm:fli-d_op": "If the D extension is implemented, FLI.D performs the analogous operation, but loads a double-precision value into floating-point register rd. Note that entry 1 (corresponding to the minimum positive normal value) has a numerically different value for double-precision than for single-precision. FLI.D is encoded like FLI.S, but with fmt=D.",
    "norm:fli-q_op": "If the Q extension is implemented, FLI.Q performs the analogous operation, but loads a quad-precision value into floating-point register rd. Note that entry 1 (corresponding to the minimum positive normal value) has a numerically different value for quad-precision. FLI.Q is encoded like FLI.S, but with fmt=Q.",
    "norm:fli-h_op": "If the Zfh or Zvfh extension is implemented, FLI.H performs the analogous operation, but loads a half-precision floating-point value into register rd. Note that entry 1 (corresponding to the minimum positive normal value) has a numerically different value for half-precision. Furthermore, since 216 is not representable in half-precision floating-point, entry 29 in the table instead loads positive infinity—i.e., it is redundant with entry 30. FLI.H is encoded like FLI.S, but with fmt=H.",
    "norm:fmaxm-s_fminm-s_op": "The FMINM.S and FMAXM.S instructions are defined like the FMIN.S and FMAX.S instructions, except that if either input is NaN, the result is the canonical NaN.",
    "norm:fmaxm-d_fminm-d_op": "If the D extension is implemented, FMINM.D and FMAXM.D instructions are analogously defined to operate on double-precision numbers.",
    "norm:fmaxm-h_fminm-h_op": "If the Zfh extension is implemented, FMINM.H and FMAXM.H instructions are analogously defined to operate on half-precision numbers.",
    "norm:fmaxm-q_fminm-q_op": "If the Q extension is implemented, FMINM.Q and FMAXM.Q instructions are analogously defined to operate on quad-precision numbers.",
    "norm:fround-s_op": "The FROUND.S instruction rounds the single-precision floating-point\nnumber in floating-point register rs1 to an integer, according to the\nrounding mode specified in the instruction's rm field. It then writes\nthat integer, represented as a single-precision floating-point number,\nto floating-point register rd",
    "norm:fround-s_zero_inf": "Zero and infinite inputs are copied to\nrd unmodified",
    "norm:fround-s_nan_nv": "Signaling NaN inputs cause the invalid operation\nexception flag to be set; no other exception flags are set",
    "norm:froundnx-s_op": "The FROUNDNX.S instruction is defined similarly, but it also sets the inexact exception flag if the input differs from the rounded result and is not NaN. FROUNDNX.S is encoded like FCVT.S.D, but with rs2=5.",
    "norm:fround-d_froundnx-d_op": "If the D extension is implemented, FROUND.D and FROUNDNX.D instructions are analogously defined to operate on double-precision numbers. They are encoded like FCVT.D.S, but with rs2=4 and 5, respectively,",
    "norm:fround-h_froundnx-h_op": "If the Zfh extension is implemented, FROUND.H and FROUNDNX.H instructions are analogously defined to operate on half-precision numbers. They are encoded like FCVT.H.S, but with rs2=4 and 5, respectively,",
    "norm:fround-q_froundnx-q_op": "If the Q extension is implemented, FROUND.Q and FROUNDNX.Q instructions are analogously defined to operate on quad-precision numbers. They are encoded like FCVT.Q.S, but with rs2=4 and 5, respectively,",
    "norm:fcvtmod-w-d_op": "The FCVTMOD.W.D instruction is defined similarly to the FCVT.W.D instruction, with the following differences. FCVTMOD.W.D always rounds towards zero. Bits 31:0 are taken from the rounded, unbounded two&#8217;s complement result, then sign-extended to XLEN bits and written to integer register rd. ±∞ and NaN are converted to zero.",
    "norm:fcvtmod-w-d_flags": "Floating-point exception flags are raised the same as they would be for FCVT.W.D with the same input operand.",
    "norm:fcvtmod-w-d_rsw": "It\nis encoded like FCVT.W.D, but with the rs2 field set to 8 and the rm\nfield set to 1 (RTZ). Other rm values are reserved.",
    "norm:fmvh-x-d_op": "For RV32 only, if the D extension is implemented, the FMVH.X.D instruction moves bits 63:32 of floating-point register rs1 into integer register rd. It is encoded in the OP-FP major opcode with funct3=0, rs2=1, and funct7=1110001.",
    "norm:fmvp-d-x_op": "For RV32 only, if the D extension is implemented, the FMVP.D.X instruction moves a double-precision number from a pair of integer registers into a floating-point register. Integer registers rs1 and rs2 supply bits 31:0 and 63:32, respectively; the result is written to floating-point register rd. FMVP.D.X is encoded in the OP-FP major opcode with funct3=0 and funct7=1011001.",
    "norm:fmvh-x-q_op": "For RV64 only, if the Q extension is implemented, the FMVH.X.Q instruction moves bits 127:64 of floating-point register rs1 into integer register rd. It is encoded in the OP-FP major opcode with funct3=0, rs2=1, and funct7=1110011.",
    "norm:fmvp-q-x_op": "For RV64 only, if the Q extension is implemented, the FMVP.Q.X instruction moves a double-precision number from a pair of integer registers into a floating-point register. Integer registers rs1 and rs2 supply bits 63:0 and 127:64, respectively; the result is written to floating-point register rd. FMVP.Q.X is encoded in the OP-FP major opcode with funct3=0 and funct7=1011011.",
    "norm:fleq-s_fltq-s_op": "The FLEQ.S and FLTQ.S instructions are defined like the FLE.S and FLT.S instructions, except that quiet NaN inputs do not cause the invalid operation exception flag to be set.",
    "norm:fleq-d_fltq-d_op": "If the D extension is implemented, FLEQ.D and FLTQ.D instructions are analogously defined to operate on double-precision numbers.",
    "norm:fleq-h_fltq-h_op": "If the Zfh extension is implemented, FLEQ.H and FLTQ.H instructions are analogously defined to operate on half-precision numbers.",
    "norm:fleq-q_fltq-q_op": "If the Q extension is implemented, FLEQ.Q and FLTQ.Q instructions are analogously defined to operate on quad-precision numbers.",
    "norm:Zfinx_F_instrs": "The Zfinx extension adds all of the instructions that the F extension adds, except for the transfer instructions FLW, FSW, FMV.W.X, FMV.X.W, C.FLW[SP], and C.FSW[SP].",
    "norm:Zfinx_x_regs": "The Zfinx variants of these F-extension instructions have the same semantics, except that whenever such an instruction would have accessed an f register, it instead accesses the x register with the same number.",
    "norm:Zfinx_narrow_operands": "Floating-point operands of width w &lt; XLEN bits occupy bits w-1:0 of an x register. Floating-point operations on w-bit operands ignore operand bits XLEN-1: w.",
    "norm:Zfinx_narrow_result": "Floating-point operations that produce w &lt; XLEN-bit results fill bits XLEN-1: w with copies of bit w-1 (the sign bit).",
    "norm:Zdinx_D_instrs": "The Zdinx extension adds all of the instructions that the D extension adds, except for the transfer instructions FLD, FSD, FMV.D.X, FMV.X.D, C.FLD[SP], and C.FSD[SP].",
    "norm:Zdinx_x_regs": "The Zdinx variants of these D-extension instructions have the same semantics, except that whenever such an instruction would have accessed an f register, it instead accesses the x register with the same number.",
    "norm:Zdinx_x_reg_pair": "Double-precision operands in RV32Zdinx are held in aligned x-register pairs, i.e., register numbers must be even. Use of misaligned (odd-numbered) registers for double-width floating-point operands is reserved.",
    "norm:Zdinx_endianness": "Regardless of endianness, the lower-numbered register holds the low-order bits, and the higher-numbered register holds the high-order bits: e.g., bits 31:0 of a double-precision operand in RV32Zdinx might be held in register x14, with bits 63:32 of that operand held in x15.",
    "norm:Zdinx_x0_write": "When a double-width floating-point result is written to x0, the entire write takes no effect: e.g., for RV32Zdinx, writing a double-precision result to x0 does not cause x1 to be written.",
    "norm:Zdinx_x0_read": "When x0 is used as a double-width floating-point operand, the entire operand is zero—i.e., x1 is not accessed.",
    "norm:Zhinx_Zfh_instrs": "The Zhinx extension adds all of the instructions that the Zfh extension adds, except for the transfer instructions FLH, FSH, FMV.H.X, and FMV.X.H.",
    "norm:Zhinx_x_regs": "The Zhinx variants of these Zfh-extension instructions have the same semantics, except that whenever such an instruction would have accessed an f register, it instead accesses the x register with the same number.",
    "norm:Zfhinxmin_instrs": "The Zhinxmin extension includes the following instructions from the Zhinx extension: FCVT.S.H and FCVT.H.S. If the Zdinx extension is present, the FCVT.D.H and FCVT.H.D instructions are also included.",
    "norm:Zfinx_mstatus-FS_zero": "In the standard privileged architecture defined in Volume II, the mstatus field FS is hardwired to 0 if the Zfinx extension is implemented, and FS no longer affects the trapping behavior of floating-point instructions or fcsr accesses.",
    "norm:Zfinx_misa-F_D_Q_zero": "The misa bits F, D, and Q are hardwired to 0 when the Zfinx extension is implemented.",
    "norm:Zca_align16": "The C extension allows 16-bit instructions to be freely\nintermixed with 32-bit instructions, with the latter now able to start\non any 16-bit boundary, i.e., IALIGN=16.",
    "norm:Zca_no_misaligned": "With the addition of the C\nextension, no instructions can raise instruction-address-misaligned\nexceptions.",
    "norm:Zca_regs8": "CIW,\nCL, CS, CA, and CB are limited to just 8 of them.\n&lt;&lt;registers&gt;&gt; lists these popular registers, which\ncorrespond to registers x8 to x15.",
    "norm:Zc_fp_regs": "Compressed register-based floating-point loads and stores also use the\nCL and CS formats respectively, with the eight registers mapping to f8 to f15.",
    "norm:c-lwsp_op": "C.LWSP loads a 32-bit value from memory into register rd. It computes\nan effective address by adding the zero-extended offset, scaled by 4,\nto the stack pointer, x2. It expands to lw rd, offset(x2).",
    "norm:c-lwsp_rsv": "C.LWSP is\nvalid only when rd≠x0; the code points with rd=x0 are reserved.",
    "norm:c-ldsp_op": "C.LDSP is an RV64C-only instruction that loads a 64-bit value\nfrom memory into register rd. It computes its effective address by\nadding the zero-extended offset, scaled by 8, to the stack pointer,\nx2. It expands to ld rd, offset(x2).",
    "norm:c-ldsp_rsv": "C.LDSP is valid only when\nrd≠x0; the code points with\nrd=x0 are reserved.",
    "norm:c-flwsp_op": "C.FLWSP is an RV32FC-only instruction that loads a single-precision\nfloating-point value from memory into floating-point register rd. It\ncomputes its effective address by adding the zero-extended offset,\nscaled by 4, to the stack pointer, x2. It expands to\nflw rd, offset(x2).",
    "norm:c-fldsp_op": "C.FLDSP is an RV32DC/RV64DC-only instruction that loads a\ndouble-precision floating-point value from memory into floating-point\nregister rd. It computes its effective address by adding the\nzero-extended offset, scaled by 8, to the stack pointer, x2. It\nexpands to fld rd, offset(x2).",
    "norm:c-swsp_op": "C.SWSP stores a 32-bit value in register rs2 to memory. It computes an\neffective address by adding the zero-extended offset, scaled by 4, to\nthe stack pointer, x2. It expands to sw rs2, offset(x2).",
    "norm:c-sdsp_op": "C.SDSP is an RV64C-only instruction that stores a 64-bit value in\nregister rs2 to memory. It computes an effective address by adding the\nzero-extended offset, scaled by 8, to the stack pointer, x2. It\nexpands to sd rs2, offset(x2).",
    "norm:c-fswsp_op": "C.FSWSP is an RV32FC-only instruction that stores a single-precision\nfloating-point value in floating-point register rs2 to memory. It\ncomputes an effective address by adding the zero-extended offset,\nscaled by 4, to the stack pointer, x2. It expands to\nfsw rs2, offset(x2).",
    "norm:c-fsdwsp_op": "C.FSDSP is an RV32DC/RV64DC-only instruction that stores a\ndouble-precision floating-point value in floating-point register rs2\nto memory. It computes an effective address by adding the\nzero-extended offset, scaled by 8, to the stack pointer, x2. It\nexpands to fsd rs2, offset(x2).",
    "norm:c-lw_op": "C.LW loads a 32-bit value from memory into register\nrd′. It computes an effective address by adding the\nzero-extended offset, scaled by 4, to the base address in register\nrs1′. It expands to lw rd′, offset(rs1′).",
    "norm:c-ld_op": "C.LD is an RV64C-only instruction that loads a 64-bit value from\nmemory into register rd′. It computes an effective\naddress by adding the zero-extended offset, scaled by 8, to the base\naddress in register rs1′. It expands to\nld rd′, offset(rs1′).",
    "norm:c-flw_op": "C.FLW is an RV32FC-only instruction that loads a single-precision\nfloating-point value from memory into floating-point register\nrd′. It computes an effective address by adding the\nzero-extended offset, scaled by 4, to the base address in register\nrs1′. It expands to\nflw rd′, offset(rs1′).",
    "norm:c-fld_op": "C.FLD is an RV32DC/RV64DC-only instruction that loads a double-precision\nfloating-point value from memory into floating-point register\nrd′. It computes an effective address by adding the\nzero-extended offset, scaled by 8, to the base address in register\nrs1′. It expands to\nfld rd′, offset(rs1′).",
    "norm:c-sw_op": "C.SW stores a 32-bit value in register rs2′ to memory.\nIt computes an effective address by adding the zero-extended offset,\nscaled by 4, to the base address in register rs1′. It\nexpands to sw rs2′, offset(rs1′).",
    "norm:c-sd_op": "C.SD is an RV64C-only instruction that stores a 64-bit value in\nregister rs2′ to memory. It computes an effective\naddress by adding the zero-extended offset, scaled by 8, to the base\naddress in register rs1′. It expands to\nsd rs2′, offset(rs1′).",
    "norm:c-fsw_op": "C.FSW is an RV32FC-only instruction that stores a single-precision\nfloating-point value in floating-point register rs2′ to\nmemory. It computes an effective address by adding the zero-extended\noffset, scaled by 4, to the base address in register\nrs1′. It expands to\nfsw rs2′, offset(rs1′).",
    "norm:c-fsd_op": "C.FSD is an RV32DC/RV64DC-only instruction that stores a\ndouble-precision floating-point value in floating-point register\nrs2′ to memory. It computes an effective address by\nadding the zero-extended offset, scaled by 8, to the base address in\nregister rs1′. It expands to\nfsd rs2′, offset(rs1′).",
    "norm:Zca_offsets_mul2": "As with base RVI instructions, the offsets of all RVC\ncontrol transfer instructions are in multiples of 2 bytes.",
    "norm:c-j_op": "C.J performs an unconditional control transfer. The offset is\nsign-extended and added to the pc to form the jump target address. C.J\ncan therefore target a {pm}2 KiB range. C.J expands to\njal x0, offset.",
    "norm:c-jal_op": "C.JAL is an RV32C-only instruction that performs the same operation as\nC.J, but additionally writes the address of the instruction following\nthe jump (pc+2) to the link register, x1. C.JAL expands to\njal x1, offset.",
    "norm:c-jr_op": "C.JR (jump register) performs an unconditional control transfer to the\naddress in register rs1. C.JR expands to jalr x0, 0(rs1).",
    "norm:c-jr_rsv": "C.JR is\nvalid only when rs1≠x0; the code\npoint with rs1=x0 is reserved.",
    "norm:c-jalr_op": "C.JALR (jump and link register) performs the same operation as C.JR, but\nadditionally writes the address of the instruction following the jump\n(pc+2) to the link register, x1. C.JALR expands to\njalr x1, 0(rs1).",
    "norm:c-jalr_ebreak": "C.JALR is valid only when\nrs1≠x0; the code point with\nrs1=x0 corresponds to the C.EBREAK\ninstruction.",
    "norm:c-beqz_op": "C.BEQZ performs conditional control transfers. The offset is\nsign-extended and added to the pc to form the branch target address.\nIt can therefore target a {pm}256 B range. C.BEQZ takes the\nbranch if the value in register rs1′ is zero. It\nexpands to beq rs1′, x0, offset.",
    "norm:c-bnez_op": "C.BNEZ is defined analogously, but it takes the branch if\nrs1′ contains a nonzero value. It expands to\nbne rs1′, x0, offset.",
    "norm:c-li_op": "C.LI loads the sign-extended 6-bit immediate, imm, into register rd.\nC.LI expands into addi rd, x0, imm.",
    "norm:c-li_hint": "The C.LI code points with rd=x0 are HINTs.",
    "norm:c-lui_op": "C.LUI loads the non-zero 6-bit immediate field into bits 17–12 of the\ndestination register, clears the bottom 12 bits, and sign-extends bit 17\ninto all higher bits of the destination. C.LUI expands into\nlui rd, imm.",
    "norm:c-lui_rsv": "C.LUI is valid only when\nrd≠x2,\nand when the immediate is not equal to zero. The code points with\nimm=0 are reserved.\nThe code points with rd=x2 and imm≠0 correspond to the\nC.ADDI16SP instruction.",
    "norm:c-lui_hint": "The code points with rd=x0 and imm≠0 are HINTs.",
    "norm:c-addi_op": "C.ADDI adds the non-zero sign-extended 6-bit immediate to the value in\nregister rd then writes the result to rd. C.ADDI expands into\naddi rd, rd, imm.",
    "norm:c-addi_hint": "The code points with rd≠0 and imm=0 are HINTs.",
    "norm:c-addi_nop": "The code points with rd=x0 encode the C.NOP instruction, of\nwhich the code points with imm≠0 are HINTs.",
    "norm:c-addiw_op": "C.ADDIW is an RV64C-only instruction that performs the same\ncomputation but produces a 32-bit result, then sign-extends result to 64\nbits. C.ADDIW expands into addiw rd, rd, imm. The immediate can be\nzero for C.ADDIW, where this corresponds to sext.w rd.",
    "norm:c-addiw_rsv": "C.ADDIW is\nvalid only when rd≠x0; the code points with\nrd=x0 are reserved.",
    "norm:c-addi16sp_op": "C.ADDI16SP (add immediate to stack pointer)\nshares the opcode with C.LUI, but has a destination field of\nx2. C.ADDI16SP adds the non-zero sign-extended 6-bit immediate to the\nvalue in the stack pointer (sp=x2), where the immediate is scaled to\nrepresent multiples of 16 in the range [-512, 496]. C.ADDI16SP is used to\nadjust the stack pointer in procedure prologues and epilogues. It\nexpands into addi x2, x2, nzimm[9:4].",
    "norm:c-addi16sp_rsv": "C.ADDI16SP is valid only when\nnzimm≠0; the code point with nzimm=0 is reserved.",
    "norm:c-addi4spn_op": "C.ADDI4SPN (add immediate to stack pointer, non-destructive)\nis a CIW-format instruction that adds a zero-extended\nnon-zero immediate, scaled by 4, to the stack pointer, x2, and writes\nthe result to rd′. This instruction is used to generate\npointers to stack-allocated variables, and expands to\naddi rd′, x2, nzuimm[9:2].",
    "norm:c-addi4spn_rsv": "C.ADDI4SPN is valid only when\nnzuimm≠0; the code points with nzuimm=0 are\nreserved.",
    "norm:c-slli_op": "C.SLLI is a CI-format instruction that performs a logical left shift of\nthe value in register rd then writes the result to rd. The shift\namount is encoded in the shamt field.\nC.SLLI expands into slli rd, rd, shamt[5:0].",
    "norm:c-slli_hint": "The C.SLLI code points with shamt=0 or with rd=x0 are HINTs.",
    "norm:c-slli_shamt5": "For RV32C, shamt[5] must be zero; the code points with shamt[5]=1\nare designated for custom extensions.",
    "norm:c-srli_op": "C.SRLI is a CB-format instruction that performs a logical right shift of\nthe value in register rd′ then writes the result to\nrd′. The shift amount is encoded in the shamt field.\nC.SRLI expands into srli rd′, rd′, shamt.",
    "norm:c-srli_hint": "The C.SRLI code points with shamt=0 are HINTs.",
    "norm:c-srli_shamt5": "For RV32C, shamt[5] must be zero; the code points with shamt[5]=1\nare designated for custom extensions.",
    "norm:c-srai_op": "C.SRAI is defined analogously to C.SRLI, but instead performs an\narithmetic right shift. C.SRAI expands to\nsrai rd′, rd′, shamt.",
    "norm:c-andi_op": "C.ANDI is a CB-format instruction that computes the bitwise AND of the\nvalue in register rd′ and the sign-extended 6-bit\nimmediate, then writes the result to rd′. C.ANDI\nexpands to andi rd′, rd′, imm.",
    "norm:c-mv_op": "C.MV copies the value in register rs2 into register rd. C.MV expands\ninto add rd, x0, rs2.",
    "norm:c-mv_jr": "C.MV is valid only when\nrs2≠x0; the code points with rs2=x0 correspond to the C.JR instruction.",
    "norm:c-mv_hint": "The code points with rs2≠x0 and rd=x0 are HINTs.",
    "norm:c-add_op": "C.ADD adds the values in registers rd and rs2 and writes the result\nto register rd. C.ADD expands into add rd, rd, rs2.",
    "norm:c-add_val": "C.ADD is only\nvalid when rs2≠x0; the code points with rs2=x0 correspond to the C.JALR\nand C.EBREAK instructions.",
    "norm:c-add_hint": "The code points with rs2≠x0 and rd=x0 are HINTs.",
    "norm:c-and_op": "C.AND computes the bitwise AND of the values in registers\nrd′ and rs2′, then writes the result\nto register rd′. C.AND expands into\nand rd′, rd′, rs2′.",
    "norm:c-or_op": "C.OR computes the bitwise OR of the values in registers\nrd′ and rs2′, then writes the result\nto register rd′. C.OR expands into\nor rd′, rd′, rs2′.",
    "norm:c-xor_op": "C.XOR computes the bitwise XOR of the values in registers\nrd′ and rs2′, then writes the result\nto register rd′. C.XOR expands into\nxor rd′, rd′, rs2′.",
    "norm:c-sub_op": "C.SUB subtracts the value in register rs2′ from the\nvalue in register rd′, then writes the result to\nregister rd′. C.SUB expands into\nsub rd′, rd′, rs2′.",
    "norm:c-addw_op": "C.ADDW is an RV64C-only instruction that adds the values in\nregisters rd′ and rs2′, then\nsign-extends the lower 32 bits of the sum before writing the result to\nregister rd′. C.ADDW expands into\naddw rd′, rd′, rs2′.",
    "norm:c-subw_op": "C.SUBW is an RV64C-only instruction that subtracts the value in\nregister rs2′ from the value in register\nrd′, then sign-extends the lower 32 bits of the\ndifference before writing the result to register rd′.\nC.SUBW expands into subw rd′, rd′, rs2′.",
    "norm:Zca_illegal": "A 16-bit instruction with all bits zero is permanently reserved as an\nillegal instruction.",
    "norm:c-nop_op": "C.NOP is a CI-format instruction that does not change any user-visible\nstate, except for advancing the pc and incrementing any applicable\nperformance counters. C.NOP expands to nop.",
    "norm:c-nop_hint": "The C.NOP code points\nwith imm≠0 encode HINTs.",
    "norm:c-ebreak_op": "Debuggers can use the C.EBREAK instruction, which expands to ebreak,\nto cause control to be transferred back to the debugging environment.\nC.EBREAK shares the opcode with the C.ADD instruction, but with rd and\nrs2 both zero, thus can also use the CR format.",
    "norm:Zca_hints": "A portion of the RVC encoding space is reserved for microarchitectural\nHINTs. Like the HINTs in the RV32I base ISA (see\n&lt;&lt;rv32i-hints&gt;&gt;), these instructions do not\nmodify any architectural state, except for advancing the pc and any\napplicable performance counters. HINTs are executed as no-ops on\nimplementations that ignore them.",
    "norm:misa-c_set_line": "MISA.C is set if the following extensions are selected:",
    "norm:misa-c_set_list": "Zca and not F\nZca, Zcf and F (but not D) is specified (RV32 only)\nZca, Zcf and Zcd if D is specified (RV32 only)\n\nthis configuration excludes Zcmp, Zcmt\nZca, Zcd if D is specified (RV64 only)\n\nthis configuration excludes Zcmp, Zcmt",
    "norm:c-lbu_op": "loads a byte from the memory address formed by adding rs1' to the zero extended immediate uimm. The resulting byte is zero extended to XLEN bits and is written to rd'.",
    "norm:c-lhu_op": "loads a halfword from the memory address formed by adding rs1' to the zero extended immediate uimm. The resulting halfword is zero extended to XLEN bits and is written to rd'.",
    "norm:c-lh_op": "loads a halfword from the memory address formed by adding rs1' to the zero extended immediate uimm. The resulting halfword is sign extended to XLEN bits and is written to rd'.",
    "norm:c-sb_op": "stores the least significant byte of rs2' to the memory address formed by adding rs1' to the zero extended immediate uimm.",
    "norm:c-sh_op": "stores the least significant halfword of rs2' to the memory address formed by adding rs1' to the zero extended immediate uimm.",
    "norm:c-zext-b_op": "zero-extends the least-significant byte of the operand to XLEN bits by inserting zeros into all of\nthe bits more significant than 7.",
    "norm:c-sext-b_op": "sign-extends the least-significant byte in the operand to XLEN bits by copying the most-significant bit\nin the byte (i.e., bit 7) to all of the more-significant bits.",
    "norm:c-zext-h_op": "zero-extends the least-significant halfword of the operand to XLEN bits by inserting zeros into all of\nthe bits more significant than 15.",
    "norm:c-sext-h_op": "sign-extends the least-significant halfword in the operand to XLEN bits by copying the most-significant bit\nin the halfword (i.e., bit 15) to all of the more-significant bits.",
    "norm:c-zext-w_op": "zero-extends the least-significant word of the operand to XLEN bits by inserting zeros into all of\nthe bits more significant than 31.",
    "norm:c-not_op": "takes the one's complement of rd'/rs1' and writes the result to the same register.",
    "norm:c-mul_op": "multiplies XLEN bits of the source operands from rsd' and rs2' and writes the lowest XLEN bits of the result to rsd'.",
    "norm:Zcmp_reexecute": "Correct execution requires that sp refers to idempotent memory (also see ), because the core must be able to handle traps detected during the sequence. The entire PUSH/POP sequence is re-executed after returning from the trap handler, and multiple traps are possible during the sequence.",
    "norm:Zcmp_trap": "If a trap occurs during the sequence then xEPC is updated with the PC of the instruction, xTVAL (if not read-only-zero) updated with the bad address if it was an access fault and xCAUSE updated with the type of trap.",
    "norm:interrupts_allowed_in_pushpop": "It is implementation defined whether interrupts can also be taken during the sequence execution.",
    "norm:Zcmp_push_sp_commit": "The stack pointer adjustment must only be committed only when it is certain that the entire PUSH instruction will commit.",
    "norm:Zcmp_bus_fault": "Stores may also return imprecise faults from the bus. It is platform defined whether the core implementation waits for the bus responses before continuing to the final stage of the sequence, or handles errors responses after completing the PUSH instruction.",
    "norm:Zcmp_pop_sp_commit": "The optional li a0, 0, stack pointer adjustment and optional ret must only be committed only when it is certain that the entire POP/POPRET instruction will commit.",
    "norm:cm-push_op": "pushes (stores) the registers in reg_list to the memory below the stack pointer,\nand then creates the stack frame by decrementing the stack pointer by stack_adj,\nincluding any additional stack space requested by the value of spimm.",
    "norm:cm-pop_op": "This instruction pops (loads) the registers in reg_list from stack memory,\nand then adjusts the stack pointer by stack_adj.",
    "norm:cm-popretz_op": "pops (loads) the registers in reg_list from stack memory, adjusts the stack pointer by stack_adj, moves zero into a0 and then returns to ra.",
    "norm:cm-popret_op": "pops (loads) the registers in reg_list from stack memory, adjusts the stack pointer by stack_adj and then returns to ra.",
    "norm:cm-mvsa01_res": "For the encoding to be legal r1s' != r2s'.",
    "norm:cm-mvsa01_op": "moves a0 into r1s' and a1 into r2s'.  r1s' and r2s' must be different.",
    "norm:cm-mvsa01_sreg": "The encoding uses sreg number specifiers instead of xreg number specifiers to save encoding space.",
    "norm:cm-mva01s_op": "moves r1s' into a0 and r2s' into a1.",
    "norm:cm-mva01s_sreg": "The encoding uses sreg number specifiers instead of xreg number specifiers to save encoding space.",
    "norm:Zcmt_table": "Table jump uses a 256-entry XLEN wide table in instruction memory to contain function addresses.\nThe table must be a minimum of 64-byte aligned.",
    "norm:Zcmt_endian": "Table entries follow the current data endianness. This is different from normal instruction fetch which is always little-endian.",
    "norm:Zcmt_entry_sz": "The base of the table is in the jvt CSR (see &lt;&lt;csrs-jvt&gt;&gt;), each table entry is XLEN bits.",
    "norm:Zcmt_fetch": "For a table jump instruction, the table entry that the instruction selects is considered an extension of the instruction itself.\nHence, the execution of a table jump instruction involves two instruction fetches, the first to read the instruction (cm.jt/cm.jalt)\nand the second to read from the jump vector table (JVT). Both instruction fetches are implicit reads, and both require\nexecute permission; read permission is irrelevant. It is recommended that the second fetch be ignored for hardware triggers and breakpoints.",
    "norm:Zcmt_trap": "If an exception occurs on either instruction fetch, xEPC is set to the PC of the table jump instruction,  xCAUSE is set as expected for the type of fault and xTVAL (if not set to zero) contains the fetch address which caused the fault.",
    "norm:jvt_reg": "The jvt register is an XLEN-bit WARL read/write register that holds the jump table configuration, consisting of the jump table base address (BASE) and the jump table mode (MODE).",
    "norm:jvt_op": "If &lt;&lt;Zcmt&gt;&gt; is implemented then jvt must also be implemented, but can contain a read-only value. If jvt is writable, the set of values the register may hold can vary by implementation. The value in the BASE field must always be aligned on a 64-byte boundary.\nNote that the CSR contains only bits XLEN-1 through 6 of the address base. When computing jump-table accesses, the lower six bits of base are filled with zeroes to obtain an XLEN-bit jump-table base address jvt.base that is always aligned on a 64-byte boundary.",
    "norm:jvt_base_vm": "jvt.base is a virtual address, whenever virtual memory is enabled.",
    "norm:jvt_mode_acc": "jvt.mode is a WARL field, so can only be programmed to modes which are implemented.",
    "norm:cm-jt_op": "cm.jt reads an entry from the jump vector table in memory and jumps to the address that was read.",
    "norm:cm-jalt_op": "cm.jalt reads an entry from the jump vector table in memory and jumps to the address that was read, linking to ra.",
    "norm:bitmanip_rv32_rv64": "The bitmanip extensions are defined for RV32 and RV64.",
    "norm:bitmanip_w_suffix_semantics": "The bitmanip extension follows the convention in RV64 that w-suffixed instructions (without a dot before the w) ignore the upper 32 bits of their inputs, operate on the least-significant 32 bits as signed values, and produce a 32-bit signed result that is sign-extended to XLEN.",
    "norm:bitmanip_uw_suffix_semantics": "Bitmanip instructions with the suffix .uw have one operand that is an unsigned 32-bit value that is extracted from the least-significant 32 bits of the specified register.  Other than that, these perform full-XLEN operations.",
    "norm:bitmanip_bhw_suffix_semantics": "Bitmanip instructions with the suffixes .b, .h, and .w only look at the least-significant 8 bits, 16 bits, and 32 bits of the input (respectively) and produce an XLEN-wide result that is sign-extended or zero-extended, based on the specific instruction.",
    "norm:b_extension_composition": "The B standard extension comprises instructions provided by the Zba, Zbb, and\nZbs extensions.",
    "norm:zba_slli_uw_function": "While the shift and add instructions are limited to a maximum left shift of 3, the slli instruction (from the base ISA) can be used to perform similar shifts for indexing into arrays of wider elements. The slli.uw -- added in this extension -- can be used when the index is to be interpreted as an unsigned word.",
    "norm:zbb_sign_zero_extension_function": "These instructions perform the sign extension or zero extension of the least-significant 8 bits or 16 bits of the source register.",
    "norm:zbb_rotate_semantics": "where the shift-logical\ninstructions shift in zeros, the rotate instructions shift in the bits that were shifted out of the other side of the value.",
    "norm:zbb_orc_b_semantics": "orc.b sets the bits of each byte in the result rd to all zeros if no bit within the respective byte of rs is set, or to all ones if any bit within the respective byte of rs is set.",
    "norm:zbc_clmul_clmulh_results": "clmul produces the lower half of the carry-less product and clmulh produces the upper half of the 2{times}XLEN carry-less product.",
    "norm:zbc_clmulr_results": "clmulr produces bits 2{times}XLEN−2:XLEN-1 of the 2{times}XLEN carry-less product.",
    "norm:zbs_single_bit_functionality": "The single-bit instructions provide a mechanism to set, clear, invert, or extract\na single bit in a register. The bit is specified by its index.",
    "norm:zbkx_lookup_table_model": "These instructions implement a \"lookup table\" for 4 and 8 bit elements\ninside the general purpose registers.",
    "norm:zbkx_indexing_behavior": "Elements in rs1 are replaced by the indexed element in rs2, or zero\nif the index into rs2 is out of bounds.",
    "norm:add_uw_enc": "Encoding",
    "norm:add_uw_op": "Operation",
    "norm:andn_enc": "Encoding",
    "norm:andn_op": "Operation",
    "norm:bclr_enc": "Encoding",
    "norm:bclr_op": "Operation",
    "norm:bclri_rv32_enc": "Encoding (RV32)",
    "norm:bclri_rv64_enc": "Encoding (RV64)",
    "norm:bclri_shamt_rsv_rv32": "For RV32, the encodings corresponding to shamt[5]=1 are reserved.",
    "norm:bclri_op": "Operation",
    "norm:bext_enc": "Encoding",
    "norm:bext_op": "Operation",
    "norm:bexti_rv32_enc": "Encoding (RV32)",
    "norm:bexti_rv64_enc": "Encoding (RV64)",
    "norm:bexti_shamt_rsv_rv32": "For RV32, the encodings corresponding to shamt[5]=1 are reserved.",
    "norm:bexti_op": "Operation",
    "norm:binv_enc": "Encoding",
    "norm:binv_op": "Operation",
    "norm:binvi_rv32_enc": "Encoding (RV32)",
    "norm:binvi_rv64_enc": "Encoding (RV64)",
    "norm:binvi_shamt_rsv_rv32": "For RV32, the encodings corresponding to shamt[5]=1 are reserved.",
    "norm:binvi_op": "Operation",
    "norm:bset_enc": "Encoding",
    "norm:bset_op": "Operation",
    "norm:bseti_rv32_enc": "Encoding (RV32)",
    "norm:bseti_rv64_enc": "Encoding (RV64)",
    "norm:bseti_shamt_rsv_rv32": "For RV32, the encodings corresponding to shamt[5]=1 are reserved.",
    "norm:bseti_op": "Operation",
    "norm:clmul_enc": "Encoding",
    "norm:clmul_op": "Operation",
    "norm:clmulh_enc": "Encoding",
    "norm:clmulh_op": "Operation",
    "norm:clmulr_enc": "Encoding",
    "norm:clmulr_op": "Operation",
    "norm:clz_enc": "Encoding",
    "norm:clz_op": "Operation",
    "norm:clzw_enc": "Encoding",
    "norm:clzw_op": "Operation",
    "norm:cpop_enc": "Encoding",
    "norm:cpop_op": "Operation",
    "norm:cpopw_enc": "Encoding",
    "norm:cpopw_op": "Operation",
    "norm:ctz_enc": "Encoding",
    "norm:ctz_op": "Operation",
    "norm:ctzw_enc": "Encoding",
    "norm:ctzw_op": "Operation",
    "norm:max_enc": "Encoding",
    "norm:max_op": "Operation",
    "norm:maxu_enc": "Encoding",
    "norm:maxu_op": "Operation",
    "norm:min_enc": "Encoding",
    "norm:min_op": "Operation",
    "norm:minu_enc": "Encoding",
    "norm:minu_op": "Operation",
    "norm:orc_b_enc": "Encoding",
    "norm:orc_b_op": "Operation",
    "norm:orn_enc": "Encoding",
    "norm:orn_op": "Operation",
    "norm:pack_enc": "Encoding",
    "norm:pack_op": "Operation",
    "norm:packh_enc": "Encoding",
    "norm:packh_op": "Operation",
    "norm:packw_enc": "Encoding",
    "norm:packw_op": "Operation",
    "norm:rev8_rv32_enc": "Encoding (RV32)",
    "norm:rev8_rv64_enc": "Encoding (RV64)",
    "norm:rev8_op": "Operation",
    "norm:brev8_enc": "Encoding",
    "norm:brev8_op": "Operation",
    "norm:rol_enc": "Encoding",
    "norm:rol_op": "Operation",
    "norm:rolw_enc": "Encoding",
    "norm:rolw_op": "Operation",
    "norm:ror_enc": "Encoding",
    "norm:ror_op": "Operation",
    "norm:rori_rv32_enc": "Encoding (RV32)",
    "norm:rori_rv64_enc": "Encoding (RV64)",
    "norm:rori_op": "Operation",
    "norm:roriw_enc": "Encoding",
    "norm:roriw_op": "Operation",
    "norm:rorw_enc": "Encoding",
    "norm:rorw_op": "Operation",
    "norm:sext_b_enc": "Encoding",
    "norm:sext_b_op": "Operation",
    "norm:sext_h_enc": "Encoding",
    "norm:sext_h_op": "Operation",
    "norm:sh1add_enc": "Encoding",
    "norm:sh1add_op": "Operation",
    "norm:sh1add_uw_enc": "Encoding",
    "norm:sh1add_uw_op": "Operation",
    "norm:sh2add_enc": "Encoding",
    "norm:sh2add_op": "Operation",
    "norm:sh2add_uw_enc": "Encoding",
    "norm:sh2add_uw_op": "Operation",
    "norm:sh3add_enc": "Encoding",
    "norm:sh3add_op": "Operation",
    "norm:sh3add_uw_enc": "Encoding",
    "norm:sh3add_uw_op": "Operation",
    "norm:slli_uw_enc": "Encoding",
    "norm:slli_uw_op": "Operation",
    "norm:unzip_enc": "Encoding",
    "norm:unzip_op": "Operation",
    "norm:xnor_enc": "Encoding",
    "norm:xnor_op": "Operation",
    "norm:xperm8_enc": "Encoding",
    "norm:xperm8_op": "Operation",
    "norm:xperm4_enc": "Encoding",
    "norm:xperm4_op": "Operation",
    "norm:zext_h_rv32_enc": "Encoding (RV32)",
    "norm:zext_h_rv64_enc": "Encoding (RV64)",
    "norm:zext_h_op": "Operation",
    "norm:zip_enc": "Encoding",
    "norm:zip_op": "Operation",
    "norm:elen": "The maximum size in bits of a vector element that any operation can produce or consume, ELEN {ge} 8, which\nmust be a power of 2.",
    "norm:vlen": "The number of bits in a single vector register, VLEN {ge} ELEN, which must be a power of 2, and must be no greater than 2^16^.",
    "norm:vreg_count": "The vector extension adds 32 architectural vector registers, v0-v31 to the base scalar RISC-V ISA.",
    "norm:mstatus-vs_sstatus-vs_op": "A vector context status field, VS, is added to mstatus[10:9] and shadowed in sstatus[10:9].  It is defined analogously to the floating-point context status field, FS.",
    "norm:mstatus-vs_op_off": "Attempts to execute any vector instruction, or to access the vector CSRs, raise an illegal-instruction exception when mstatus.VS is set to Off.",
    "norm:mstatus-vs_op_initial_clean": "When mstatus.VS is set to Initial or Clean, executing any instruction that changes vector state, including the vector CSRs, will change mstatus.VS to Dirty. Implementations may also change mstatus.VS from Initial or Clean to Dirty at any time, even when there is no change in vector state.",
    "norm:mstatus-sd_op": "If mstatus.VS is Dirty, mstatus.SD is 1; otherwise, mstatus.SD is set in accordance with existing specifications.",
    "norm:mutable_misa_v": "Implementations may have a writable misa.V field.",
    "norm:mstatus_vs_exists": "Analogous to the\nway in which the floating-point unit is handled, the mstatus.VS\nfield may exist even if misa.V is clear.",
    "norm:vsstatus-vs_sz_acc": "When the hypervisor extension is present, a vector context status field, VS, is added to vsstatus[10:9]. It is defined analogously to the floating-point context status field, FS.",
    "norm:vsstatus-vs_mstatus-vs_op_off": "When V=1, both vsstatus.VS and mstatus.VS are in effect: attempts to execute any vector instruction, or to access the vector CSRs, raise an illegal-instruction exception when either field is set to Off.",
    "norm:vsstatus-vs_mstatus-vs_op_active": "When V=1 and neither vsstatus.VS nor mstatus.VS is set to Off, executing\nany instruction that changes vector state, including the vector CSRs, will\nchange both mstatus.VS and vsstatus.VS to Dirty.",
    "norm:hw_mstatus_vs_dirty_update": "Implementations may also change mstatus.VS or vsstatus.VS from Initial or\nClean to Dirty at any time, even when there is no change in vector state.",
    "norm:vsstatus-sd_op_vs": "If vsstatus.VS is Dirty, vsstatus.SD is 1; otherwise, vsstatus.SD is set in accordance with existing specifications.",
    "norm:mstatus-sd_op_vs": "If mstatus.VS is Dirty, mstatus.SD is 1; otherwise, mstatus.SD is set in accordance with existing specifications.",
    "norm:vsstatus_vs_exists": "For implementations with a writable misa.V field, the vsstatus.VS field may exist even if misa.V is clear.",
    "norm:vtype_sz_acc_op": "The read-only XLEN-wide vector type CSR, vtype provides the\ndefault type used to interpret the contents of the vector register\nfile, and can only be updated by vset{i}vl{i} instructions.",
    "norm:vtype-fields_sz": "The vtype register has five fields, vill, vma, vta, vsew[2:0], and vlmul[2:0].  Bits vtype[XLEN-2:8] should be written with zero, and non-zero values in this field are reserved.",
    "norm:vill_implicit_encoding": "A small implementation supporting ELEN=32 requires only seven bits of state in vtype: two bits for ma and ta, two bits for vsew[1:0] and three bits for vlmul[2:0].  The illegal value represented by vill can be internally encoded using the illegal 64-bit combination in vsew[1:0] without requiring an additional storage\nbit to hold vill.",
    "norm:vtype-vsew_op": "The value in vsew sets the dynamic selected element width (SEW).  By default, a vector register is viewed as being divided into VLEN/SEW elements.",
    "norm:vtype-vsew_rsv": "While it is anticipated the larger vsew[2:0] encodings\n(100-111) will be used to encode larger SEW, the encodings are\nformally reserved at this point.",
    "norm:vtype-lmul_val": "Implementations must support LMUL integer values of\n1, 2, 4, and 8.",
    "norm:vtype-lmul_fval": "Implementations must provide fractional LMUL settings that allow the narrowest supported type to occupy a fraction of a vector register corresponding to the ratio of the narrowest supported type&#8217;s width to that of the largest supported type&#8217;s width.  In general, the requirement is to support LMUL ≥ SEWMIN/ELEN, where SEWMIN is the narrowest supported SEW value and ELEN is the widest supported SEW value.  In the standard extensions, SEWMIN=8.  For standard vector extensions with ELEN=32, fractional LMULs of 1/2 and 1/4 must be supported.  For standard vector extensions with ELEN=64, fractional LMULs of 1/2, 1/4, and 1/8 must be supported.",
    "norm:vtype-sew_val": "For a given supported fractional LMUL setting, implementations must support SEW settings between SEWMIN and LMUL * ELEN, inclusive.",
    "norm:vtype-lmul_fval_rsv": "The use of vtype encodings with LMUL &lt; SEWMIN/ELEN is reserved, but implementations can set vill if they do not support these configurations.",
    "norm:lmul": "LMUL is set by the signed vlmul field in vtype (i.e., LMUL = 2vlmul[2:0]).",
    "norm:vlmax": "The derived value VLMAX = LMUL*VLEN/SEW represents the maximum number of elements that can be operated on with a single vector instruction given the current SEW and LMUL settings as shown in the table below.",
    "norm:vreg_offgroup_lmul2_rsv": "Instructions specifying an LMUL=2 vector register group\nwith an odd-numbered vector register are reserved.",
    "norm:vreg_offgroup_lmul4_rsv": "instructions specifying an LMUL=4 vector register group using vector\nregister numbers that are not multiples of four are reserved.",
    "norm:vreg_offgroup_lmul8_rsv": "instructions specifying an LMUL=8 vector register group\nusing register numbers that are not multiples of eight are reserved.",
    "norm:vreg_mask_lmul_indp": "Mask registers are always contained in a single vector register, regardless of LMUL.",
    "norm:vtype-vta-vma_op": "These two bits modify the behavior of destination tail elements and destination inactive masked-off elements respectively during the execution of vector instructions.  The tail and inactive sets contain element positions that are not receiving new results during a vector operation, as defined in .",
    "norm:vtype-vta-vma_val": "All systems must support all four options:",
    "norm:vreg_mask_tail_agn": "Mask destination tail elements are always treated as tail-agnostic, regardless of the setting of vta.",
    "norm:vreg_mask_op": "When a set is marked undisturbed, the corresponding set of destination elements in a vector register group retain the value they previously held.",
    "norm:vreg_agnostic_op": "When a set is marked agnostic, the corresponding set of destination elements in any vector destination operand can either retain the value they previously held, or are overwritten with 1s.  Within a single vector instruction, each destination element can be either left undisturbed or overwritten with 1s, in any combination, and the pattern of undisturbed or overwritten with 1s is not required to be deterministic when the instruction is executed with the same inputs.",
    "norm:vreg_mask_tail_op": "In addition, except for mask load instructions, any element in the tail of a mask result can also be written with the value the mask-producing operation would have calculated with vl=VLMAX. Furthermore, for mask-logical instructions and vmsbf.m, vmsif.m, vmsof.m mask-manipulation instructions, any element in the tail of the result can be written with the value the mask-producing operation would have calculated with vl=VLEN, SEW=8, and LMUL=8 (i.e., all bits of the mask register can be overwritten).",
    "norm:vtype-vill_op": "If the vill bit is set, then any attempt to execute a vector instruction that depends upon vtype will raise an illegal-instruction exception.",
    "norm:vl_acc": "The XLEN-bit-wide read-only vl CSR can only be updated by the vset{i}vl{i} instructions, and the fault-only-first vector load instruction variants.",
    "norm:vl_op": "The vl register holds an unsigned integer specifying the number of elements to be updated with results from a vector instruction, as further detailed in .",
    "norm:vlenb_acc_op": "The XLEN-bit-wide read-only CSR vlenb holds the value VLEN/8, i.e., the vector register length in bytes.",
    "norm:vstart_acc_sz": "The XLEN-bit-wide read-write vstart CSR specifies the index of the first element to be executed by a vector instruction, as described in .",
    "norm:vstart_op": "All vector instructions are defined to begin execution with the\nelement number given in the vstart CSR, leaving earlier elements in\nthe destination vector undisturbed",
    "norm:vstart_update": "reset the vstart CSR to\nzero at the end of execution.",
    "norm:vstart_unmodified": "vstart is not modified by vector instructions that raise illegal-instruction exceptions.",
    "norm:vstart_sz_writable": "The vstart CSR is defined to have only enough writable bits to hold the largest element index (one less than the maximum VLMAX).",
    "norm:vstart_val_rsv": "The use of vstart values greater than the largest element index for the current vtype setting is reserved.",
    "norm:vstart_vtype_dep": "Implementations are permitted to raise illegal-instruction exceptions when attempting to execute a vector instruction with a value of vstart that the implementation can never produce when executing that same instruction with the same vtype setting.",
    "norm:vxrm_val_sz_acc": "The vector fixed-point rounding-mode register holds a two-bit read-write rounding-mode field in the least-significant bits (vxrm[1:0]).  The upper bits, vxrm[XLEN-1:2], should be written as zeros.",
    "norm:vcsr-vxrm_op": "The vector fixed-point rounding-mode is given a separate CSR address to allow independent access, but is also reflected as a field in vcsr.",
    "norm:vxrm_op": "The fixed-point rounding algorithm is specified as follows. Suppose the pre-rounding result is v, and d bits of that result are to be rounded off. Then the rounded result is (v &gt;&gt; d) + r, where r depends on the rounding mode as specified in the following table.",
    "norm:vxsat_op_acc_sz": "The vxsat CSR has a single read-write least-significant bit (vxsat[0]) that indicates if a fixed-point instruction has had to saturate an output value to fit into a destination format. Bits vxsat[XLEN-1:1] should be written as zeros.",
    "norm:vcsr-vxsat_op": "The vxsat bit is mirrored in vcsr.",
    "norm:vcsr-vxrm-vxsat_acc": "The vxrm and vxsat separate CSRs can also be accessed via fields in the XLEN-bit-wide vector control and status CSR, vcsr.",
    "norm:vreg_lmul1_op": "When LMUL=1, elements are simply packed in order from the least-significant to most-significant bits of the vector register.",
    "norm:vreg_flmul_op": "When LMUL &lt; 1, only the first LMUL*VLEN/SEW elements in the vector register are used.  The remaining space in the vector register is treated as part of the tail, and hence must obey the vta setting.",
    "norm:vreg_lmulge2_op": "When vector registers are grouped, the elements of the vector register group are packed contiguously in element order beginning with the lowest-numbered vector register and moving to the next-highest-numbered vector register in the group once each vector register is filled.",
    "norm:vreg_mask_vtype_indp": "A vector mask occupies only one vector register regardless of SEW and LMUL.",
    "norm:vreg_mask_sz": "Each element is allocated a single mask bit in a mask vector register. The mask bit for element i is located in bit i of the mask register, independent of SEW or LMUL.",
    "norm:vreg_scalar_lmul_indp": "Any vector register can be used to hold a scalar regardless\nof the current LMUL setting.",
    "norm:eew_emul": "Each vector operand has an effective element width (EEW) and an effective LMUL (EMUL) that is used to determine the size and location of all the elements within a vector register group.  By default, for most operands of most instructions, EEW=SEW and EMUL=LMUL.",
    "norm:eew_emul_sew_lmul_dep": "EEW/EMUL = SEW/LMUL.",
    "norm:vnarrowing_eew_emul": "Narrowing instructions have a source operand that has\nEEW=2*SEW and EMUL=2*LMUL but with a destination where EEW=SEW and EMUL=LMUL.",
    "norm:emul_offgroup_rsv": "Using other than the lowest-numbered\nvector register to specify a vector register group is a reserved\nencoding.",
    "norm:vreg_source_eew_rsv": "A vector register cannot be used to provide source operands with more than one EEW for a single instruction.  A mask register source is considered to have EEW=1 for this constraint.  An encoding that would result in the same vector register being read with two or more different EEWs, including when the vector register appears at different positions within two or more vector register groups, is reserved.",
    "norm:vreg_overlap_legal": "A destination vector register group can overlap a source vector register group only if one of the following holds:",
    "norm:vreg_mask_overlap": "For the purpose of determining register group overlap constraints, mask elements have EEW=1.",
    "norm:vreg_overlap_rsv": "Any instruction encoding that violates the overlap constraints is reserved.",
    "norm:vreg_overlap_agn": "When source and destination registers overlap and have different EEW, the instruction is mask- and tail-agnostic, regardless of the setting of the vta and vma bits in vtype.",
    "norm:emul_rsv": "The largest vector register group used by an instruction can not be greater than 8 vector registers (i.e., EMUL≤8), and if a vector instruction would require greater than 8 vector registers in a group, the instruction encoding is reserved.  For example, a widening operation that produces a widened vector register group result when LMUL=8 is reserved as this would imply a result EMUL=16.",
    "norm:vreg_scalar_emul": "Widened scalar values, e.g., input and output to a widening reduction operation, are held in the first element of a vector register and have EMUL=1.",
    "norm:vmask_inactive_op": "Element operations\nthat are masked off (inactive) never generate exceptions.",
    "norm:vmask_agn_op": "The\ndestination vector register elements corresponding to masked-off\nelements are handled with either a mask-undisturbed or mask-agnostic\npolicy depending on the setting of the vma bit in vtype",
    "norm:vreg_vmask": "The mask value used to control execution of a masked vector instruction is always supplied by vector register v0.",
    "norm:vreg_vmask_rsv": "The destination vector register group for a masked vector instruction cannot overlap the source mask register (v0), unless the destination vector register is being written with a mask value (e.g., compares) or the scalar result of a reduction.  These instruction encodings are reserved.",
    "norm:vmask_vm_enc": "Where available, masking is encoded in a single-bit vm field in the  instruction (inst[25]).",
    "norm:vector_prestart_element": "The prestart elements do not raise exceptions and do not update the destination vector register.",
    "norm:vector_active_element": "The active elements can raise exceptions and update the destination vector register group.",
    "norm:vector_inactive_element": "The inactive elements do not raise exceptions and do not update any destination vector register group unless masked agnostic is specified (vtype.vma=1), in which case inactive elements may be overwritten with 1s.",
    "norm:vector_tail_element": "The tail elements do not raise exceptions, and do not update any destination vector register group unless tail agnostic is specified (vtype.vta=1), in which case tail elements may be overwritten with 1s, or with the result of the instruction in the case of mask-producing instructions except for mask loads.  When LMUL &lt; 1, the tail includes the elements past VLMAX that are held in the same vector register.",
    "norm:vstart_vl_dep": "When vstart ≥ vl, there are no body elements, and no elements are updated in any destination vector register group, including that no tail elements are updated with agnostic values.",
    "norm:vstart_vl_scalar_indp": "Instructions that write an x register or f register do so even when vstart ≥ vl, including when vl=0.",
    "norm:vset_op": "The\nvset{i}vl{i} instructions set the vtype and vl CSRs based on\ntheir arguments, and write the new value of vl into rd.",
    "norm:vtype_acc": "The new vtype value is encoded in the immediate fields of vsetvli and vsetivli, and in the rs2 register for vsetvl.",
    "norm:vtype-vill_val": "If the vtype value is not supported by the implementation, then\nthe vill bit is set in vtype, the remaining bits in vtype are\nset to zero",
    "norm:vtype-vstart_op": "the vl register is also set to zero.",
    "norm:vtype-vill_val_vill": "A vtype value with vill set is treated as an unsupported configuration.",
    "norm:vtype-vill_all_bits": "Implementations must consider all bits of the vtype value to determine if the configuration is supported.  An unsupported value in any location within the vtype value must result in vill being set.",
    "norm:vsetvl_op": "When rs1 is not x0, the AVL is an unsigned integer held in the x register specified by rs1, and the new vl value is also written to the x register specified by rd.",
    "norm:vsetvl_op_rs1_x0_rd_nx0": "When rs1=x0 but rd≠x0, the maximum unsigned integer value (~0) is used as the AVL, and the resulting VLMAX is written to vl and also to the x register specified by rd.",
    "norm:vsetvl_op_rs1_x0_rd_x0": "When rs1=x0 and rd=x0, the instructions operate as if the current vector length in vl is used as the AVL, and the resulting value is written to vl, but not to a destination register.  This form can only be used when VLMAX and hence vl is not actually changed by the new SEW/LMUL ratio.",
    "norm:vtype_vset_rsv": "Use of the instructions with a new SEW/LMUL ratio that would result in a change of VLMAX is reserved. Use of the instructions is also reserved if vill was 1 beforehand.",
    "norm:reserved_vill_set": "Implementations may set vill in either case.",
    "norm:vsetivli_op": "For the vsetivli instruction, the AVL is encoded as a 5-bit zero-extended immediate (0&#8212;&#8203;31) in the rs1 field.",
    "norm:vl_val_lead-in": "The vset{i}vl{i} instructions first set VLMAX according to their vtype argument, then set vl obeying the following constraints:",
    "norm:vl_val_list": "vl = AVL if AVL ≤ VLMAX\nceil(AVL / 2) ≤ vl ≤ VLMAX if AVL &lt; (2 * VLMAX)\nvl = VLMAX if AVL ≥ (2 * VLMAX)\nDeterministic on any given implementation for same input AVL and VLMAX values\nThese specific properties follow from the prior rules:\n\nvl = 0 if  AVL = 0\nvl &gt; 0 if AVL &gt; 0\nvl ≤ VLMAX\nvl ≤ AVL\na value read from vl when used as the AVL argument to vset{i}vl{i} results in the same value in vl, provided the resultant VLMAX equals the value of VLMAX at the time that vl was read",
    "norm:vector_load_store_semantics": "Vector loads and stores move values between vector registers and\nmemory.",
    "norm:vector_masked_memory_access": "Vector loads and stores can be masked, and they only access memory or raise\nexceptions for active elements.",
    "norm:vector_masked_inactive_behavior": "Masked vector loads do not update inactive elements in the destination vector\nregister group, unless masked agnostic is specified (vtype.vma=1).",
    "norm:vector_ls_vstart": "All vector loads and stores may generate and accept a non-zero vstart value.",
    "norm:vector_ls_strided_eew": "Vector memory unit-stride and constant-stride operations directly encode EEW of the data to be transferred statically in the instruction to reduce the number of vtype changes when accessing memory in a mixed-width routine.",
    "norm:vector_ls_indexed_eew": "Indexed operations use the explicit EEW encoding in the instruction to set the size of the indices used, and use SEW/LMUL to specify the data width.",
    "norm:vector_ls_base_stride_regtype": "Vector load/store base\nregisters and strides are taken from the GPR x registers.",
    "norm:vector_ls_base": "The base effective address for all vector accesses is given by the contents of the x register named in rs1.",
    "norm:vector_ls_unit-stride_op": "Vector unit-stride operations access elements stored contiguously in memory starting from the base effective address.",
    "norm:vector_ls_constant-stride_op": "Vector constant-stride operations access the first memory element at the base effective address, and then access subsequent elements at address increments given by the byte offset contained in the x register specified by rs2.",
    "norm:vector_ls_indexed_op": "Vector indexed operations add the contents of each element of the vector offset operand specified by vs2 to the base effective address to give the effective address of each element.  The data vector register group has EEW=SEW, EMUL=LMUL, while the offset vector register group has EEW encoded in the instruction and EMUL=(EEW/SEW)*LMUL.",
    "norm:vector_ls_bytewise": "The vector offset operand is treated as a vector of byte-address offsets.",
    "norm:vector_ls_xlen_dep": "If the vector offset elements are narrower than XLEN, they are zero-extended to XLEN before adding to the base effective address.  If the vector offset elements are wider than XLEN, the least-significant XLEN bits are used in the address calculation.",
    "norm:vector_ls_eew_rsv": "If the implementation does not support the EEW of the offset elements, the instruction is reserved.",
    "norm:vector_ls_stride_ordered_op": "Vector unit-stride and constant-stride memory accesses do not guarantee ordering between individual element accesses.  The vector indexed load and store memory operations have two forms, ordered and unordered.  The indexed-ordered variants preserve element ordering on memory accesses.",
    "norm:vector_ls_stride_unordered_op": "For unordered instructions (mop[1:0]!=11) there is no guarantee on element access order.  If the accesses are to a strongly ordered IO region, the element accesses can be initiated in any order.",
    "norm:vector_ls_stride_unordered_precise": "For implementations with precise vector traps, exceptions on indexed-unordered stores must also be precise.",
    "norm:vector_ls_nf_op": "The nf[2:0] field encodes the number of fields in each segment.  For regular vector loads and stores, nf=0, indicating that a single value is moved between a vector register group and memory at each element position.  Larger values in the nf field are used to access multiple contiguous fields within a segment as described below in .",
    "norm:vector_wholels_nf_op": "The nf[2:0] field also encodes the number of whole vector registers to transfer for the whole vector register load/store instructions.",
    "norm:vector_ls_eew_emul": "Vector loads and stores have an EEW encoded directly in the\ninstruction.  The corresponding EMUL is calculated as EMUL =\n(EEW/SEW)*LMUL.",
    "norm:vector_ls_emul_rsv": "If the EMUL would be out of range (EMUL&gt;8 or\nEMUL&lt;1/8), the instruction encoding is reserved.",
    "norm:vector_ls_emul_offgroup_rsv": "The vector register\ngroups must have legal register specifiers for the selected EMUL,\notherwise the instruction encoding is reserved.",
    "norm:vector_ls_indexed_eew_emul": "Vector unit-stride and constant-stride use the EEW/EMUL encoded in the instruction for the data values, while vector indexed loads and stores use the EEW/EMUL encoded in the instruction for the index values and the SEW/LMUL encoded in vtype for the data values.",
    "norm:vector_ls_ins_req": "Implementations must provide vector loads and stores with EEWs corresponding to all supported SEW settings.",
    "norm:vector_ls_ins_rsv": "Vector load/store encodings for unsupported EEW widths are reserved.",
    "norm:vector_ls_mew_rsv": "The mew bit (inst[28]) when set is expected to be used to encode expanded memory sizes of 128 bits and above, but these encodings are currently reserved.",
    "norm:vector_ls_unit-stride_mask": "Additional unit-stride mask load and store instructions are provided to transfer mask values to/from memory.  These operate similarly to unmasked byte loads or stores (EEW=8), except that the effective vector length is evl=ceil(vl/8) (i.e. EMUL=1), and the destination register is always written with a tail-agnostic policy.",
    "norm:vector_ls_neg_zero_stride": "Negative and zero strides are supported.",
    "norm:vector_ls_constant-stride_unordered": "Element accesses within a constant-stride instruction are unordered with respect to each other.",
    "norm:vector_ls_constant_stride_x0": "When rs2=x0, then an implementation is allowed, but not required, to perform fewer memory operations than the number of active elements, and may perform different numbers of memory operations across different dynamic executions of the same static instruction.",
    "norm:vector_ff_trigger": "The unit-stride fault-only-first load instructions are used to\nvectorize loops with data-dependent exit conditions (\"while\" loops).\nThese instructions execute as a regular load except that they will\nonly take a trap caused by a synchronous exception on element 0.",
    "norm:vector_ff_op": "If element 0 raises an exception, vl is not modified, and the trap is taken.  If an element &gt; 0 raises an exception, the corresponding trap is not taken, and the vector length vl is reduced to the index of the element that would have raised an exception.",
    "norm:vector_ls_overwrite_past_trap": "Load instructions may overwrite active destination vector register\ngroup elements past the element index at which the trap is reported.",
    "norm:vector_ff_past_trap": "Similarly, fault-only-first load instructions may update active destination elements past the element that causes trimming of the vector length (but not past the original vector length).  The values of these spurious updates do not have to correspond to the values in memory at the addressed memory locations.  Non-idempotent memory locations can only be accessed when it is known the corresponding element load operation will not be restarted due to a trap or vector-length trimming.",
    "norm:vector_ff_no_exception": "Even when an exception is not raised, implementations are permitted to process fewer than vl elements and reduce vl accordingly, but if vstart=0 and vl&gt;0, then at least one element must be processed.",
    "norm:vector_ff_interrupt_behavior": "When the fault-only-first instruction takes a trap due to an interrupt, implementations should not reduce vl and should instead set a vstart value.",
    "norm:nfields": "The three-bit nf field in the vector instruction encoding is an unsigned integer that contains one less than the number of fields per segment, NFIELDS.",
    "norm:emul_nfields_rsv": "The EMUL setting must be such that EMUL * NFIELDS ≤ 8, otherwise the instruction encoding is reserved.",
    "norm:nfields_op": "Each field will be held in successively numbered vector register groups.  When EMUL&gt;1, each field will occupy a vector register group held in multiple successively numbered vector registers, and the vector register group for each field must follow the usual vector register alignment constraints (e.g., when EMUL=2 and NFIELDS=4, each field&#8217;s vector register group must start at an even vector register, but does not have to start at a multiple of 8 vector register number).",
    "norm:vector_ls_seg_rsv": "If the vector register numbers accessed by the segment load or store would increment past 31, then the instruction encoding is reserved.",
    "norm:vector_ls_seg_op": "The vl register gives the number of segments to move, which is equal to the number of elements transferred to each vector register group.  Masking is also applied at the level of whole segments.",
    "norm:vector_ls_seg_unordered": "For segment loads and stores, the individual memory accesses used to access fields within each segment are unordered with respect to each other even for ordered indexed segment loads and stores.",
    "norm:vector_ls_seg_vstart_dep": "The vstart value is in units of whole segments.",
    "norm:vector_ls_seg_partial_access": "If a trap occurs during\naccess to a segment, it is implementation-defined whether a subset\nof the faulting segment's accesses are performed before the trap is taken.",
    "norm:vector_ls_seg_unit-stride_op": "The vector unit-stride load and store segment instructions move packed contiguous segments into multiple destination vector register groups.",
    "norm:vector_ls_seg_unit-stride_vd_vs3": "For loads, the vd register will hold the first field loaded from the segment.  For stores, the vs3 register is read to provide the first field to be stored to each segment.",
    "norm:vector_ls__seg_ff_unit-stride_op": "For fault-only-first segment loads, if an exception is detected partway through accessing the zeroth segment, the trap is taken. If an exception is detected partway through accessing a subsequent segment, vl is reduced to the index of that segment.",
    "norm:vector_ff_seg_partial_access": "In both cases, it is implementation-defined whether a subset of the segment is loaded.",
    "norm:vector_ls_seg_ff_overload": "These instructions may overwrite destination vector register group elements past the point at which a trap is reported or past the point at which vector length is trimmed.",
    "norm:vector_ls_seg_constant-stride_op": "Vector constant-stride segment loads and stores move contiguous segments where each segment is separated by the byte-stride offset given in the rs2 GPR argument.",
    "norm:vector_ls_seg_constant-stride_unordered": "Accesses to the fields within each segment can occur in any order, including the case where the byte stride is such that segments overlap in memory.",
    "norm:vector_ls_seg_indexed_op": "Vector indexed segment loads and stores move contiguous segments where each segment is located at an address given by adding the scalar base address in the rs1 field to byte offsets in vector register vs2.",
    "norm:vector_ls_seg_indexed_unordered": "However, even for the ordered form, accesses to the fields within an individual segment are not ordered with respect to each other.",
    "norm:vector_ls_seg_indexed_eew_emul_op": "The data vector register group has EEW=SEW, EMUL=LMUL, while the index vector register group has EEW encoded in the instruction with EMUL=(EEW/SEW)*LMUL.",
    "norm:vector_ls_seg_indexed_emul_nfields_val": "The EMUL * NFIELDS ≤ 8 constraint applies to the data vector register group.",
    "norm:vector_ls_seg_indexed_vreg_rsv": "For vector indexed segment loads, the destination vector register groups cannot overlap the source vector register group (specified by vs2), else the instruction encoding is reserved.",
    "norm:vector_ls_seg_wholereg_eew": "The load instructions have an EEW encoded in the mew and width fields following the pattern of regular unit-stride loads.",
    "norm:vector_ls_seg_wholereg_op": "NFIELDS\nindicates the number of vector registers to transfer, numbered\nsuccessively after the base.",
    "norm:vector_ls_seg_wholereg_nf_rsv": "Only NFIELDS values of 1, 2, 4, 8 are\nsupported, with other values reserved.",
    "norm:vector_ls_seg_wholereg_op_cont": "When multiple registers are\ntransferred, the lowest-numbered vector register is held in the\nlowest-numbered memory addresses and successive vector register\nnumbers are placed contiguously in memory.",
    "norm:vector_ls_seg_wholereg_evl": "The instructions operate with an effective vector length, evl=NFIELDS*VLEN/EEW, regardless of current settings in vtype and vl.  The usual property that no elements are written if vstart ≥ vl does not apply to these instructions. Similarly, the property that the instructions are reserved if vstart exceeds the largest element index for the current vtype setting does not apply. Instead, the instructions are reserved if vstart ≥ evl.",
    "norm:vector_ls_wholereg_missaligned_exception": "Implementations are allowed to raise a misaligned address exception on whole register loads and stores if the base address is not naturally aligned to the larger of the size of the encoded EEW in bytes (EEW/8) or the implementation&#8217;s smallest supported SEW size in bytes (SEWMIN/8).",
    "norm:vector_ls_missaligned_exception": "If an element accessed by a vector memory instruction is not naturally aligned to the size of the element, either the element is transferred successfully or an address-misaligned exception is raised on that element.",
    "norm:vector_ls_scalar_missaligned_independence": "Support for misaligned vector memory accesses is independent of an implementation&#8217;s support for misaligned scalar memory accesses.",
    "norm:vector_ls_scalar_missaligned_dependence": "Vector misaligned memory accesses follow the same rules for atomicity as scalar misaligned memory accesses.",
    "norm:vector_ls_program_order": "Vector memory instructions appear to execute in program order on the local hart.",
    "norm:vector_ls_rvwmo": "Vector memory instructions follow RVWMO at the instruction level.",
    "norm:vector_ls_rvtso": "If the Ztso extension is implemented, vector memory instructions additionally follow RVTSO at the instruction level.",
    "norm:vector_ls_indexed-ordered_ordered": "Except for vector indexed-ordered loads and stores, element operations are unordered within the instruction.",
    "norm:vector_ls_indexed-ordered_rvwmo": "Vector indexed-ordered loads and stores read and write elements from/to memory in element order respectively, obeying RVWMO at the element level.",
    "norm:vl_control_dependency": "Instructions affected by the vector length register vl have a control dependency on vl, rather than a data dependency.",
    "norm:vmask_control_dependency": "Similarly, masked vector instructions have a control dependency on the source mask register, rather than a data dependency.",
    "norm:V_fp_frm": "All vector floating-point operations use the dynamic rounding mode in the frm register.",
    "norm:V_inv_frm_rsv": "Use of the frm field\nwhen it contains an invalid rounding mode by any vector floating-point\ninstruction--even those that do not depend on the rounding mode, or\nwhen vl=0, or when vstart {ge} vl--is reserved.",
    "norm:vop-vv_vreg_vs2_vs1": "Vector-vector operations take two vectors of operands from vector register groups specified by vs2 and vs1 respectively.",
    "norm:vop-vx_vop-vi_vreg_vs2": "the vector register group operand is specified by vs2.",
    "norm:vop-vi_imm_5bit": "For integer operations, the scalar can be a 5-bit immediate, imm[4:0], encoded\nin the rs1 field.  The value is sign-extended to SEW bits, unless otherwise specified.",
    "norm:vop-vx_xreg_rs1": "For integer operations, the scalar can be taken from the scalar x\nregister specified by rs1.",
    "norm:vop-vx_rs1_trunc_lsb_sewbits": "If XLEN&gt;SEW, the least-significant SEW bits of the x register are used, unless otherwise specified.",
    "norm:vop-vx_rs1_sext_sewbits": "If XLEN&lt;SEW, the value from the x register is sign-extended to SEW\nbits.",
    "norm:vfop_freg": "For floating-point operations, the scalar can be taken from a scalar\nf register.",
    "norm:vfop_freg_NaNbox_lsb_sewbits": "If FLEN &gt; SEW, the value in the f registers is\nchecked for a valid NaN-boxed value, in which case the\nleast-significant SEW bits of the f register are used, else the\ncanonical NaN value is used.",
    "norm:V_fp_eew_rsv": "Vector instructions where any\nfloating-point vector operand's EEW is not a supported floating-point\ntype width (which includes when FLEN &lt; SEW) are reserved.",
    "norm:V_Zinx_fp_scalar": "When adding a vector extension to the Zfinx/Zdinx/Zhinx\nextensions, floating-point scalar arguments are taken from the x registers.\nNaN-boxing is not supported in these extensions, and so operands narrower\nthan XLEN bits are not checked for a NaN box; bits XLEN-1:EEW are ignored.\nFor RV32_Zdinx, EEW=64 scalar arguments are supplied by an x-register pair.",
    "norm:V_masked": "Vector arithmetic instructions are masked under control of the vm\nfield.",
    "norm:vwop_vd_eew_emul": "A few vector arithmetic instructions are defined to be widening\noperations where the destination vector register group has EEW=2*SEW\nand EMUL=2*LMUL.",
    "norm:vnop_vd_vs2_eew_emul": "A few instructions are provided to convert double-width source vectors\ninto single-width destination vectors.  These instructions convert a\nvector register group specified by vs2 with EEW/EMUL=2*SEW/2*LMUL to a vector register\ngroup with the current SEW/LMUL setting.",
    "norm:vnop_vs1_eew_emul": "Where there is a second\nsource vector register group (specified by vs1), this has the same\n(narrower) width as the result (i.e., EEW=SEW).",
    "norm:vadd_vsub_op": "Vector integer add and subtract are provided.",
    "norm:vrsub_op": "Reverse-subtract\ninstructions are also provided for the vector-scalar forms.",
    "norm:vwaddu_vwadd_vwsubu_vwsub_op": "The widening add/subtract instructions are provided in both signed and\nunsigned variants, depending on whether the narrower source operands\nare first sign- or zero-extended before forming the double-width sum.",
    "norm:vsext_vzext_op": "The vector integer extension instructions zero- or sign-extend a\nsource vector integer operand with EEW less than SEW to fill SEW-sized\nelements in the destination.",
    "norm:vsext_vzext_vs_eew_emul": "The EEW of the source is 1/2, 1/4, or\n1/8 of SEW, while EMUL of the source is (EEW/SEW)*LMUL.",
    "norm:vsext_vzext_vd_eew_emul": "The\ndestination has EEW equal to SEW and EMUL equal to LMUL.",
    "norm:vsext_vzext_ill_eew_emul_rsv": "If the source EEW is not a supported width, or source EMUL would be\nbelow the minimum legal LMUL, the instruction encoding is reserved.",
    "norm:vmadc_vmsbc_vadc_vsbc_carry_v0": "The carry inputs and outputs are represented using the mask register\nlayout as described in &lt;&lt;sec-mask-register-layout&gt;&gt;.  Due to\nencoding constraints, the carry input must come from the implicit v0\nregister,",
    "norm:vadc_vsbc_op": "vadc and vsbc add or subtract the source operands and the carry-in or\nborrow-in, and write the result to vector register vd.",
    "norm:vadc_vsbc_masked_write_all_elem": "These instructions are encoded as masked instructions (vm=0), but they operate\non and write back all body elements.",
    "norm:vadc_vsbc_unmasked_rsv": "Encodings corresponding to the unmasked versions (vm=1) are reserved.",
    "norm:vmadc_vmsbc_op_masked": "vmadc and vmsbc add or subtract the source operands, optionally\nadd the carry-in or subtract the borrow-in if masked (vm=0), and\nwrite the resulting carry-out or borrow-out back to mask register vd.",
    "norm:vmadc_vmsbc_op_unmasked": "If unmasked (vm=1), there is no carry-in or borrow-in.",
    "norm:vmadc_vmsbc_masked_write_all_elem": "These instructions\noperate on and write back all body elements, even if masked.",
    "norm:vmadc_vmsbc_tail_agnostic": "Because these\ninstructions produce a mask value, they always operate with a\ntail-agnostic policy.",
    "norm:vmsbc_borrow_neg": "For vmsbc, the borrow is defined to be 1 iff the difference, prior to\ntruncation, is negative.",
    "norm:vadc_vsbc_vd_v0_rsv": "For vadc and vsbc, the instruction encoding is reserved if the\ndestination vector register is v0.",
    "norm:vand_vor_vxor_op": "# Bitwise logical operations.\nvand.vv vd, vs2, vs1, vm   # Vector-vector\nvand.vx vd, vs2, rs1, vm   # vector-scalar\nvand.vi vd, vs2, imm, vm   # vector-immediate\n\nvor.vv vd, vs2, vs1, vm    # Vector-vector\nvor.vx vd, vs2, rs1, vm    # vector-scalar\nvor.vi vd, vs2, imm, vm    # vector-immediate\n\nvxor.vv vd, vs2, vs1, vm    # Vector-vector\nvxor.vx vd, vs2, rs1, vm    # vector-scalar\nvxor.vi vd, vs2, imm, vm    # vector-immediate",
    "norm:vsll_vsrl_vsra_op": "A full set of vector shift instructions are provided, including\nlogical shift left (sll), and logical (zero-extending srl) and\narithmetic (sign-extending sra) shift right.  The data to be shifted\nis in the vector register group specified by vs2 and the shift\namount value can come from a vector register group vs1, a scalar\ninteger register rs1, or a zero-extended 5-bit immediate.",
    "norm:vsll_vsrl_vsra_shamt": "Only the low\nlg2(SEW) bits of the shift-amount value are used to control the shift\namount.",
    "norm:vnsrl_vnsra_op": "The narrowing right shifts extract a smaller field from a wider\noperand and have both zero-extending (srl) and sign-extending\n(sra) forms.  The shift amount can come from a vector register\ngroup, or a scalar x register, or a zero-extended 5-bit immediate.",
    "norm:vnsrl_vnsra_shamt": "The low lg2(2*SEW) bits of the shift-amount value are\nused (e.g., the low 6 bits for a SEW=64-bit to SEW=32-bit narrowing\noperation).",
    "norm:vmseq_vmsne_vmsltu_vmslt_vmsleu_vmsle_vmsgtu_vmsgt_op": "The following integer compare instructions write 1 to the destination\nmask register element if the comparison evaluates to true, and 0\notherwise.  The destination mask vector is always held in a single\nvector register, with a layout of elements as described in\n&lt;&lt;sec-mask-register-layout&gt;&gt;.",
    "norm:vmseq_vmsne_vmsltu_vmslt_vmsleu_vmsle_vmsgtu_vmsgt_vd_v0_legal": "The destination mask vector register\nmay be the same as the source vector mask register (v0).",
    "norm:vmseq_vmsne_vmsltu_vmslt_vmsleu_vmsle_vmsgtu_vmsgt_maskundisturbed": "Compares effectively AND in the mask under a mask-undisturbed policy if the destination register is v0,",
    "norm:vmseq_vmsne_vmsltu_vmslt_vmsleu_vmsle_vmsgtu_vmsgt_tail_agnostic": "Compares write mask registers, and so always operate under a\ntail-agnostic policy.",
    "norm:vminu_vmin_vmaxu_vmax_op": "Signed and unsigned integer minimum and maximum instructions are\nsupported.",
    "norm:vmul_vmulh_vmulhu_vmulhsu_op": "The single-width multiply instructions perform a SEW-bit*SEW-bit\nmultiply to generate a 2*SEW-bit product, then return one half of the\nproduct in the SEW-bit-wide destination.  The mul versions write\nthe low word of the product to the destination register, while the\nmulh versions write the high word of the product to the\ndestination register.",
    "norm:vdivu_vdiv_vremu_vrem_op": "The divide and remainder instructions are equivalent to the RISC-V\nstandard scalar integer multiply/divides, with the same results for\nextreme inputs.",
    "norm:vwmul_wmulu_vwmulsu_op": "The widening integer multiply instructions return the full 2*SEW-bit\nproduct from an SEW-bit*SEW-bit multiply.",
    "norm:vmacc_vnmsac_vmadd_vnmsub_op": "The integer multiply-add instructions are destructive and are provided\nin two forms, one that overwrites the addend or minuend\n(vmacc, vnmsac) and one that overwrites the first multiplicand\n(vmadd, vnmsub).",
    "norm:vmacc_vnmsac_vmadd_vnmsub_op_lowhalf": "The low half of the product is added or subtracted from the third operand.",
    "norm:vwmaccu_vwmacc_vwmaccsu_vwmaccus_op": "The widening integer multiply-add instructions add the full 2*SEW-bit\nproduct from a SEW-bit*SEW-bit multiply to a 2*SEW-bit value and\nproduce a 2*SEW-bit result.",
    "norm:vmerge_op": "The vector integer merge instructions combine two source operands\nbased on a mask.",
    "norm:vmerge_all_elem": "Unlike regular arithmetic instructions, the\nmerge operates on all body elements (i.e., the set of elements from\nvstart up to the current vector length in vl).",
    "norm:vmerge_op_mask": "The vmerge instructions are encoded as masked instructions (vm=0).\nThe instructions combine two\nsources as follows.  At elements where the mask value is zero, the\nfirst operand is copied to the destination element, otherwise the\nsecond operand is copied to the destination element.  The first\noperand is always a vector register group specified by vs2.  The\nsecond operand is a vector register group specified by vs1 or a\nscalar x register specified by rs1 or a 5-bit sign-extended\nimmediate.",
    "norm:vmv_op": "The vector integer move instructions copy a source operand to a vector\nregister group.\nThe vmv.v.v variant copies a vector register group, whereas the vmv.v.x\nand vmv.v.i variants splat a scalar register or immediate to all active\nelements of the destination vector register group.",
    "norm:vmv_vs2_nv0_rsv": "The first operand specifier (vs2) must contain v0, and any other vector\nregister number in vs2 is reserved.",
    "norm:vsaddu_vsadd_vssubu_vssub_op": "Saturating forms of integer add and subtract are provided, for both\nsigned and unsigned integers.",
    "norm:vsaddu_vsadd_vssubu_vssub_op_overflow_vxsat_op_vsaddsub": "If the result would overflow the\ndestination, the result is replaced with the closest representable\nvalue, and the vxsat bit is set.",
    "norm:vaaddu_vaadd_vasubu_vasub_op": "The averaging add and subtract instructions right shift the result by\none bit and round off the result according to the setting in vxrm.\nComputation is performed in infinite precision before rounding and truncating.",
    "norm:vasub_vasubu_op_overflow": "For vasub and vasubu, overflow is ignored and the result wraps around.",
    "norm:vsmul_op": "The signed fractional multiply instruction produces a 2*SEW product of\nthe two SEW inputs, then shifts the result right by SEW-1 bits,\nrounding these bits according to vxrm, then saturates the result to\nfit into SEW bits.",
    "norm:vxsat_op_vsmul": "If the result causes saturation, the vxsat bit\nis set.",
    "norm:vssrl_vssra_op": "These instructions shift the input value right, and round off the\nshifted out bits according to vxrm.  The scaling right shifts have\nboth zero-extending (vssrl) and sign-extending (vssra) forms.  The\ndata to be shifted is in the vector register group specified by vs2\nand the shift amount value can come from a vector register group\nvs1, a scalar integer register rs1, or a zero-extended 5-bit\nimmediate.",
    "norm:vssrl_vssra_shamt": "Only the low lg2(SEW) bits of the shift-amount value are used to control the shift amount.",
    "norm:vnclipu_vnclip_op": "The vnclip instructions are used to pack a fixed-point value into a\nnarrower destination.  The instructions support rounding, scaling, and\nsaturation into the final destination format.  The source data is in\nthe vector register group specified by vs2. The scaling shift amount\nvalue can come from a vector register group vs1, a scalar integer\nregister rs1, or a zero-extended 5-bit immediate.",
    "norm:vnclipu_vnclip_shamt": "The low\nlg2(2*SEW) bits of the vector or scalar shift-amount value (e.g., the\nlow 6 bits for a SEW=64-bit to SEW=32-bit narrowing operation) are\nused to control the right shift amount, which provides the scaling.",
    "norm:vnclipu_vnclip_rounding": "For vnclipu/vnclip, the rounding mode is specified in the vxrm\nCSR.  Rounding occurs around the least-significant bit of the\ndestination and before saturation.",
    "norm:vnclipu_overflow": "For vnclipu, the shifted rounded source value is treated as an\nunsigned integer and saturates if the result would overflow the\ndestination viewed as an unsigned integer.",
    "norm:vnclip_overflow": "For vnclip, the shifted rounded source value is treated as a signed\ninteger and saturates if the result would overflow the destination viewed\nas a signed integer.",
    "norm:vxsat_op_vnclip_u": "If any destination element is saturated, the vxsat bit is set in the\nvxsat register.",
    "norm:V_fp_EEW_IEEE_nsupported_rsv": "If the EEW of a vector\nfloating-point operand does not correspond to a supported IEEE\nfloating-point type, the instruction encoding is reserved.",
    "norm:Vf_requrires_Vx": "Vector floating-point instructions require the presence of base scalar\nfloating-point extensions corresponding to the supported vector\nfloating-point element widths.",
    "norm:mstatus-FS_off_V_fp_ill": "If the floating-point unit status field mstatus.FS is Off then any\nattempt to execute a vector floating-point instruction will raise an\nillegal-instruction exception.",
    "norm:mstatus-FS_dirty_V_fp": "Any vector floating-point instruction\nthat modifies any floating-point extension state (i.e., floating-point\nCSRs or f registers) must set mstatus.FS to Dirty.",
    "norm:vsstatus_mstatus-FS_off_hypervisor_V_fp_ill": "If the hypervisor extension is implemented and V=1, the vsstatus.FS field is\nadditionally in effect for vector floating-point instructions.  If\nvsstatus.FS or mstatus.FS is Off then any\nattempt to execute a vector floating-point instruction will raise an\nillegal-instruction exception.",
    "norm:vsstatus_mstatus-FS_dirty_hypervisor_V_fp": "Any vector floating-point instruction\nthat modifies any floating-point extension state (i.e., floating-point\nCSRs or f registers) must set both mstatus.FS and vsstatus.FS to Dirty.",
    "norm:fflags_op_V_fp": "A vector floating-point exception at any active floating-point element\nsets the standard FP exception flags in the fflags register.  Inactive\nelements do not set FP exception flags.",
    "norm:vfadd_vfsub_vfrsub_op": "# Floating-point add\nvfadd.vv vd, vs2, vs1, vm   # Vector-vector\nvfadd.vf vd, vs2, rs1, vm   # vector-scalar\n\n# Floating-point subtract\nvfsub.vv vd, vs2, vs1, vm   # Vector-vector\nvfsub.vf vd, vs2, rs1, vm   # Vector-scalar vd[i] = vs2[i] - f[rs1]\nvfrsub.vf vd, vs2, rs1, vm  # Scalar-vector vd[i] = f[rs1] - vs2[i]",
    "norm:vfwadd_op": "# Widening FP add/subtract, 2*SEW = SEW +/- SEW\nvfwadd.vv vd, vs2, vs1, vm  # vector-vector\nvfwadd.vf vd, vs2, rs1, vm  # vector-scalar\nvfwsub.vv vd, vs2, vs1, vm  # vector-vector\nvfwsub.vf vd, vs2, rs1, vm  # vector-scalar\n\n# Widening FP add/subtract, 2*SEW = 2*SEW +/- SEW\nvfwadd.wv  vd, vs2, vs1, vm  # vector-vector\nvfwadd.wf  vd, vs2, rs1, vm  # vector-scalar\nvfwsub.wv  vd, vs2, vs1, vm  # vector-vector\nvfwsub.wf  vd, vs2, rs1, vm  # vector-scalar",
    "norm:vfmul_vfdiv_vfrdiv_op": "# Floating-point multiply\nvfmul.vv vd, vs2, vs1, vm   # Vector-vector\nvfmul.vf vd, vs2, rs1, vm   # vector-scalar\n\n# Floating-point divide\nvfdiv.vv vd, vs2, vs1, vm   # Vector-vector\nvfdiv.vf vd, vs2, rs1, vm   # vector-scalar\n\n# Reverse floating-point divide vector = scalar / vector\nvfrdiv.vf vd, vs2, rs1, vm  # scalar-vector, vd[i] = f[rs1]/vs2[i]",
    "norm:vfwmul_op": "# Widening floating-point multiply\nvfwmul.vv    vd, vs2, vs1, vm # vector-vector\nvfwmul.vf    vd, vs2, rs1, vm # vector-scalar",
    "norm:vfmacc_vfnmacc_vfmsac_vfnmsac_vfmadd_vfnmadd_vfmsub_vfnmsub_op": "All four varieties of fused multiply-add are provided, and in two\ndestructive forms that overwrite one of the operands, either the\naddend or the first multiplicand.",
    "norm:vfwmacc_vfwnmacc_vfwmsac_vfwnmsac_op": "The widening floating-point fused multiply-add instructions all\noverwrite the wide addend with the result.  The multiplier inputs are\nall SEW wide, while the addend and destination is 2*SEW bits wide.",
    "norm:vfsqrt_op": "# Floating-point square root\nvfsqrt.v vd, vs2, vm   # Vector-vector square root",
    "norm:vfrsqrt7_op": "This is a unary vector-vector instruction that returns an estimate of\n1/sqrt(x) accurate to 7 bits.",
    "norm:vfrsqrt7_op_unex": "For the non-exceptional cases, the low bit of the exponent and the six high\nbits of significand (after the leading one) are concatenated and used to\naddress the following table.\nThe output of the table becomes the seven high bits of the result significand\n(after the leading one); the remainder of the result significand is zero.\nSubnormal inputs are normalized and the exponent adjusted appropriately before\nthe lookup.\nThe output exponent is chosen to make the result approximate the reciprocal of\nthe square root of the argument.",
    "norm:vfrsqrt7_op_precise": "More precisely, the result is computed as follows.\nLet the normalized input exponent be equal to the input exponent if the input\nis normal, or 0 minus the number of leading zeros in the significand\notherwise.\nIf the input is subnormal, the normalized input significand is given by\nshifting the input significand left by 1 minus the normalized input exponent,\ndiscarding the leading 1 bit.\nThe output exponent equals floor((3*B - 1 - the normalized input exponent) / 2),\nwhere B is the exponent bias. The output sign equals the input sign.",
    "norm:vfrec7_op": "This is a unary vector-vector instruction that returns an estimate of\n1/x accurate to 7 bits.",
    "norm:vfrec7_op_unex": "For the non-exceptional cases, the seven high bits of significand (after the\nleading one) are used to address the following table.\nThe output of the table becomes the seven high bits of the result significand\n(after the leading one); the remainder of the result significand is zero.\nSubnormal inputs are normalized and the exponent adjusted appropriately before\nthe lookup.\nThe output exponent is chosen to make the result approximate the reciprocal of\nthe argument, and subnormal outputs are denormalized accordingly.",
    "norm:vfrec7_op_precise": "More precisely, the result is computed as follows.\nLet the normalized input exponent be equal to the input exponent if the input\nis normal, or 0 minus the number of leading zeros in the significand\notherwise.\nThe normalized output exponent equals (2*B - 1 - the normalized input exponent).\nIf the normalized output exponent is outside the range [-1, 2*B], the result\ncorresponds to one of the exceptional cases in the table above.",
    "norm:vfrec7_op_subnorm": "If the input is subnormal, the normalized input significand is given by\nshifting the input significand left by 1 minus the normalized input exponent,\ndiscarding the leading 1 bit.\nOtherwise, the normalized input significand equals the input significand.\nThe following table gives the seven MSBs of the normalized output significand\nas a function of the seven MSBs of the normalized input significand; the other\nbits of the normalized output significand are zero.",
    "norm:vfrec7_op_output": "If the normalized output exponent is 0 or -1, the result is subnormal: the\noutput exponent is 0, and the output significand is given by concatenating\na 1 bit to the left of the normalized output significand, then shifting that\nquantity right by 1 minus the normalized output exponent.\nOtherwise, the output exponent equals the normalized output exponent, and the\noutput significand equals the normalized output significand.\nThe output sign equals the input sign.",
    "norm:vfmin_vfmax_op": "The vector floating-point vfmin and vfmax instructions have the\nsame behavior as the corresponding scalar floating-point instructions\nin version 2.2 of the RISC-V F/D/Q extension: they perform the minimumNumber\nor maximumNumber operation on active elements.",
    "norm:vfsgnj_vfsgnjn_vfsgnjx_op": "Vector versions of the scalar sign-injection instructions.  The result\ntakes all bits except the sign bit from the vector vs2 operands.",
    "norm:vmfeq_vmfne_vmflt_vmfle_vmfgt_vmfge_op": "These vector FP compare instructions compare two source operands and\nwrite the comparison result to a mask register.",
    "norm:vmfeq_vmfne_vmflt_vmfle_vmfgt_vmfge_vd_single_vreg": "The destination mask\nvector is always held in a single vector register, with a layout of\nelements as described in &lt;&lt;sec-mask-register-layout&gt;&gt;.",
    "norm:vmfeq_vmfne_vmflt_vmfle_vmfgt_vmfge_vd_eq_v0": "The\ndestination mask vector register may be the same as the source vector\nmask register (v0).",
    "norm:vmfeq_vmfne_vmflt_vmfle_vmfgt_vmfge_tail_agnostic": "Compares write mask registers, and so always\noperate under a tail-agnostic policy.",
    "norm:vmfeq_vmfne_sNaN_invalid": "vmfeq and vmfne raise the invalid\noperation exception only on signaling NaN inputs.",
    "norm:vmflt_vmfle_vmfgt_vmfge_sqNaN_invalid": "vmflt, vmfle, vmfgt,\nand vmfge raise the invalid operation exception on both signaling and\nquiet NaN inputs.",
    "norm:vmfne_vdval1_NaN": "vmfne writes 1 to the destination element when either\noperand is NaN,",
    "norm:vmfeq_vmflt_vmfle_vmfgt_vmfge_vdval0_NaN": "whereas the other compares write 0 when either operand\nis NaN.",
    "norm:vfclass_op": "This is a unary vector-vector instruction that operates in the same\nway as the scalar classify instruction.",
    "norm:vfclass_op_result": "The 10-bit mask produced by this instruction is placed in the\nleast-significant bits of the result elements.  The upper (SEW-10)\nbits of the result are filled with zeros.",
    "norm:vfclass_SEWge16": "The instruction is only\ndefined for SEW=16b and above, so the result will always fit in the\ndestination elements.",
    "norm:vfmerge_op": "A vector-scalar floating-point merge instruction is provided,",
    "norm:vfmerge_all_elem": "operates on all body elements from vstart up to the current vector\nlength in vl regardless of mask value.",
    "norm:vfmerge_op_mask": "At elements where the mask value is zero, the first vector operand is\ncopied to the destination element, otherwise a scalar floating-point\nregister value is copied to the destination element.",
    "norm:vfmv_op": "The vector floating-point move instruction splats a floating-point\nscalar operand to a vector register group.  The instruction copies a\nscalar f register value to all active elements of a vector register\ngroup.",
    "norm:vfmv_vs2_nv0_rsv": "The instruction must have the vs2 field set to v0, with all other\nvalues for vs2 reserved.",
    "norm:vfcvt_op": "Conversion operations are provided to convert to and from\nfloating-point values and unsigned and signed integers, where both\nsource and destination are SEW wide.",
    "norm:vfcvt_op_exceptions": "The conversions follow the same rules on exceptional conditions as the\nscalar conversion instructions.",
    "norm:vfcvt_op_frm": "The conversions use the dynamic rounding mode in frm, except for the rtz\nvariants, which round towards zero.",
    "norm:vfwcvt_op": "A set of conversion instructions is provided to convert between\nnarrower integer and floating-point datatypes to a type of twice the\nwidth.",
    "norm:vfwcvt_vreg_constr": "These instructions have the same constraints on vector register overlap\nas other widening instructions (see &lt;&lt;sec-widening&gt;&gt;).",
    "norm:vfncvt_op": "A set of conversion instructions is provided to convert wider integer\nand floating-point datatypes to a type of half the width.",
    "norm:vfncvt_vreg_constr": "These instructions have the same constraints on vector register overlap\nas other narrowing instructions (see &lt;&lt;sec-narrowing&gt;&gt;).",
    "norm:vreduction_scalar_def": "Vector reduction operations take a vector register group of elements\nand a scalar held in element 0 of a vector register, and perform a\nreduction using some binary operator, to produce a scalar result in\nelement 0 of a vector register.",
    "norm:vreduction_scalar_disregard_LMUL": "The scalar input and output operands\nare held in element 0 of a single vector register, not a vector\nregister group, so any vector register can be the scalar source or\ndestination of a vector reduction regardless of LMUL setting.",
    "norm:vreduction_vd_overlap_vs": "The destination vector register can overlap the source operands,\nincluding the mask register.",
    "norm:vreduction_scalar_disregard_maskval": "Inactive elements from the source vector register group are excluded\nfrom the reduction, but the scalar operand is always included\nregardless of the mask values.",
    "norm:vreduction_tail_policy": "The other elements in the destination vector register ( 0 &lt; index &lt;\nVLEN/SEW) are considered the tail and are managed with the current\ntail agnostic/undisturbed policy.",
    "norm:vreduction_vl_0": "If vl=0, no operation is performed and the destination register is\nnot updated.",
    "norm:vreduction_trap": "Traps on vector reduction instructions are always reported with a\nvstart of 0.",
    "norm:vreduction_vstart_n0_ill": "Vector reduction operations raise an\nillegal-instruction exception if vstart is non-zero.",
    "norm:vredsum_vredmaxu_vredmax_vredminu_vredmin_vredand_vredor_vredxor_op": "All operands and results of single-width reduction instructions have\nthe same SEW width.",
    "norm:vredsum_vredmaxu_vredmax_vredminu_vredmin_vredand_vredor_vredxor_overflow": "Overflows wrap around on arithmetic sums.",
    "norm:vwredsumu_op": "The unsigned vwredsumu.vs instruction zero-extends the SEW-wide\nvector elements before summing them, then adds the 2*SEW-width scalar\nelement, and stores the result in a 2*SEW-width scalar element.",
    "norm:vwredsum_op": "The vwredsum.vs instruction sign-extends the SEW-wide vector\nelements before summing them.",
    "norm:vwredsumu_vwredsum_op_overflow": "For both vwredsumu.vs and vwredsum.vs, overflows wrap around.",
    "norm:vfredosum_op": "The vfredosum instruction must sum the floating-point values in\nelement order, starting with the scalar in vs1[0]",
    "norm:vfredosum_op_exceptions": "where each addition operates identically to the scalar floating-point\ninstructions in terms of raising exception flags and generating or\npropagating special values.",
    "norm:vfredosum_maskoff": "When the operation is masked (vm=0), the masked-off elements do not\naffect the result or the exception flags.",
    "norm:vfredusum_op": "The implementation must produce a result equivalent to a reduction tree\ncomposed of binary operator nodes, with the inputs being elements from\nthe source vector register group (vs2) and the source scalar value\n(vs1[0]).  Each operator in the tree accepts two inputs and produces\none result.\nEach operator first computes an exact sum as a RISC-V scalar floating-point\naddition with infinite exponent range and precision, then converts this exact\nsum to a floating-point format with range and precision each at least as great\nas the element floating-point format indicated by SEW, rounding using the\ncurrently active floating-point dynamic rounding mode and raising exception\nflags as necessary.\nA different floating-point range and precision may be chosen for the result of\neach operator.\nA node where one input is derived only from elements masked-off or beyond the\nactive vector length may either treat that input as the additive identity of the\nappropriate EEW or simply copy the other input to its output.\nThe rounded result from the root node in the tree is converted (rounded again,\nusing the dynamic rounding mode) to the standard floating-point format\nindicated by SEW.",
    "norm:vfredusum_additive_impl": "The additive identity is +0.0 when rounding down (towards -{inf}) or\n-0.0 for all other rounding modes.",
    "norm:vfredusum_redtree": "The reduction tree structure must be deterministic for a given value\nin vtype and vl.",
    "norm:vfredmin_vfredmax_op": "The vfredmin and vfredmax instructions reduce the scalar argument in\nvs1[0] and active elements in vs2 using the minimumNumber and\nmaximumNumber operations, respectively.",
    "norm:vfwredosum_vfwredusum_op": "Widening forms of the sum reductions are provided that\nread and write a double-width reduction result.",
    "norm:vfwredosum_vfwredusum_op_reduction": "The reduction of the SEW-width elements is performed as in the\nsingle-width reduction case, with the elements in vs2 promoted\nto 2*SEW bits before adding to the 2*SEW-bit accumulator.",
    "norm:vmask_maskreg_def": "Vector mask-register logical operations operate on mask registers.\nEach element in a mask register is a single bit,",
    "norm:instrgrp_vmask_disregard_vlmul": "so these instructions\nall operate on single vector registers regardless of the setting of\nthe vlmul field in vtype.  They do not change the value of\nvlmul.",
    "norm:vmask_vd_overlap_vs": "The destination vector register may be the same as either\nsource vector register.",
    "norm:vmask_vstart": "As with other vector instructions, the elements with indices less than\nvstart are unchanged, and vstart is reset to zero after execution.",
    "norm:vmasklogical_unmasked": "Vector mask logical instructions are always unmasked,",
    "norm:vmasklogical_masked_rsv": "so there are no\ninactive elements, and the encodings with vm=0 are reserved.",
    "norm:vmasklogical_tail_agnostic": "Mask elements past vl, the tail elements, are\nalways updated with a tail-agnostic policy.",
    "norm:vmand_vmnand_vmandn_vmxor_vmor_vmnor_vmorn_vmxnor_op": "vmand.mm vd, vs2, vs1   # vd.mask[i] =   vs2.mask[i] &amp;&amp;  vs1.mask[i]\nvmnand.mm vd, vs2, vs1  # vd.mask[i] = !(vs2.mask[i] &amp;&amp;  vs1.mask[i])\nvmandn.mm vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] &amp;&amp; !vs1.mask[i]\nvmxor.mm  vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] ^^  vs1.mask[i]\nvmor.mm  vd, vs2, vs1   # vd.mask[i] =   vs2.mask[i] ||  vs1.mask[i]\nvmnor.mm  vd, vs2, vs1  # vd.mask[i] = !(vs2.mask[i] ||  vs1.mask[i])\nvmorn.mm  vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] || !vs1.mask[i]\nvmxnor.mm vd, vs2, vs1  # vd.mask[i] = !(vs2.mask[i] ^^  vs1.mask[i])",
    "norm:vcpop_vs_single_vreg": "The source operand is a single vector register holding mask register\nvalues as described in &lt;&lt;sec-mask-register-layout&gt;&gt;.",
    "norm:vcpop_op": "The vcpop.m instruction counts the number of mask elements of the\nactive elements of the vector source mask register that have the value\n1 and writes the result to a scalar x register.",
    "norm:vcpop_op_mask": "The operation can be performed under a mask, in which case only the\nmasked elements are counted.",
    "norm:vcpop_vl0": "The vcpop.m instruction writes x[rd] even if vl=0 (with the\nvalue 0, since no mask elements are active).",
    "norm:vcpop_trap": "Traps on vcpop.m are always reported with a vstart of 0.",
    "norm:vcpop_vstart_n0_ill": "The\nvcpop.m instruction will raise an illegal-instruction exception if\nvstart is non-zero.",
    "norm:vfirst_op": "The vfirst instruction finds the lowest-numbered active element of\nthe source mask vector that has the value 1 and writes that element's\nindex to a GPR.  If no active element has the value 1, -1 is written\nto the GPR.",
    "norm:vfirst_vl0": "The vfirst.m instruction writes x[rd] even if vl=0 (with the\nvalue -1, since no mask elements are active).",
    "norm:vfirst_trap": "Traps on vfirst are always reported with a vstart of 0.",
    "norm:vfirst_vstart_n0_ill": "The\nvfirst instruction will raise an illegal-instruction exception if\nvstart is non-zero.",
    "norm:vmsbf_op": "The vmsbf.m instruction takes a mask register as input and writes\nresults to a mask register.  The instruction writes a 1 to all active\nmask elements before the first active source element that is a 1, then\nwrites a 0 to that element and all following active elements.  If\nthere is no set bit in the active elements of the source vector, then\nall active elements in the destination are written with a 1.",
    "norm:vmsbf_tail_agnostic": "The tail elements in the destination mask register are updated under a\ntail-agnostic policy.",
    "norm:vmsbf_trap": "Traps on vmsbf.m are always reported with a vstart of 0.",
    "norm:vmsbf_vstart_n0_ill": "The\nvmsbf instruction will raise an illegal-instruction exception if\nvstart is non-zero.",
    "norm:vmsbf_vreg_constr": "The destination register cannot overlap the source register\nand, if masked, cannot overlap the mask register ('v0').",
    "norm:vmsif_op": "The vector mask set-including-first instruction is similar to\nset-before-first, except it also includes the element with a set bit.",
    "norm:vmsif_tail_agnostic": "The tail elements in the destination mask register are updated under a\ntail-agnostic policy.",
    "norm:vmsif_trap": "Traps on vmsif.m are always reported with a vstart of 0.",
    "norm:vmsif_vstart_n0_ill": "The\nvmsif instruction will raise an illegal-instruction exception if\nvstart is non-zero.",
    "norm:vmsif_vreg_constr": "The destination register cannot overlap the source register\nand, if masked, cannot overlap the mask register ('v0').",
    "norm:vmsof_op": "The vector mask set-only-first instruction is similar to\nset-before-first, except it only sets the first element with a bit\nset, if any.",
    "norm:vmsof_tail_agnostic": "The tail elements in the destination mask register are updated under a\ntail-agnostic policy.",
    "norm:vmsof_trap": "Traps on vmsof.m are always reported with a vstart of 0.",
    "norm:vmsof_vstart_n0_ill": "The\nvmsof instruction will raise an illegal-instruction exception if\nvstart is non-zero.",
    "norm:vmsof_vreg_constr": "The destination register cannot overlap the source register\nand, if masked, cannot overlap the mask register ('v0').",
    "norm:viota_op": "The viota.m instruction reads a source vector mask register and\nwrites to each element of the destination vector register group the\nsum of all the bits of elements in the mask register\nwhose index is less than the element, e.g., a parallel prefix sum of\nthe mask values.",
    "norm:viota_op_masked": "This instruction can be masked, in which case only the enabled\nelements contribute to the sum.",
    "norm:viota_op_zext": "The result value is zero-extended to fill the destination element if\nSEW is wider than the result.",
    "norm:viota_op_overflow": "If the result value would overflow the\ndestination SEW, the least-significant SEW bits are retained.",
    "norm:viota_trap": "Traps on viota.m are always reported with a vstart of 0,",
    "norm:viota_restart": "execution is always restarted from the beginning when resuming after a\ntrap handler.",
    "norm:viota_vstart_n0_ill": "An illegal-instruction exception is raised if vstart\nis non-zero.",
    "norm:viota_vreg_constr": "The destination register group cannot overlap the source register\nand, if masked, cannot overlap the mask register (v0).",
    "norm:vid_op": "The vid.v instruction writes each element's index to the\ndestination vector register group, from 0 to vl-1.",
    "norm:vid_op_mask": "The instruction can be masked.  Masking does not change the\nindex value written to active elements.",
    "norm:vid_vs2_nv0_rsv": "The vs2 field of the instruction must be set to v0, otherwise the\nencoding is reserved.",
    "norm:vid_op_zext": "The result value is zero-extended to fill the destination element if\nSEW is wider than the result.",
    "norm:vid_op_overflow": "If the result value would overflow the\ndestination SEW, the least-significant SEW bits are retained.",
    "norm:vmv-x-s_vmv-s-x_ignoreLMUL": "The instructions ignore LMUL and vector register groups.",
    "norm:vmv-x-s_op": "The vmv.x.s instruction copies a single SEW-wide element from index 0 of the\nsource vector register to a destination integer register.  If SEW &gt; XLEN, the\nleast-significant XLEN bits are transferred and the upper SEW-XLEN bits are\nignored.  If SEW &lt; XLEN, the value is sign-extended to XLEN bits.",
    "norm:vmv-x-s_vstartgevl_vl0": "vmv.x.s performs its operation even if vstart {ge} vl or vl=0.",
    "norm:vmv-s-x_op": "The vmv.s.x instruction copies the scalar integer register to element 0 of\nthe destination vector register.  If SEW &lt; XLEN, the least-significant bits\nare copied and the upper XLEN-SEW bits are ignored.  If SEW &gt; XLEN, the value\nis sign-extended to SEW bits.  The other elements in the destination vector\nregister ( 0 &lt; index &lt; VLEN/SEW) are treated as tail elements using the current tail agnostic/undisturbed policy.",
    "norm:vmv-s-x_vstart_ge_vl": "If vstart {ge} vl, no\noperation is performed and the destination register is not updated.",
    "norm:vmv-s-x_vmv-x-s_masked_rsv": "The encodings corresponding to the masked versions (vm=0) of vmv.x.s\nand vmv.s.x are reserved.",
    "norm:vfmv-f-s_vfmv-s-f_ignoreLMUL": "The instructions ignore LMUL and vector register groups.",
    "norm:vfmv-f-s_op": "The vfmv.f.s instruction copies a single SEW-wide element from index\n0 of the source vector register to a destination scalar floating-point\nregister.",
    "norm:vfmv-s-f_op": "The vfmv.s.f instruction copies the scalar floating-point register\nto element 0 of the destination vector register.  The other elements\nin the destination vector register ( 0 &lt; index &lt; VLEN/SEW) are treated\nas tail elements using the current tail agnostic/undisturbed policy.",
    "norm:vfmv-s-f_vstart_ge_vl": "If vstart {ge} vl, no operation is performed and the destination\nregister is not updated.",
    "norm:vfmv-s-f_masked_rsv": "The encodings corresponding to the masked versions (vm=0) of vfmv.f.s\nand vfmv.s.f are reserved.",
    "norm:vslide_vstart_ge_vl": "For all of the vslideup, vslidedown, v[f]slide1up, and\nv[f]slide1down instructions, if vstart {ge} vl, the instruction performs no\noperation and leaves the destination vector register unchanged.",
    "norm:vslide_mask": "The slide instructions may be masked, with mask element i\ncontrolling whether destination element i is written.  The mask\nundisturbed/agnostic policy is followed for inactive elements.",
    "norm:vslideup_op": "For vslideup, the value in vl specifies the maximum number of destination\nelements that are written.  The start index (OFFSET) for the\ndestination can be either specified using an unsigned integer in the\nx register specified by rs1, or a 5-bit immediate, zero-extended to XLEN bits.\nIf XLEN &gt; SEW, OFFSET is not truncated to SEW bits.\nDestination elements OFFSET through vl-1 are written if unmasked and\nif OFFSET &lt; vl.",
    "norm:vslideup_vreg_constr": "The destination vector register group for vslideup cannot overlap\nthe source vector register group, otherwise the instruction encoding\nis reserved.",
    "norm:vslidedown_op": "For vslidedown, the value in vl specifies the maximum number of\ndestination elements that are written.  The remaining elements past\nvl are handled according to the current tail policy\n(&lt;&lt;sec-agnostic&gt;&gt;).",
    "norm:vslidedown_op_src": "The start index (OFFSET) for the source can be either specified\nusing an unsigned integer in the x register specified by rs1, or a\n5-bit immediate, zero-extended to XLEN bits.\nIf XLEN &gt; SEW, OFFSET is not truncated to SEW bits.",
    "norm:vslide1up-vx_op": "The vslide1up instruction places the x register argument at\nlocation 0 of the destination vector register group, provided that\nelement 0 is active, otherwise the destination element update follows the\ncurrent mask agnostic/undisturbed policy.  If XLEN &lt; SEW, the value is\nsign-extended to SEW bits.  If XLEN &gt; SEW, the least-significant bits\nare copied over and the high XLEN-SEW bits are ignored.",
    "norm:vslide1up-vx_op_rem_elem": "The remaining active vl-1 elements are copied over from index i in\nthe source vector register group to index i+1 in the destination\nvector register group.",
    "norm:vslide1up-vx_op_vl": "The vl register specifies the maximum number of destination vector\nregister elements updated with source values, and remaining elements\npast vl are handled according to the current tail policy\n(&lt;&lt;sec-agnostic&gt;&gt;).",
    "norm:vslide1up-vx_vreg_constr": "The vslide1up instruction requires that the destination vector\nregister group does not overlap the source vector register group.\nOtherwise, the instruction encoding is reserved.",
    "norm:vslide1up-vf_op": "The vfslide1up instruction is defined analogously to vslide1up,\nbut sources its scalar argument from an f register.",
    "norm:vslide1down-vx_op": "The vslide1down instruction copies the first vl-1 active elements\nvalues from index i+1 in the source vector register group to index\ni in the destination vector register group.",
    "norm:vslide1down-vx_op_vl": "The vl register specifies the maximum number of destination vector\nregister elements written with source values, and remaining elements\npast vl are handled according to the current tail policy\n(&lt;&lt;sec-agnostic&gt;&gt;).",
    "norm:vslide1down-vx_op_details": "The vslide1down instruction places the x register argument at\nlocation vl-1 in the destination vector register, provided that\nelement vl-1 is active, otherwise the destination element update\nfollows the current mask agnostic/undisturbed policy.\nIf XLEN &lt; SEW, the value is sign-extended to SEW bits.  If\nXLEN &gt; SEW, the least-significant bits are copied over and the high\nSEW-XLEN bits are ignored.",
    "norm:vslide1down-vf_op": "The vfslide1down instruction is defined analogously to vslide1down,\nbut sources its scalar argument from an f register.",
    "norm:vrgather_vrgatherei16_vs2_uint": "The index values in the second vector are\ntreated as unsigned integers.",
    "norm:vrgather_vrgatherei16_vs_ignore_vl": "The source vector can be read at any\nindex &lt; VLMAX regardless of vl.",
    "norm:vrgather_vrgatherei16_vl": "The maximum number of elements to write to\nthe destination register is given by vl,",
    "norm:vrgather_vrgatherei16_tail": "and the remaining elements\npast vl are handled according to the current tail policy\n(&lt;&lt;sec-agnostic&gt;&gt;).",
    "norm:vrgather_vrgatherei16_mask": "The operation can be masked, and the mask\nundisturbed/agnostic policy is followed for inactive elements.",
    "norm:vrgather-vv_op_vrgatherei16-vv_op": "vrgather.vv vd, vs2, vs1, vm     # vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];\nvrgatherei16.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];",
    "norm:vrgather-vv_sew_lmul": "The vrgather.vv form uses SEW/LMUL for both the data and\nindices.",
    "norm:vrgatherei16-vv_sew_lmul": "The vrgatherei16.vv form uses SEW/LMUL for the data in\nvs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1.",
    "norm:vrgather_vrgatherei16_id_ge_VLMAX": "If an element index is out of range ( vs1[i] {ge} VLMAX )\nthen zero is returned for the element value.",
    "norm:vrgather-vx_vrgather-vi_op": "Vector-scalar and vector-immediate forms of the register gather are\nalso provided.  These read one element from the source vector at the\ngiven index, and write this value to the active elements\nof the destination vector register. The index value in the scalar\nregister and the immediate, zero-extended to XLEN bits, are treated as\nunsigned integers.  If XLEN &gt; SEW, the index value is not truncated\nto SEW bits.",
    "norm:vrgather_vrgatherei16_vreg_constr": "For any vrgather instruction, the destination vector register group\ncannot overlap with the source vector register groups, otherwise the\ninstruction encoding is reserved.",
    "norm:vcompress_op": "The vector mask register specified by vs1 indicates which of the\nfirst vl elements of vector register group vs2 should be extracted\nand packed into contiguous elements at the beginning of vector\nregister vd. The remaining elements of vd are treated as tail\nelements according to the current tail policy\n(&lt;&lt;sec-agnostic&gt;&gt;).",
    "norm:vcompress_enc": "T`vcompress` is encoded as an unmasked instruction (vm=1).",
    "norm:vcompress_masked_rsv": "The equivalent\nmasked instruction (vm=0) is reserved.",
    "norm:vcompress_vreg_constr": "The destination vector register group cannot overlap the source vector\nregister group or the source mask register, otherwise the instruction\nencoding is reserved.",
    "norm:vcompress_trap": "A trap on a vcompress instruction is always reported with a\nvstart of 0.",
    "norm:vcompress_vstart_n0_ill": "Executing a vcompress instruction with a non-zero\nvstart raises an illegal-instruction exception.",
    "norm:vmv-nr-r_op": "The vmv&lt;nr&gt;r.v instructions copy whole vector registers (i.e., all\nVLEN bits) and can copy whole vector register groups.  The nr value\nin the opcode is the number of individual vector registers, NREG, to\ncopy.  The instructions operate as if EEW=SEW, EMUL = NREG, effective\nlength evl= EMUL * VLEN/SEW.",
    "norm:vmv-nr-r_enc": "The instruction is encoded as an OPIVI instruction.  The number of\nvector registers to copy is encoded in the low three bits of the\nsimm field (simm[2:0]) using the same encoding as the nf[2:0] field for memory\ninstructions (Figure &lt;&lt;fig-nf&gt;&gt;), i.e., simm[2:0] = NREG-1.",
    "norm:vmv-nr-r_nreg_rsv": "The value of NREG must be 1, 2, 4, or 8, and values of simm[4:0]\nother than 0, 1, 3, and 7 are reserved.",
    "norm:vmv-nr-r_vreg_constr": "The source and destination vector register numbers must be aligned\nappropriately for the vector register group size,",
    "norm:vmv-nr-r_unaligned_rsv": "encodings with\nother vector register numbers are reserved.",
    "norm:epc_vstart_op_V_trap": "On a trap during a vector instruction (caused by either a synchronous\nexception or an asynchronous interrupt), the existing *epc CSR is\nwritten with a pointer to the trapping vector instruction, while the\nvstart CSR contains the element index on which the trap was\ntaken.",
    "norm:Zve_XLEN": "Any of these extensions can be added to base ISAs with\nXLEN=32 or XLEN=64.",
    "norm:Zve32f_Zve64x_dependent_Zve32x": "The Zve32f and Zve64x extensions depend on the Zve32x extension.",
    "norm:Zve64f_dependent_Zve32f_Zve64x": "The Zve64f extension depends on the Zve32f and Zve64x extensions.",
    "norm:Zve64d_dependent_Zve64f": "The Zve64d extension depends on the Zve64f extension.",
    "norm:Zve_precise_traps": "All Zve* extensions have precise traps.",
    "norm:Zve_eew": "All Zve* extensions provide support for EEW of 8, 16, and 32, and\nZve64* extensions also support EEW of 64.",
    "norm:Zve_nsupport_eew64_xlen32": "All Zve* extensions support all vector load and store instructions\n(&lt;&lt;sec-vector-memory&gt;&gt;), except Zve64* extensions do not\nsupport EEW=64 for index values when XLEN=32.",
    "norm:Zve64_eew64_nsupport_vmulh": "All Zve* extensions support all vector integer instructions\n(&lt;&lt;sec-vector-integer&gt;&gt;), except that the vmulh integer multiply\nvariants that return the high word of the product (vmulh.vv,\nvmulh.vx, vmulhu.vv, vmulhu.vx, vmulhsu.vv, vmulhsu.vx) are\nnot included for EEW=64 in Zve64*.",
    "norm:Zve64_eew64_nsupport_vsmul": "All Zve* extensions support all vector fixed-point arithmetic\ninstructions (&lt;&lt;sec-vector-fixed-point&gt;&gt;), except that vsmul.vv and\nvsmul.vx are not included in EEW=64 in Zve64*.",
    "norm:Zve32x_Zve64x_nsupport_freg": "All Zve* extensions support all vector permutation instructions\n(&lt;&lt;sec-vector-permute&gt;&gt;), except that Zve32x and Zve64x\ndo not include those with floating-point operands, and Zve64f does not include those\nwith EEW=64 floating-point operands.",
    "norm:Zve32x_dependent_Zicsr": "The Zve32x extension depends on the Zicsr extension.",
    "norm:Zve32f_Zve64f_dependent_F": "The Zve32f and Zve64f extensions depend upon the F extension,\nand implement all\nvector floating-point instructions (&lt;&lt;sec-vector-float&gt;&gt;) for\nfloating-point operands with EEW=32. Vector single-width floating-point reduction\noperations (&lt;&lt;sec-vector-float-reduce&gt;&gt;) for EEW=32 are supported.",
    "norm:misa-V_op": "The misa.v bit is set for implementations providing misa and\nsupporting V.",
    "norm:V_precise_traps": "The V vector extension has precise traps.",
    "norm:V_dependent_Zvl128b_Zve64d": "The V vector extension depends upon the Zvl128b and Zve64d extensions.",
    "norm:V_supported_eew": "The V extension supports EEW of 8, 16, and 32, and 64.",
    "norm:V_instr_config": "The V extension supports the vector configuration instructions\n(&lt;&lt;sec-vector-config&gt;&gt;).",
    "norm:V_instr_ls_eew64_nsupported_xlen32": "The V extension supports all vector load and store instructions\n(&lt;&lt;sec-vector-memory&gt;&gt;), except the V extension does not\nsupport EEW=64 for index values when XLEN=32.",
    "norm:V_instr_int": "The V extension supports all vector integer instructions\n(&lt;&lt;sec-vector-integer&gt;&gt;).",
    "norm:V_instr_fixedpt": "The V extension supports all vector fixed-point arithmetic\ninstructions (&lt;&lt;sec-vector-fixed-point&gt;&gt;).",
    "norm:V_instr_red": "The V extension supports all vector integer single-width and\nwidening reduction operations (&lt;&lt;sec-vector-integer-reduce&gt;&gt;,\n&lt;&lt;sec-vector-integer-reduce-widen&gt;&gt;).",
    "norm:V_instr_mask": "The V extension supports all vector mask instructions\n(&lt;&lt;sec-vector-mask&gt;&gt;).",
    "norm:V_instr_perm": "The V extension supports all vector permutation instructions\n(&lt;&lt;sec-vector-permute&gt;&gt;).",
    "norm:V_dependent_F_D": "The V extension depends upon the F and D\nextensions, and implements all vector floating-point instructions\n(&lt;&lt;sec-vector-float&gt;&gt;) for floating-point operands with EEW=32\nor EEW=64 (including widening instructions and conversions between\nFP32 and FP64). Vector single-width floating-point reductions\n(&lt;&lt;sec-vector-float-reduce&gt;&gt;) for EEW=32 and EEW=64 are supported as\nwell as widening reductions from FP32 to FP64.",
    "norm:Zvfhmin_dependent_Zve32f": "The Zvfhmin extension depends on the Zve32f extension.",
    "norm:Zvfh_instr": "When the Zvfh extension is implemented, all instructions in\n&lt;&lt;sec-vector-float&gt;&gt;, &lt;&lt;sec-vector-float-reduce&gt;&gt;,\n&lt;&lt;sec-vector-float-reduce-widen&gt;&gt;, &lt;&lt;sec-vector-float-move&gt;&gt;,\n&lt;&lt;sec-vfslide1up&gt;&gt;, and &lt;&lt;sec-vfslide1down&gt;&gt;\nbecome defined when SEW=16.",
    "norm:Zvfh_eew16": "The EEW=16 floating-point operands of these instructions use the binary16\nformat.",
    "norm:Zvfh_instr_cvt": "Additionally, conversions between 8-bit integers and binary16 values are\nprovided.  The floating-point-to-integer narrowing conversions\n(vfncvt[.rtz].x[u].f.w) and integer-to-floating-point\nwidening conversions (vfwcvt.f.x[u].v) become defined when SEW=8.",
    "norm:Zvfh_dependent_Zve32f_Zfhmin": "The Zvfh extension depends on the Zve32f and Zfhmin extensions.",
    "norm:egs_ge_vlmax_rsv": "Vector instructions with EGS &gt; VLMAX are reserved.",
    "norm:egs_vl_rsv": "When an operand is a vector of element groups, the vl\nsetting must correspond to an integer multiple of the element group\nsize, with other values of vl reserved.",
    "norm:egs_vl_avl": "When element group instructions are present, an additional constraint\nis placed on the setting of vl based on an AVL value\n(augmenting &lt;&lt;constraints-on-setting-vl&gt;&gt;).\nEGSMAX is the largest EGS supported by the\nimplementation.  When AVL &gt; VLMAX, the value of vl must be set to\neither VLMAX or a positive integer multiple of EGSMAX.",
    "norm:egs_sew_eew": "The vtype SEW can be used to indicate or calculate the effective\nelement size (EEW) of one or more operands of an element group\ninstruction.  Where the operand is an element group, SEW and EEW refer\nto the number of bits in each individual element within a group not\nthe number of bits in the group as a whole.",
    "norm:egs_lmul_emul": "The vtype LMUL setting can be used to indicate or calculate the\neffective length multiplier (EMUL) for one or more operands.  Element\ngroup instructions tend to exhibit a much wider range of relationships\nbetween various operand EEW/EMUL values.  For example, an instruction\nmight take a vector of length N of 4-element groups with EEW=8b and\nreduce each group to produce a vector length N of 1-element groups\nwith EEW=32b. In this case, the input and output EMUL values are equal\neven though the EEW settings differ by a factor of 4.",
    "norm:egs_egw": "The element group width (EGW) is the number of bits in the\nelement group as a whole.\nFor example, the SHA-256 instructions in the Zvknha extension operate on an\nEGW of 128, with EGS=4 and EEW=32.\nIt is possible to use LMUL to concatenate multiple vector registers together\nto support larger EGW&gt;VLEN.",
    "norm:zk_scalar_xreg_op": "All instructions described herein use the general-purpose X\nregisters, and obey the 2-read-1-write register access constraint.",
    "norm:zknd_shared_instr": "NOTE: The &lt;&lt;insns-aes64ks1i&gt;&gt; and &lt;&lt;insns-aes64ks2&gt;&gt; instructions are\npresent in both the &lt;&lt;zknd&gt;&gt; and &lt;&lt;zkne&gt;&gt; extensions.",
    "norm:zkne_shared_instr": "NOTE: The\n&lt;&lt;insns-aes64ks1i,aes64ks1i&gt;&gt;\nand\n&lt;&lt;insns-aes64ks2,aes64ks2&gt;&gt;\ninstructions are present in both the &lt;&lt;zknd&gt;&gt; and &lt;&lt;zkne&gt;&gt; extensions.",
    "norm:zkr_seed_addr": "The entropy source extension defines the seed CSR at address 0x015. This CSR provides up to 16 physical entropy bits that can be used to seed cryptographic random bit generators.",
    "norm:zkn_impl_all": "A core which implements Zkn must implement all of the above extensions.",
    "norm:zks_impl_all": "A core which implements Zks must implement all of the above extensions.",
    "norm:zk_impl_all": "A core which implements Zk must implement all of the above extensions.",
    "norm:aes32dsi_enc": "Encoding",
    "norm:aes32dsi_op": "Operation",
    "norm:aes32dsmi_enc": "Encoding",
    "norm:aes32dsmi_op": "Operation",
    "norm:aes32esi_enc": "Encoding",
    "norm:aes32esi_op": "Operation",
    "norm:aes32esmi_enc": "Encoding",
    "norm:aes32esmi_op": "Operation",
    "norm:aes64ds_enc": "Encoding",
    "norm:aes64ds_op": "Operation",
    "norm:aes64dsm_enc": "Encoding",
    "norm:aes64dsm_op": "Operation",
    "norm:aes64es_enc": "Encoding",
    "norm:aes64es_op": "Operation",
    "norm:aes64esm_enc": "Encoding",
    "norm:aes64esm_op": "Operation",
    "norm:aes64im_enc": "Encoding",
    "norm:aes64im_op": "Operation",
    "norm:aes64ks1i_enc": "Encoding",
    "norm:aes64ks1i_op": "Operation",
    "norm:aes64ks2_enc": "Encoding",
    "norm:aes64ks2_op": "Operation",
    "norm:sha256sig0_enc": "Encoding",
    "norm:sha256sig0_op": "Operation",
    "norm:sha256sig1_enc": "Encoding",
    "norm:sha256sig1_op": "Operation",
    "norm:sha256sum0_enc": "Encoding",
    "norm:sha256sum0_op": "Operation",
    "norm:sha256sum1_enc": "Encoding",
    "norm:sha256sum1_op": "Operation",
    "norm:sha512sig0h_enc": "Encoding",
    "norm:sha512sig0h_op": "Operation",
    "norm:sha512sig0l_enc": "Encoding",
    "norm:sha512sig0l_op": "Operation",
    "norm:sha512sig1h_enc": "Encoding",
    "norm:sha512sig1h_op": "Operation",
    "norm:sha512sig1l_enc": "Encoding",
    "norm:sha512sig1l_op": "Operation",
    "norm:sha512sum0r_enc": "Encoding",
    "norm:sha512sum0r_op": "Operation",
    "norm:sha512sum1r_enc": "Encoding",
    "norm:sha512sum1r_op": "Operation",
    "norm:sha512sig0_enc": "Encoding",
    "norm:sha512sig0_op": "Operation",
    "norm:sha512sig1_enc": "Encoding",
    "norm:sha512sig1_op": "Operation",
    "norm:sha512sum0_enc": "Encoding",
    "norm:sha512sum0_op": "Operation",
    "norm:sha512sum1_enc": "Encoding",
    "norm:sha512sum1_op": "Operation",
    "norm:sm3p0_enc": "Encoding",
    "norm:sm3p0_op": "Operation",
    "norm:sm3p1_enc": "Encoding",
    "norm:sm3p1_op": "Operation",
    "norm:sm4ed_enc": "Encoding",
    "norm:sm4ed_op": "Operation",
    "norm:sm4ks_enc": "Encoding",
    "norm:sm4ks_op": "Operation",
    "norm:seed_csr_unpriv": "seed is an unprivileged CSR located at address 0x015.",
    "norm:seed_ro_illegal": "Attempts to access the seed CSR using a read-only CSR-access instruction\n(CSRRS/CSRRC with rs1=x0 or CSRRSI/CSRRCI with uimm=0) raise an\nillegal-instruction exception; any other CSR-access instruction may be used\nto access seed.",
    "norm:seed_write_ignore": "The write value (in rs1 or uimm) must be ignored by implementations.",
    "norm:seed_exec_mode_control": "The seed CSR is also access controlled by execution mode, and attempted\nread or write access will raise an illegal-instruction exception outside M mode\nunless access is explicitly granted. See &lt;&lt;crypto_scalar_es_access&gt;&gt; for\nmore details.",
    "norm:seed_entropy_unique": "Each returned seed[15:0] = entropy value represents unique randomness\nwhen OPST=ES16 (seed[31:30] = 10), even if its numerical value is\nthe same as that of a previously polled entropy value.",
    "norm:seed_entropy_zero_non_es16": "When OPST is not ES16, entropy must be set to 0.",
    "norm:seed_wipe_on_read": "For security reasons, the interface guarantees that secret entropy\nwords are not made available multiple times. Hence polling (reading) must\nalso have the side effect of clearing (wipe-on-read) the entropy contents and\nchanging the state to WAIT (unless there is entropy\nimmediately available for ES16). Other states (BIST, WAIT, and DEAD)\nmay be unaffected by polling.",
    "norm:seed_bist_latch": "Such a BIST alarm must be latched until polled at least once to enable\nsoftware to record its occurrence.",
    "norm:seed_min_security_256": "Any implementation of the seed CSR that limits the security\nstrength shall not reduce it to less than 256 bits.",
    "norm:seed_disable_if_weak": "If the security\nlevel is under 256 bits, then the interface must not be available.",
    "norm:zkt_optional_instr": "Vendors do not have to implement all of the list's instructions to be Zkt\ncompliant;",
    "norm:zkt_impl_must_constant_latency": "if they claim to have Zkt and implement any of the listed instructions, it must have data-independent latency.",
    "norm:veccrypto_eeweqsew": "For all of the vector crypto instructions in this specification, EEW=SEW.",
    "norm:veccrypto_vl_vstart_egsconstr": "Since vl and vstart refer to elements, Vector Crypto instructions that use elements groups\n(See &lt;&lt;crypto-vector-element-groups&gt;&gt;) require that these values are an integer multiple of the\nElement Group Size (EGS).",
    "norm:veccrypto_vl_vstart_rsv": "Instructions that violate the vl or vstart requirements are reserved.",
    "norm:veccrypto_lmul_egwconstr": "For element-group instructions, LMUL*VLEN must always be at least as large as EGW, otherwise an\nillegal-instruction exception is raised, even if vl=0.",
    "norm:veccrypto_sew_rsv": "Some Vector Crypto instructions are only defined for a specific SEW. In such a case\nall other SEW values are reserved.",
    "norm:veccrypto_vsins_vs2": "In the case of the .vs instructions defined in this specification, vs2 holds a 128-bit scalar element group.",
    "norm:veccrypto_vsins_vdvs2overlap": "For implementations with VLEN ≥ 128, vs2 refers to a single register. Thus, the vd register group must not\noverlap the vs2 register.\nHowever, in implementations where VLEN &lt; 128, vs2 refers to a register group comprised of the number\nof registers needed to hold the 128-bit scalar element group. In this case, the vd register group must not\noverlap this vs2 register group.",
    "norm:veccrypto_vsins_vd": "they return vector results to vd, which is also a source vector operand.",
    "norm:veccrypto_vsins_vs2function": "These instructions enable a single key, specified as a scalar element group in vs2, to be\napplied to each element group of register group vd.",
    "norm:Zvknhb_Zvbc_Zvkn_Zvknc_Zvkng_depZve64x": "The &lt;&lt;zvknh,Zvknhb&gt;&gt; and &lt;&lt;zvbc&gt;&gt; Vector Crypto Extensions\n--and accordingly the composite extensions &lt;&lt;Zvkn&gt;&gt;, &lt;&lt;Zvknc&gt;&gt;, &lt;&lt;Zvkng&gt;&gt;, and &lt;&lt;Zvksc&gt;&gt;--\ndepend on Zve64x.",
    "norm:Zvbb_Zvkb_Zvkg_Zvkned_Zvknha_Zvksed_Zvksh_Zvks_Zvksc_Zvksg_Zvkt_depZve32x": "All of the other Vector Crypto Extensions depend on Zve32x.",
    "norm:veccrypto_indepZkt": "It is important to note that the Vector Crypto instructions are independent of the\nimplementation of the Zkt extension and do not require that Zkt is implemented.",
    "norm:Zvbc_sew64only": "These instructions are only defined for SEW=64.",
    "norm:Zvkg_egw128b_elem32b": "All of these instructions work on 128-bit element groups comprised of four 32-bit elements.",
    "norm:Zvkg_dataindeptiming": "To help avoid side-channel timing attacks, these instructions shall be implemented with data-independent timing.",
    "norm:Zvkg_vl": "The number of element groups to be processed is vl/EGS.\nvl must be set to the number of SEW=32 elements to be processed and\ntherefore must be a multiple of EGS=4.",
    "norm:Zvkg_vstart": "Likewise, vstart must be a multiple of EGS=4.",
    "norm:Zvkned_egw128b_elem32b": "All of these instructions work on 128-bit element groups comprised of four\n32-bit elements.",
    "norm:Zvkned_dataindeptiming": "To help avoid side-channel timing attacks, these instructions shall be implemented with data-independent timing.",
    "norm:Zvkned_vl": "The number of element groups to be processed is vl/EGS.\nvl must be set to the number of SEW=32 elements to be processed and\ntherefore must be a multiple of EGS=4.",
    "norm:Zvkned_vstart": "Likewise, vstart must be a multiple of EGS=4.",
    "norm:Zvknha_Zvknhb_sha256_egw128b_elem32b": "SHA-256: these instructions work on 128-bit element groups comprised of four 32-bit elements.",
    "norm:Zvknhb_sha512_egw256b_elem64b": "SHA-512: these instructions work on 256-bit element groups comprised of four 64-bit elements.",
    "norm:Zvknhb_sha256_sha512": "Zvknhb supports SHA-256 and SHA-512.",
    "norm:Zvknha_sha256": "Zvknha supports only SHA-256.",
    "norm:Zvknha_Zvknhb_dataindeptiming": "To help avoid side-channel timing attacks, these instructions shall be implemented with data-independent timing.",
    "norm:Zvknha_Zvknhb_vl": "The number of element groups to be processed is vl/EGS.\nvl must be set to the number of SEW elements to be processed and\ntherefore must be a multiple of EGS=4.",
    "norm:Zvknha_Zvknhb_vstart": "Likewise, vstart must be a multiple of EGS=4.",
    "norm:Zvksed_egw128b_elem32b": "All of these instructions work on 128-bit element groups comprised of four\n32-bit elements.",
    "norm:Zvksed_dataindeptiming": "To help avoid side-channel timing attacks, these instructions shall be implemented with data-independent timing.",
    "norm:Zvksed_vl": "The number of element groups to be processed is vl/EGS.\nvl must be set to the number of SEW=32 elements to be processed and\ntherefore must be a multiple of EGS=4.",
    "norm:Zvksed_vstart": "Likewise, vstart must be a multiple of EGS=4.",
    "norm:Zvksh_egw256b_elem32b": "All of these instructions work on 256-bit element groups comprised of\neight 32-bit elements.",
    "norm:Zvksh_dataindeptiming": "To help avoid side-channel timing attacks, these instructions shall be implemented with data-independent timing.",
    "norm:Zvksh_vl": "The number of element groups to be processed is vl/EGS.\nvl must be set to the number of SEW=32 elements to be processed and\ntherefore must be a multiple of EGS=8.",
    "norm:Zvksh_vstart": "Likewise, vstart must be a multiple of EGS=8.",
    "norm:vaesdf_final": "",
    "norm:vaesdf_ops": "The InvShiftRows and InvSubBytes steps are applied to each round state element group from vd.",
    "norm:vaesdf_xor_form": "This is then XORed with the round key in either the corresponding element group in vs2 (vector-vector\nform) or scalar element group in vs2 (vector-scalar form).",
    "norm:vaesdm_mid": "",
    "norm:vaesdm_ops": "The InvShiftRows and InvSubBytes steps are applied to each round state element group from vd.",
    "norm:vaesdm_xor_form": "This is then XORed with the round key in either the corresponding element group in vs2 (vector-vector\nform) or the scalar element group in vs2 (vector-scalar form).",
    "norm:vaesdm_invmix": "InvMixColumns step.",
    "norm:vaesef_final": "",
    "norm:vaesef_ops": "The SubBytes and ShiftRows steps are applied to each round state element group from vd.",
    "norm:vaesef_xor_form": "This is then XORed with the round key in either the corresponding element group in vs2 (vector-vector\nform) or the scalar element group in vs2 (vector-scalar form).",
    "norm:vaesem_mid": "",
    "norm:vaesem_ops": "The SubBytes, ShiftRows, and MixColumns steps are applied to each round state element group from vd.",
    "norm:vaesem_xor_form": "This is then XORed with the round key in either the corresponding  element group in vs2 (vector-vector\nform) or the scalar element group in vs2 (vector-scalar form).",
    "norm:vaeskf1_round": "A single round of the forward AES-128 KeySchedule is performed.",
    "norm:vaeskf1_wordgen": "The next round key is generated word by word from the\ncurrent round key element group in vs2 and the immediately previous word of the\nround key.",
    "norm:vaeskf1_uimm_src": "ranges from 1 to 10, comes from uimm[3:0];\nuimm[4] is ignored.",
    "norm:vaeskf1_uimm_map": "The out-of-range uimm[3:0] values of 0 and 11-15 are mapped to in-range\nvalues by inverting uimm[3].",
    "norm:vaeskf2_round": "A single round of the forward AES-256 KeySchedule is performed.",
    "norm:vaeskf2_wordgen": "The next round key is generated word by word from the\nprevious round key element group in vd and the immediately previous word of the\nround key.",
    "norm:vaeskf2_rcon_lsw": "least significant word of the next round key is generated by\napplying a function to the most significant word of the current round key and\nthen XORing the result with the round constant.",
    "norm:vaeskf2_rcon_func": "The round number is used to select the round constant as well as the function.",
    "norm:vaeskf2_uimm_src": "ranges from 2 to 14, comes from uimm[3:0];\nuimm[4] is ignored.",
    "norm:vaeskf2_uimm_map": "The out-of-range uimm[3:0] values of 0-1 and 15 are mapped to in-range\nvalues by inverting uimm[3].",
    "norm:vaesz_round0": "A round-0 AES block cipher operation is performed.",
    "norm:vaesz_vs_only": "There is only a .vs form of the instruction.",
    "norm:vaesz_vs2_rk": "Vs2 holds a\nscalar element group that is used\nas the round key for all of the round state element groups.",
    "norm:vandn_op": "Each bit of Op1 is inverted and logically ANDed with the corresponding bits in vs2.",
    "norm:vandn-vx_rs1": "In the vector-scalar version, Op1 is the sign-extended or truncated value in scalar\nregister rs1.",
    "norm:vandn-vv_vs1": "In the vector-vector version, Op1 is vs1.",
    "norm:vbrev-v_op": "A bit reversal is performed on the bits of each element.",
    "norm:vbrev8-v_op": "A bit reversal is performed on the bits of each byte.",
    "norm:vclmul_sewn64_rsv": "SEW is any value other than 64",
    "norm:vclmul_op": "Each 64-bit element in the vs2 vector register is carry-less multiplied by\neither each 64-bit element in vs1 (vector-vector), or the 64-bit value\nfrom integer register rs1 (vector-scalar). The result is the least\nsignificant 64 bits of the carry-less product.",
    "norm:vclmulh_sewn64_rsv": "SEW is any value other than 64",
    "norm:vclmulh_op": "Each 64-bit element in the vs2 vector register is carry-less multiplied by\neither each 64-bit element in vs1 (vector-vector), or the 64-bit value\nfrom integer register rs1 (vector-scalar). The result is the most\nsignificant 64 bits of the carry-less product.",
    "norm:vclz-v_op": "A leading zero count is performed on each element.",
    "norm:vclz-v_op_zeroinput": "The result for zero-valued inputs is the value SEW.",
    "norm:vcpop-v_op": "A population count is performed on each element.",
    "norm:vctz-v_op": "A trailing zero count is performed on each element.",
    "norm:vghsh-vv_sewn32_rsv": "SEW is any value other than 32",
    "norm:vghsh-vv_op": "This instruction treats all of the inputs and outputs as 128-bit polynomials and\nperforms operations over GF[2].\nIt produces the next partial hash (Y~i+1~) by adding the current partial\nhash (Y~i~) to the cipher text block (X~i~) and then multiplying (over GF(2^128^))\nthis sum by the Hash Subkey (H).",
    "norm:vghsh-vv_op_gf": "The multiplication over GF(2^128^) is a carry-less multiply of two 128-bit polynomials\nmodulo GHASH's irreducible polynomial (x^128^ + x^7^ + x^2^ + x + 1).",
    "norm:vghsh-vv_op_coeff": "The NIST specification (see &lt;&lt;zvkg&gt;&gt;) orders the coefficients from left to right x~0~x~1~x~2~...x~127~\nfor a polynomial x~0~ + x~1~u +x~2~ u^2^ + ... + x~127~u^127^. This can be viewed as a collection of\nbyte elements in memory with the byte containing the lowest coefficients (i.e., 0,1,2,3,4,5,6,7)\nresiding at the lowest memory address. Since the bits in the bytes are reversed,\nthis instruction internally performs bit swaps within bytes to put the bits in the standard ordering\n(e.g., 7,6,5,4,3,2,1,0).",
    "norm:vghsh-vv_exeindepdata": "This instruction must always be implemented such that its execution latency does not depend\non the data being operated upon.",
    "norm:vgmul-vv_sewn32_rsv": "SEW is any value other than 32",
    "norm:vgmul-vv_op": "This instruction treats all of the inputs and outputs as 128-bit polynomials and\nperforms operations over GF[2].\nIt produces the product over GF(2^128^) of the two 128-bit inputs.",
    "norm:vgmul-vv_op_gf": "The multiplication over GF(2^128^) is a carry-less multiply of two 128-bit polynomials\nmodulo GHASH's irreducible polynomial (x^128^ + x^7^ + x^2^ + x + 1).",
    "norm:vgmul-vv_op_coeff": "The NIST specification (see &lt;&lt;zvkg&gt;&gt;) orders the coefficients from left to right x~0~x~1~x~2~...x~127~\nfor a polynomial x~0~ + x~1~u +x~2~ u^2^ + ... + x~127~u^127^. This can be viewed as a collection of\nbyte elements in memory with the byte containing the lowest coefficients (i.e., 0,1,2,3,4,5,6,7)\nresiding at the lowest memory address. Since the bits in the bytes are reversed,\nThis instruction internally performs bit swaps within bytes to put the bits in the standard ordering\n(e.g., 7,6,5,4,3,2,1,0).",
    "norm:vgmul-vv_exeindepdata": "This instruction must always be implemented such that its execution latency does not depend\non the data being operated upon.",
    "norm:vrev8-v_op": "A byte reversal is performed on each element of vs2, effectively performing an endian swap.",
    "norm:vrol_op": "The elements in vs2 are rotated left by the rotate amount specified by either\nthe corresponding elements of vs1 (vector-vector), or integer register rs1\n(vector-scalar).\nOnly the low log2(SEW) bits of the rotate-amount value are used, all other\nbits are ignored.",
    "norm:vror_op": "The elements in vs2 are rotated right by the rotate amount specified by either\nthe corresponding elements of vs1 (vector-vector), integer register rs1\n(vector-scalar), or an immediate value (vector-immediate).\nOnly the low log2(SEW) bits of the rotate-amount value are used, all other\nbits are ignored.",
    "norm:vsha2chl-vv_Zvknha_sewn32_rsv": "zvknha: SEW is any value other than 32",
    "norm:vsha2chl-vv_Zvknhb_sewn32or64_rsv": "zvknhb: SEW is any value other than 32 or 64",
    "norm:vsha2chl-vv_vdoverlapvs1vs2_rsv": "The vd register group overlaps with either vs1 or vs2",
    "norm:vsha2chl-vv_op_sew32": "SEW=32: 2 rounds of SHA-256 compression are performed (zvknha and zvknhb)",
    "norm:vsha2chl-vv_op_sew64": "SEW=64: 2 rounds of SHA-512 compression are performed (zvknhb)",
    "norm:vsha2chl-vv_op": "Two words of vs1 are processed with\nthe 8 words of current state held in vd and vs2 to perform two\nrounds of hash computation producing four words of the\nnext state.",
    "norm:vsha2ms-vv_Zvknha_sewn32_rsv": "zvknha: SEW is any value other than 32",
    "norm:vsha2ms-vv_Zvknhb_sewn32or64_rsv": "zvknhb: SEW is any value other than 32 or 64",
    "norm:vsha2ms-vv_vdoverlapvs1vs2_rsv": "The vd register group overlaps with either vs1 or vs2",
    "norm:vsha2ms-vv_op_sew32": "SEW=32: Four rounds of SHA-256 message schedule expansion are performed (zvknha and zvknhb)",
    "norm:vsha2ms-vv_op_sew64": "SEW=64: Four rounds of SHA-512 message schedule expansion are performed (zvknhb)",
    "norm:vsha2ms-vv_op": "Eleven of the last 16 SEW-sized message-schedule words from vd (oldest), vs2,\nand vs1 (most recent) are processed to produce the\nnext 4 message-schedule words.",
    "norm:vsm3c-vi_sewn32_rsv": "SEW is any value other than 32",
    "norm:vsm3c-vi_vdoverlapvs2_rsv": "The vd register group overlaps with the vs2 register group",
    "norm:vsm3c-vi_op": "Two rounds of SM3 compression are performed.",
    "norm:vsm3c-vi_op_sm3": "The current state of eight 32-bit words is read in as an element group from vd. Eight 32-bit\nmessage words are read in as an element group from vs2, although only four of them are used.\nAll of the 32-bit input words are byte-swapped from big endian to little endian.\nThese inputs are processed somewhat differently based on the round group (as specified in rnds),\nand the next state is generated as an element group of eight 32-bit words.\nThe next state of eight 32-bit words are generated,\nswapped from little endian to big endian, and are returned in\nan eight-element group.",
    "norm:vsm3c-vi_op_rnd": "The round number is provided by the 5-bit rnds unsigned immediate. Legal values are 0 - 31\nand indicate which group of two rounds are being performed. For example, if rnds=1,\nthen rounds 2 and 3 are being performed.",
    "norm:vsm3me-vv_sewn32_rsv": "SEW is any value other than 32",
    "norm:vsm3me-vv_vdoverlapvs2_rsv": "The vd register group overlaps with the vs2 register group.",
    "norm:vsm3me-vv_op": "Eight rounds of SM3 message expansion are performed.",
    "norm:vsm3me-vv_op_sm3": "The sixteen most recent 32-bit message words are read in as two\neight-element groups from vs1 and vs2. Each of these words is\nswapped from big endian to little endian.\nThe next eight 32-bit message words are generated,\nswapped from little endian to big endian, and are returned in\nan eight-element group.",
    "norm:vsm4k-vi_sewn32_rsv": "SEW is any value other than 32",
    "norm:vsm4k-vi_op": "Four rounds of the SM4 Key Expansion are performed.",
    "norm:vsm4k-vi_op_sm4k": "Four round keys are read in as a 4-element group from vs2. Each of the next four round keys are generated\nby iteratively XORing the last three round keys with a constant that is indexed by the Round Group Number,\nperforming a byte-wise substitution, and then performing XORs between rotated versions of this value\nand the corresponding current round key.",
    "norm:vsm4k-vi_op_rnd": "The Round group number (rnd) comes from uimm[2:0]; the bits in uimm[4:3] are ignored.\nRound group numbers range from 0 to 7 and indicate which\ngroup of four round keys are being generated. Round Keys range from 0-31.\nFor example, if rnd=1, then round keys 4, 5, 6, and 7 are being generated.",
    "norm:vsm4r_sewn32_rsv": "SEW is any value other than 32",
    "norm:vsm4r-vs_vdoverlapvs2_rsv": "Only for the .vs form: the vd register group overlaps the vs2 register",
    "norm:vsm4r_op": "Four rounds of SM4 Encryption/Decryption are performed.",
    "norm:vsm4r_op_sm4encdec": "The four words of current state are read as a 4-element group from vd\nand the round keys are read from either the corresponding 4-element group\nin vs2 (vector-vector form) or the scalar element group in vs2\n(vector-scalar form).\nThe next four words of state are generated\nby iteratively XORing the last three words of the state with\nthe corresponding round key, performing\na byte-wise substitution, and then performing XORs between rotated\nversions of this value and the corresponding current state.",
    "norm:vwsll_op": "The elements in vs2 are zero-extended to 2*SEW bits, then shifted left\nby the shift amount specified by either\nthe corresponding elements of vs1 (vector-vector), integer register rs1\n(vector-scalar), or an immediate value (vector-immediate).\nOnly the low log2(2*SEW) bits of the shift-amount value are used, all other\nbits are ignored.",
    "norm:cfi_call_term": "The term call is used to refer to a JAL or JALR instruction with a link register as destination, i.e., rd≠x0. Conventionally, the link register is x1 or x5. A call using JAL or C.JAL is termed a direct call. A C.JALR expands to JALR x1, 0(rs1) and is a call. A call using JALR or C.JALR is termed an indirect-call.",
    "norm:cfi_return_term": "The term return is used to refer to a JALR instruction with rd=x0 and with rs1=x1 or rs1=x5. A C.JR instruction expands to JALR x0, 0(rs1) and is a return if rs1=x1 or rs1=x5.",
    "norm:cfi_indirect-jump_term": "The term indirect-jump is used to refer to a JALR instruction with rd=x0 and where the rs1 is not x1 or x5 (i.e., not a return). A C.JR instruction where rs1 is not x1 or x5 (i.e., not a return) is an indirect-jump.",
    "norm:zicflip_lpad_enc": "The LPAD\ninstruction (See &lt;&lt;LP_INST&gt;&gt;) is encoded using the AUIPC major opcode with\nrd=x0.",
    "norm:zicflip_lpad_expected": "The Zicfilp extension, when enabled, determines if an indirect call or an indirect jump must land on a landing pad, as specified in . If is_lp_expected is 1, then the hart updates the ELP to LP_EXPECTED.",
    "norm:zicflip_indirect_branch_lpad": "An indirect branch using JALR, C.JALR, or C.JR with rs1 as x7 is termed a software guarded branch. Such branches do not need to land on a LPAD instruction and thus do not set ELP to LP_EXPECTED.",
    "norm:zicflip_lpad_label": "To support labeled landing pads, the\nindirect call/jump sites establish an expected landing pad label (e.g., using\nthe LUI instruction) in the bits 31:12 of the x7 register.",
    "norm:zicflip_lpad_imm_enc": "The LPAD\ninstruction is encoded with a 20-bit immediate value called the landing-pad-label\n(LPL) that is matched to the expected landing pad label. When LPL is encoded\nas zero, the LPAD instruction does not perform the label check and in programs\nbuilt with this single label mode of operation the indirect call/jump sites do\nnot need to establish an expected landing pad label value in x7.",
    "norm:zicflip_elp_lpad_expected": "When ELP is set to LP_EXPECTED, if the next instruction in the instruction stream is not 4-byte aligned, or is not LPAD, or if the landing pad label encoded in LPAD is not zero and does not match the expected landing pad label in bits 31:12 of the x7 register, then a software-check exception (cause=18) with xtval set to \"landing pad fault (code=2)\" is raised else the ELP is updated to NO_LP_EXPECTED.",
    "norm:zicflip_lpad_enabled_instr_allowed": "When Zicfilp is enabled, LPAD is the only instruction allowed to execute when\nthe ELP state is LP_EXPECTED. If Zicfilp is not enabled then the instruction\nis a no-op.",
    "norm:zicflip_lpad_enabled_exception": "If Zicfilp is enabled, the LPAD instruction causes a\nsoftware-check exception with xtval set to \"landing pad fault (code=2)\"",
    "norm:zicflip_lpad_alignment_exception": "The pc is not 4-byte aligned and ELP is LP_EXPECTED.",
    "norm:zicflip_lpad_label_exception": "The ELP is LP_EXPECTED and the LPL is not zero and the LPL does not match the expected landing pad label in bits 31:12 of the x7 register.",
    "norm:zicflip_lpad_no_sw_exception": "If a software-check exception is not caused then the ELP is updated to NO_LP_EXPECTED.",
    "norm:zicfiss_link_reg_func_enter": "When Zicfiss is enabled, each function that needs to spill the link register,\ntypically non-leaf functions, store the link register value to the regular stack\nand a shadow copy of the link register value to the shadow stack when the\nfunction is entered (the prologue).",
    "norm:zicfiss_link_reg_func_return": "When such a function returns (the\nepilogue), the function loads the link register from the regular stack and\nthe shadow copy of the link register from the shadow stack.",
    "norm:zicfiss_stack_compare": "Then, the link\nregister value from the regular stack and the shadow link register value from\nthe shadow stack are compared. A mismatch of the two values is indicative of a\nsubversion of the return address control variable and causes a software-check\nexception.",
    "norm:zicfiss_enc": "The Zicfiss instructions, except SSAMOSWAP.W/D, are encoded using a subset of\nMay-Be-Operation instructions defined by the Zimop and Zcmop extensions.",
    "norm:zicfiss_sspush_enc": "SSPUSH x1 and SSPUSH x5 - encoded using MOP.RR.7",
    "norm:zicfiss_c-sspush_enc": "C.SSPUSH x1 - encoded using C.MOP.1",
    "norm:zicfiss_sspopchk_enc": "SSPOPCHK x1 and SSPOPCHK x5 - encoded using MOP.R.28",
    "norm:zicfiss_c-sspopchk_enc": "C.SSPOPCHK x5 - encoded using C.MOP.5",
    "norm:zicfiss_ssrdp_enc": "SSRDP - encoded using MOP.R.28",
    "norm:zicfiss_atomic_swap": "Perform an atomic swap from a shadow stack location (See &lt;&lt;SSAMOSWAP&gt;&gt;)",
    "norm:ssp_op": "The ssp CSR is an unprivileged read-write (URW) CSR that reads and writes\nXLEN low order bits of the shadow stack pointer (ssp).",
    "norm:ssp_addr": "The CSR address is\n0x011.",
    "norm:ssp_sz": "There is no high CSR defined as the ssp is always as wide as the XLEN\nof the current privilege mode.",
    "norm:ssp-field_1_0": "The bits 1:0 of ssp are read-only zero. If the\nUXLEN or SXLEN may never be 32, then the bit 2 is also read-only zero.",
    "norm:ss_push": "A shadow stack push operation is defined as decrement of the ssp by XLEN/8 followed by a store of the value in the link register to memory at the new top of the shadow stack.",
    "norm:sspush_c-sspush_instr": "The SSPUSH instruction and its compressed form C.SSPUSH can be used to push a link register on the shadow stack. The SSPUSH and C.SSPUSH instructions perform a store identically to the existing store instructions, with the difference that the base is implicitly ssp and the width is implicitly XLEN.",
    "norm:sspush_c-sspush_decrement": "The ssp is decremented by SSPUSH and C.SSPUSH only if the store to the shadow stack completes successfully.",
    "norm:ss_pop": "A shadow stack pop operation is defined as an XLEN wide read from the current top of the shadow stack followed by an increment of the ssp by XLEN/8.",
    "norm:sspopchk_shadow_return_pop": "The SSPOPCHK instruction, and its compressed form C.SSPOPCHK, can be used to pop the shadow return address value from the shadow stack and check that the value matches the contents of the link register, and if not cause a software-check exception with xtval set to \"shadow stack fault (code=3)\".",
    "norm:sspopchk-c_load_op": "The C.SSPOPCHK, and SSPOPCHK instructions perform a load identically to the existing load instructions, with the difference that the base is implicitly ssp and the width is implicitly XLEN.",
    "norm:sspop_exception": "If the value loaded from the address in ssp does not match the value in rs1, a software-check exception (cause=18) is raised with xtval set to \"shadow stack fault (code=3)\". The software-check exception caused by SSPOPCHK/ C.SSPOPCHK is lower in priority than a load/store/AMO access-fault exception.",
    "norm:sspop_increment": "The ssp is incremented by SSPOPCHK and C.SSPOPCHK only if the load from the shadow stack completes successfully and no software-check exception is raised.",
    "norm:ssrdp_read": "The SSRDP instruction is provided to move the contents of ssp to a destination register.",
    "norm:rv32_ssamoswap-w_op": "For RV32, SSAMOSWAP.W atomically loads a 32-bit data value from address of a shadow stack location in rs1, puts the loaded value into register rd, and stores the 32-bit value held in rs2 to the original address in rs1. SSAMOSWAP.D (RV64 only) is similar to SSAMOSWAP.W but operates on 64-bit data values.",
    "norm:rv64_ssamoswap-w_op": "For RV64, SSAMOSWAP.W atomically loads a 32-bit data value from address of a shadow stack location in rs1, sign-extends the loaded value and puts it in rd, and stores the lower 32 bits of the value held in rs2 to the original address in rs1.",
    "norm:ssamoswap_address": "Just as for AMOs in the A extension, SSAMOSWAP.W/D requires that the address held in rs1 be naturally aligned to the size of the operand (i.e., eight-byte aligned for doublewords, and four-byte aligned for words). The same exception options apply if the address is not naturally aligned.",
    "norm:Zilsd_reg_pairs": "Operands containing src for store instructions and dest for load instructions are held in aligned x-register pairs, i.e., register numbers must be even.",
    "norm:Zilsd_bits_to_pair": "Regardless of endianness, the lower-numbered register holds the\nlow-order bits, and the higher-numbered register holds the high-order bits",
    "norm:Zilsd_align8_no_exc": "As the access size is 64-bit, accesses are only considered naturally aligned for effective addresses that are a multiple of 8.\nIn this case, these instructions are guaranteed to not raise an address-misaligned exception.",
    "norm:Zilsd_align8_atomic": "Even if naturally aligned, the memory access might not be performed atomically.",
    "norm:Zilsd_align4_atomic": "If the effective address is a multiple of 4, then each word access is required to be performed atomically.",
    "norm:Zilsd_ld_resume_trap": "To ensure resumable trap handling is possible for the load instructions, the base register must\nhave its original value if a trap is taken.",
    "norm:Zilsd_ld_x0": "LD instructions with destination x0 are processed as any other load,\nbut the result is discarded entirely and x1 is not written.",
    "norm:Zilsd_c-ldsp_x0": "For C.LDSP, usage of x0 as the destination is reserved.",
    "norm:Zilsd_sd_x0": "If using x0 as src of SD or C.SDSP, the entire 64-bit operand is zero — i.e., register x1 is not accessed.",
    "norm:Zilsd_RVWMO_exc_misaligned": "For the purposes of RVWMO and exception handling, LD and SD instructions are\nconsidered to be misaligned loads and stores",
    "norm:Zilsd_align4_two_4byte": "an LD or SD instruction whose effective address is a multiple of 4 gives rise\nto two 4-byte memory operations.",
    "norm:Zilsd_ld_op": "Loads a 64-bit value into registers rd and rd+1. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.",
    "norm:Zilsd_sd_op": "Stores a 64-bit value from registers rs2 and rs2+1. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.",
    "norm:Zilsd_c-ldsp_op": "Loads stack-pointer relative 64-bit value into registers rd' and rd'+1. It computes its effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2. It expands to ld rd, offset(x2). C.LDSP is only valid when rd≠x0; the code points with rd=x0 are reserved.",
    "norm:Zilsd_c-sdsp_op": "Stores a stack-pointer relative 64-bit value from registers rs2' and rs2'+1. It computes an effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2. It expands to sd rs2, offset(x2).",
    "norm:Zilsd_c-ld_op": "Loads a 64-bit value into registers rd' and rd'+1. It computes an effective address by adding the zero-extended offset, scaled by 8, to the base address in register rs1'.",
    "norm:Zilsd_c-sd_op": "Stores a 64-bit value from registers rs2' and rs2'+1. It computes an effective address by adding the zero-extended offset, scaled by 8, to the base address in register rs1'. It expands to sd rs2', offset(rs1').",
    "norm:lui_enc": "LUI",
    "norm:auipc_enc": "AUIPC",
    "norm:jal_enc": "JAL",
    "norm:jalr_enc": "JALR",
    "norm:beq_enc": "BEQ",
    "norm:bne_enc": "BNE",
    "norm:blt_enc": "BLT",
    "norm:bge_enc": "BGE",
    "norm:bltu_enc": "BLTU",
    "norm:bgeu_enc": "BGEU",
    "norm:lb_enc": "LB",
    "norm:lh_enc": "LH",
    "norm:lw_enc": "LW",
    "norm:lbu_enc": "LBU",
    "norm:lhu_enc": "LHU",
    "norm:sb_enc": "SB",
    "norm:sh_enc": "SH",
    "norm:sw_enc": "SW",
    "norm:addi_enc": "ADDI",
    "norm:slti_enc": "SLTI",
    "norm:sltiu_enc": "SLTIU",
    "norm:xori_enc": "XORI",
    "norm:ori_enc": "ORI",
    "norm:andi_enc": "ANDI",
    "norm:slli_enc": "SLLI",
    "norm:srli_enc": "SRLI",
    "norm:srai_enc": "SRAI",
    "norm:add_enc": "ADD",
    "norm:sub_enc": "SUB",
    "norm:sll_enc": "SLL",
    "norm:slt_enc": "SLT",
    "norm:sltu_enc": "SLTU",
    "norm:xor_enc": "XOR",
    "norm:srl_enc": "SRL",
    "norm:sra_enc": "SRA",
    "norm:or_enc": "OR",
    "norm:and_enc": "AND",
    "norm:fence_enc": "FENCE",
    "norm:fence-tso_enc": "FENCE.TSO",
    "norm:pause_enc": "PAUSE",
    "norm:ecall_enc": "ECALL",
    "norm:ebreak_enc": "EBREAK",
    "norm:lwu_enc": "LWU",
    "norm:ld_enc": "LD",
    "norm:sd_enc": "SD",
    "norm:addiw_enc": "ADDIW",
    "norm:slliw_enc": "SLLIW",
    "norm:srliw_enc": "SRLIW",
    "norm:sraiw_enc": "SRAIW",
    "norm:addw_enc": "ADDW",
    "norm:subw_enc": "SUBW",
    "norm:sllw_enc": "SLLW",
    "norm:srlw_enc": "SRLW",
    "norm:sraw_enc": "SRAW",
    "norm:mul_enc": "MUL",
    "norm:mulh_enc": "MULH",
    "norm:mulhsu_enc": "MULHSU",
    "norm:mulhu_enc": "MULHU",
    "norm:div_enc": "DIV",
    "norm:divu_enc": "DIVU",
    "norm:rem_enc": "REM",
    "norm:remu_enc": "REMU",
    "norm:mulw_enc": "MULW",
    "norm:divw_enc": "DIVW",
    "norm:divuw_enc": "DIVUW",
    "norm:remw_enc": "REMW",
    "norm:remuw_enc": "REMUW"
  },
  "sections": {
    "title": "",
    "id": "",
    "children": [
      {
        "title": "Preface",
        "id": "_preface",
        "children": [],
        "tags": []
      },
      {
        "title": "Introduction",
        "id": "_introduction",
        "children": [
          {
            "title": "RISC-V Hardware Platform Terminology",
            "id": "_risc_v_hardware_platform_terminology",
            "children": [],
            "tags": []
          },
          {
            "title": "RISC-V Software Execution Environments and Harts",
            "id": "_risc_v_software_execution_environments_and_harts",
            "children": [],
            "tags": [
              "norm:execution_environment_implementation_flexibility"
            ]
          },
          {
            "title": "RISC-V ISA Overview",
            "id": "_risc_v_isa_overview",
            "children": [],
            "tags": [
              "norm:base_integer_variants",
              "norm:xlen_definition",
              "norm:twos_complement_signed_integers"
            ]
          },
          {
            "title": "Memory",
            "id": "_memory",
            "children": [],
            "tags": []
          },
          {
            "title": "Base Instruction-Length Encoding",
            "id": "_base_instruction_length_encoding",
            "children": [],
            "tags": []
          },
          {
            "title": "Exceptions, Traps, and Interrupts",
            "id": "trap-defn",
            "children": [],
            "tags": []
          },
          {
            "title": "UNSPECIFIED Behaviors and Values",
            "id": "_unspecified_behaviors_and_values",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "RV32I Base Integer Instruction Set, Version 2.1",
        "id": "rv32",
        "children": [
          {
            "title": "Programmers' Model for Base Integer ISA",
            "id": "_programmers_model_for_base_integer_isa",
            "children": [],
            "tags": [
              "norm:rv32i_xreg_sz",
              "norm:x0eq0",
              "norm:rv32i_rv64i_other_xregs",
              "norm:pcreg_op"
            ]
          },
          {
            "title": "Base Instruction Formats",
            "id": "_base_instruction_formats",
            "children": [],
            "tags": [
              "norm:taken_cti_misaligned_exc",
              "norm:cond_br_no_ia_misaligned_exc_not_taken",
              "norm:imm_always_sex"
            ]
          },
          {
            "title": "Immediate Encoding Variants",
            "id": "_immediate_encoding_variants",
            "children": [],
            "tags": []
          },
          {
            "title": "Integer Computational Instructions",
            "id": "_integer_computational_instructions",
            "children": [
              {
                "title": "Integer Register-Immediate Instructions",
                "id": "_integer_register_immediate_instructions",
                "children": [],
                "tags": [
                  "norm:addi_op",
                  "norm:addi_overflow",
                  "norm:slti_sltiu_op",
                  "norm:andi_ori_xori_op",
                  "norm:slli_op",
                  "norm:srli_op",
                  "norm:srai_op",
                  "norm:lui_op",
                  "norm:auipc_op"
                ]
              },
              {
                "title": "Integer Register-Register Instructions",
                "id": "_integer_register_register_instructions",
                "children": [],
                "tags": [
                  "norm:R-type_operands",
                  "norm:add_op",
                  "norm:sub_op",
                  "norm:add_sub_overflow",
                  "norm:slt_sltu_op",
                  "norm:and_or_xor_op",
                  "norm:sll_srl_sra_op"
                ]
              },
              {
                "title": "NOP Instruction",
                "id": "_nop_instruction",
                "children": [],
                "tags": [
                  "norm:nop_op",
                  "norm:nop_enc"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Control Transfer Instructions",
            "id": "_control_transfer_instructions",
            "children": [
              {
                "title": "Unconditional Jumps",
                "id": "_unconditional_jumps",
                "children": [],
                "tags": [
                  "norm:jal_target",
                  "norm:jal_op",
                  "norm:jalr_target",
                  "norm:jalr_op",
                  "norm:jump_misaligned_exception",
                  "norm:jump_misaligned_c_no_exception"
                ]
              },
              {
                "title": "Conditional Branches",
                "id": "_conditional_branches",
                "children": [],
                "tags": [
                  "norm:br_target",
                  "norm:beq_bne_op",
                  "norm:blt_bltu_op",
                  "norm:bge_bgeu_op",
                  "norm:branch_misaligned_taken_exception",
                  "norm:branch_misaligned_untaken_exception",
                  "norm:branch_misaligned_c_no_exception"
                ]
              }
            ],
            "tags": [
              "norm:no_cti_delay_slots",
              "norm:ia_fault_exc_on_target"
            ]
          },
          {
            "title": "Load and Store Instructions",
            "id": "ldst",
            "children": [],
            "tags": [
              "norm:load_exc_x0",
              "norm:ENDIANNESS_LITTLE_OR_BIG",
              "norm:ldst_endian_byte_invariant",
              "norm:ldst_endian_byte_op",
              "norm:ldst_little_endian_op",
              "norm:ldst_big_endian_op",
              "norm:ldst_ea",
              "norm:load_op",
              "norm:store_op",
              "norm:lw_op",
              "norm:lh_op",
              "norm:lhu_op",
              "norm:lb_lbu_op",
              "norm:sw_sh_sb_op",
              "norm:ldst_no_exc_aligned",
              "norm:misaligned_ldst_eei_dependent_behavior",
              "norm:misaligned_ldst_fully_hw_supported",
              "norm:misaligned_ldst_invisible_trap",
              "norm:misaligned_ldst_hw_or_invisible_trap_func_of_addr",
              "norm:misaligned_ldst_fully_hw_supported_or_visible_trap",
              "norm:ldst_addr_misaligned_or_access_fault_exc",
              "norm:misaligned_ldst_contained_or_fatal_trap",
              "norm:ldst_atomicity_for_aligned"
            ]
          },
          {
            "title": "Memory Ordering Instructions",
            "id": "fence",
            "children": [],
            "tags": [
              "norm:fence_op",
              "norm:fence-tso_op",
              "norm:fence-tso_ordering_rw_rw_ok",
              "norm:fence_unused_flds_rsv",
              "norm:fence_cons_ok"
            ]
          },
          {
            "title": "Environment Call and Breakpoints",
            "id": "ecall-ebreak",
            "children": [],
            "tags": [
              "norm:ecall_op1",
              "norm:ebreak_op1"
            ]
          },
          {
            "title": "HINT Instructions",
            "id": "_hint_instructions",
            "children": [],
            "tags": [
              "norm:hints_op",
              "norm:hints_enc"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "RV32E and RV64E Base Integer Instruction Sets, Version 2.0",
        "id": "rv32e",
        "children": [
          {
            "title": "RV32E and RV64E Programmers’ Model",
            "id": "_rv32e_and_rv64e_programmers_model",
            "children": [],
            "tags": []
          },
          {
            "title": "RV32E and RV64E Instruction Set Encoding",
            "id": "_rv32e_and_rv64e_instruction_set_encoding",
            "children": [],
            "tags": [
              "norm:diff-rv32e-rv32i"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "RV64I Base Integer Instruction Set, Version 2.1",
        "id": "rv64",
        "children": [
          {
            "title": "Register State",
            "id": "_register_state",
            "children": [],
            "tags": [
              "norm:rv64i_xreg_sz"
            ]
          },
          {
            "title": "Integer Computational Instructions",
            "id": "_integer_computational_instructions_2",
            "children": [
              {
                "title": "Integer Register-Immediate Instructions",
                "id": "_integer_register_immediate_instructions_2",
                "children": [],
                "tags": [
                  "norm:addiw_op",
                  "norm:addiw_overflow",
                  "norm:slliw_srliw_sraiw_op",
                  "norm:slliw_srliw_sraiw_imm5_rsv",
                  "norm:lui_op_rv64i",
                  "norm:auipc_op_rv64i"
                ]
              },
              {
                "title": "Integer Register-Register Operations",
                "id": "_integer_register_register_operations",
                "children": [],
                "tags": [
                  "norm:addw_subw_op",
                  "norm:addw_subw_overflow",
                  "norm:sll_srl_sra_sh_amt_rv64i",
                  "norm:sllw_srlw_sraw_op"
                ]
              }
            ],
            "tags": [
              "norm:rv64_w_sex"
            ]
          },
          {
            "title": "Load and Store Instructions",
            "id": "_load_and_store_instructions",
            "children": [],
            "tags": [
              "norm:ld_op_rv64i",
              "norm:lw_op_rv64i",
              "norm:lwu_op",
              "norm:lh_lhu_lb_lbu_op_rv64i",
              "norm:sd_sw_sh_sb_op_rv64i"
            ]
          },
          {
            "title": "HINT Instructions",
            "id": "rv64i-hints",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Zifencei\" Extension for Instruction-Fetch Fence, Version 2.0",
        "id": "zifencei",
        "children": [],
        "tags": [
          "norm:fence_i_op",
          "norm:fence_i_rsv"
        ]
      },
      {
        "title": "\"Zicsr\" Extension for Control and Status Register (CSR) Instructions, Version 2.0",
        "id": "csrinsts",
        "children": [
          {
            "title": "CSR Instructions",
            "id": "_csr_instructions",
            "children": [
              {
                "title": "CSR Access Ordering",
                "id": "_csr_access_ordering",
                "children": [],
                "tags": [
                  "norm:csr_access_order",
                  "norm:csrr_order",
                  "norm:csrw_order",
                  "norm:csr_side_effects_synchronous",
                  "norm:csr_weakly_ordered",
                  "norm:csr_memory_access_ordering",
                  "norm:csr_fence_ordering",
                  "norm:csr_strongly_ordered"
                ]
              }
            ],
            "tags": [
              "norm:csrrw_op",
              "norm:csrrs_op",
              "norm:csrrc_op",
              "norm:csrrs_csrrc_rs1_x0",
              "norm:csrrw_rs1_x0",
              "norm:csrrsi_csrrci_uimm_zero",
              "norm:csrrwi_rd_x0",
              "norm:csrrwi_csrrsi_csrrci_ops",
              "norm:csr_side_effects",
              "norm:csr_rs1_uimm_side_effect"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Zicntr\" and \"Zihpm\" Extensions for Counters, Version 2.0",
        "id": "counters",
        "children": [
          {
            "title": "\"Zicntr\" Extension for Base Counters and Timers",
            "id": "_zicntr_extension_for_base_counters_and_timers",
            "children": [],
            "tags": [
              "norm:zicntr_rdcycle_op",
              "norm:zicntr_rdcycleh_op",
              "norm:zicntr_rdtime_op",
              "norm:zicntr_rdtimeh_op",
              "norm:zicntr_time_hart_sync",
              "norm:zicntr_rdinstret_op",
              "norm:zicntr_rdinstreth_op"
            ]
          },
          {
            "title": "\"Zihpm\" Extension for Hardware Performance Counters",
            "id": "_zihpm_extension_for_hardware_performance_counters",
            "children": [],
            "tags": [
              "norm:hpmcounter_op_sz_mode",
              "norm:hpm_counter_op_sz_mode_xlen32",
              "norm:hpm_counter_op_sz_mode_dependency",
              "norm:hpm_platform_specific_impl",
              "norm:hpm_unimplemented_counter_access",
              "norm:hpm_misconfigured_event_behavior"
            ]
          }
        ],
        "tags": [
          "norm:zihpm_op_sz_mode_acc_count",
          "norm:zihpm_op_sz_mode_acc_priv",
          "norm:zihpm_op_sz_mode_acc_xlen32",
          "norm:zihpm_op_sz_mode_acc_partition"
        ]
      },
      {
        "title": "\"Zihintntl\" Extension for Non-Temporal Locality Hints, Version 1.0",
        "id": "chap:zihintntl",
        "children": [],
        "tags": [
          "norm:NTL-target_definition",
          "norm:NTL-P1_op",
          "norm:NTL-P1_enc",
          "norm:NTL-PALL_op",
          "norm:NTL-PALL_enc",
          "norm:NTL-S1_op",
          "norm:NTL-S1_enc",
          "norm:NTL-ALL_op",
          "norm:NTL-ALL_enc",
          "norm:NTL-compressed_variants",
          "norm:NTL_range",
          "norm:NTL_Zicob_prefetch_outer",
          "norm:NTL_trap_behavior",
          "norm:NTL-LR_SC_exception"
        ]
      },
      {
        "title": "\"Zihintpause\" Extension for Pause Hint, Version 2.0",
        "id": "zihintpause",
        "children": [],
        "tags": [
          "norm:pause_op",
          "norm:pause_enc_fence"
        ]
      },
      {
        "title": "\"Zimop\" Extension for May-Be-Operations, Version 1.0",
        "id": "zimop",
        "children": [
          {
            "title": "\"Zcmop\" Compressed May-Be-Operations Extension, Version 1.0",
            "id": "_zcmop_compressed_may_be_operations_extension_version_1_0",
            "children": [],
            "tags": [
              "norm:Zcmop_op",
              "norm:Zcmop_enc",
              "norm:Zcmop_instr_write",
              "norm:c-mop_enc"
            ]
          }
        ],
        "tags": [
          "norm:Zimop_mop-r_op",
          "norm:Zimop_mop-r_enc",
          "norm:Zimop_mop-rr_op",
          "norm:Zimop_mop-rr_enc"
        ]
      },
      {
        "title": "\"Zicond\" Extension for Integer Conditional Operations, Version 1.0.0",
        "id": "Zicond",
        "children": [
          {
            "title": "Instructions (in alphabetical order)",
            "id": "_instructions_in_alphabetical_order",
            "children": [
              {
                "title": "czero.eqz",
                "id": "insns-czero-eqz",
                "children": [],
                "tags": [
                  "norm:czero-eqz_op",
                  "norm:czero-eqz_inst_ctime"
                ]
              },
              {
                "title": "czero.nez",
                "id": "insns-czero-nez",
                "children": [],
                "tags": [
                  "norm:czero-nez_op",
                  "norm:czero-nez_zkt_timing"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Usage examples",
            "id": "_usage_examples",
            "children": [
              {
                "title": "Instruction sequences",
                "id": "_instruction_sequences",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"M\" Extension for Integer Multiplication and Division, Version 2.0",
        "id": "mstandard",
        "children": [
          {
            "title": "Multiplication Operations",
            "id": "_multiplication_operations",
            "children": [],
            "tags": [
              "norm:mul_op",
              "norm:mulh_mulhu_mulhsu_op",
              "norm:mulw_op"
            ]
          },
          {
            "title": "Division Operations",
            "id": "_division_operations",
            "children": [],
            "tags": [
              "norm:div_divu_op",
              "norm:rem_remu_op",
              "norm:rem_result_sign",
              "norm:divw_divuw_op",
              "norm:remw_remuw_op",
              "norm:remw_remuw_result_sign",
              "norm:div_by_zero",
              "norm:rem_by_zero",
              "norm:signed_div_overflow"
            ]
          },
          {
            "title": "Zmmul Extension, Version 1.0",
            "id": "_zmmul_extension_version_1_0",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"A\" Extension for Atomic Instructions, Version 2.1",
        "id": "_a_extension_for_atomic_instructions_version_2_1",
        "children": [
          {
            "title": "Specifying Ordering of Atomic Instructions",
            "id": "_specifying_ordering_of_atomic_instructions",
            "children": [],
            "tags": [
              "norm:a_aq_rl_bits",
              "norm:a_domain_specific_ordering",
              "norm:a_no_aq_rl",
              "norm:a_acquire_semantics",
              "norm:a_release_semantics",
              "norm:a_seq_cst_semantics"
            ]
          },
          {
            "title": "\"Zalrsc\" Extension for Load-Reserved/Store-Conditional Instructions",
            "id": "sec:lrsc",
            "children": [],
            "tags": [
              "norm:lr_w_op",
              "norm:sc_w_success",
              "norm:sc_w_failure",
              "norm:sc_retire_permission",
              "norm:sc_failed_side_effects",
              "norm:sc_failed_as_store",
              "norm:sc_reservation_invalidate",
              "norm:lr_sc_rv64",
              "norm:sc_failure_code",
              "norm:lr_sc_alignment",
              "norm:lr_reservation_set_size",
              "norm:sc_pairs_latest_lr",
              "norm:sc_success_conditions",
              "norm:sc_device_write_failure",
              "norm:sc_addr_not_in_reservation_fail",
              "norm:sc_other_hart_store_fail",
              "norm:sc_other_device_write_fail",
              "norm:sc_intervening_sc_fail",
              "norm:lr_sc_atomicity_axiom",
              "norm:sc_not_observable_before_lr",
              "norm:lr_sc_aq_rl_software_rule"
            ]
          },
          {
            "title": "Eventual Success of Store-Conditional Instructions",
            "id": "sec:lrscseq",
            "children": [],
            "tags": [
              "norm:constrained_lrsc_loop_size",
              "norm:constrained_lrsc_instruction_set",
              "norm:constrained_lrsc_compressed_allowed",
              "norm:constrained_lrsc_retry_code",
              "norm:lrsc_eventuality_region",
              "norm:lrsc_same_address_and_size",
              "norm:unconstrained_lrsc_no_progress"
            ]
          },
          {
            "title": "\"Zaamo\" Extension for Atomic Memory Operations",
            "id": "sec:amo",
            "children": [],
            "tags": [
              "norm:amo_operand_size",
              "norm:amo_alignment",
              "norm:amo_misaligned_atomicity_granule",
              "norm:amo_release_consistency"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Zawrs\" Extension for Wait-on-Reservation-Set instructions, Version 1.01",
        "id": "_zawrs_extension_for_wait_on_reservation_set_instructions_version_1_01",
        "children": [
          {
            "title": "Wait-on-Reservation-Set Instructions",
            "id": "Zawrs",
            "children": [],
            "tags": [
              "norm:Zawrs_stall_terminate",
              "norm:Zawrs_exec_resume_rules",
              "norm:Zawrs_priv_illegal_instr_excp",
              "norm:Zawrs_virtual_instr_excp"
            ]
          }
        ],
        "tags": [
          "norm:Zawrs_wrs-nto_stall_exec",
          "norm:Zawrs_wrs-sto_stall_duration"
        ]
      },
      {
        "title": "\"Zacas\" Extension for Atomic Compare-and-Swap (CAS) Instructions, Version 1.0.0",
        "id": "_zacas_extension_for_atomic_compare_and_swap_cas_instructions_version_1_0_0",
        "children": [
          {
            "title": "Word/Doubleword/Quadword CAS (AMOCAS.W/D/Q) Instructions",
            "id": "_worddoublewordquadword_cas_amocas_wdq_instructions",
            "children": [],
            "tags": [
              "norm:Zacas_rv32_amocas-w_op",
              "norm:Zacas_rv32_amocas-d_op",
              "norm:Zacas_rv32_amocas-d_frst_pair_entry_reg_even",
              "norm:Zacas_rv32_amocas-d_rs2_frst_reg_x0",
              "norm:Zacas_rv32_amocas-d_rd_frst_reg_x0",
              "norm:Zacas_rv64_amocas-w_op",
              "norm:Zacas_rv64_amocas-d_op",
              "norm:Zacas_rv64_amocas-q_op",
              "norm:Zacas_rv64_amocas-q_frst_pair_entry_reg_even",
              "norm:Zacas_rv64_amocas-q_rs2_frst_reg_x0",
              "norm:Zacas_rv64_amocas-q_rd_frst_reg_x0",
              "norm:Zacas_amocas_rs1_addr_alignment",
              "norm:Zacas_amocas_mem_op_success_aq_rl",
              "norm:Zacas_amocas_mem_op_fail_aq_rl",
              "norm:Zacas_amocas_w_permission"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Zabha\" Extension for Byte and Halfword Atomic Memory Operations, Version 1.0",
        "id": "_zabha_extension_for_byte_and_halfword_atomic_memory_operations_version_1_0",
        "children": [
          {
            "title": "Byte and Halfword Atomic Memory Operation Instructions",
            "id": "_byte_and_halfword_atomic_memory_operation_instructions",
            "children": [],
            "tags": [
              "norm:Zabha_rd_sign_extension",
              "norm:Zabha_amocas-BH_ignore_bits",
              "norm:Zabha_rs1_align_addr"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Zalasr\" Atomic Load-Acquire and Store-Release Instructions, Version 1.0",
        "id": "_zalasr_atomic_load_acquire_and_store_release_instructions_version_1_0",
        "children": [
          {
            "title": "Load-Acquire and Store-Release Instructions",
            "id": "_load_acquire_and_store_release_instructions",
            "children": [],
            "tags": [
              "norm:zalasr_signext_rd",
              "norm:zalasr_ignore_rs2_upper",
              "norm:zalasr_natural_align",
              "norm:zalasr_misaligned_exception",
              "norm:zalasr_misaligned_pma_relax",
              "norm:zalasr_misaligned_single_op"
            ]
          },
          {
            "title": "Load Acquire",
            "id": "insns-ldatomic",
            "children": [],
            "tags": [
              "norm:ldaq_atomic_load_enc",
              "norm:ldaq_atomic_load_op",
              "norm:ldaq_signext_rule",
              "norm:ldaq_aq_required",
              "norm:ldaq_rl_optional",
              "norm:ldaq_rcsc_semantics",
              "norm:ldaq_no_aq_reserved",
              "norm:ldaq_rv64_only"
            ]
          },
          {
            "title": "Store Release",
            "id": "insns-sdatomic",
            "children": [],
            "tags": [
              "norm:sdrl_atomic_store_enc",
              "norm:sdrl_atomic_store_op",
              "norm:sdrl_rl_required",
              "norm:sdrl_aq_optional",
              "norm:sdrl_rcsc_semantics",
              "norm:sdrl_no_rl_reserved",
              "norm:sdrl_rv64_only"
            ]
          }
        ],
        "tags": [
          "norm:zalasr_def",
          "norm:zalasr_builds_on_amo",
          "norm:zalasr_atomic_ordered"
        ]
      },
      {
        "title": "RVWMO Memory Consistency Model, Version 2.0",
        "id": "memorymodel",
        "children": [
          {
            "title": "Definition of the RVWMO Memory Model",
            "id": "rvwmo",
            "children": [
              {
                "title": "Memory Model Primitives",
                "id": "rvwmo-primitives",
                "children": [],
                "tags": [
                  "norm:rvwmo_single_copy_atomic",
                  "norm:rvwmo_aligned_memop",
                  "norm:rvwmo_aligned_amo_memop",
                  "norm:rvwmo_sc_fail_no_memop",
                  "norm:rvwmo_v_p_multi_memops",
                  "norm:rvwmo_misaligned_ldst_memops",
                  "norm:rvwmo_fp_gt_xlen_memops",
                  "norm:rvwmo_order_multi_memops",
                  "norm:rvwmo_misaligned_in_atomic_pma"
                ]
              },
              {
                "title": "Syntactic Dependencies",
                "id": "mem-dependencies",
                "children": [],
                "tags": []
              },
              {
                "title": "Preserved Program Order",
                "id": "_preserved_program_order",
                "children": [],
                "tags": [
                  "norm:rvwmo_ppo_lead-in",
                  "norm:rvwmo_ppo_overlap",
                  "norm:rvwmo_ppo_overlap1",
                  "norm:rvwmo_ppo_overlap2",
                  "norm:rvwmo_ppo_overlap3",
                  "norm:rvwmo_ppo_sync",
                  "norm:rvwmo_ppo_sync1",
                  "norm:rvwmo_ppo_sync2",
                  "norm:rvwmo_ppo_sync3",
                  "norm:rvwmo_ppo_sync4",
                  "norm:rvwmo_ppo_sync5",
                  "norm:rvwmo_ppo_dep",
                  "norm:rvwmo_ppo_dep1",
                  "norm:rvwmo_ppo_dep2",
                  "norm:rvwmo_ppo_dep3",
                  "norm:rvwmo_ppo_pipe",
                  "norm:rvwmo_ppo_pipe1",
                  "norm:rvwmo_ppo_pipe2"
                ]
              },
              {
                "title": "Memory Model Axioms",
                "id": "_memory_model_axioms",
                "children": [
                  {
                    "title": "Load Value Axiom",
                    "id": "ax-load",
                    "children": [],
                    "tags": [
                      "norm:rvwmo_ld_val_axiom_lead-in",
                      "norm:rvwmo_ld_val_axiom_list"
                    ]
                  },
                  {
                    "title": "Atomicity Axiom",
                    "id": "ax-atom",
                    "children": [],
                    "tags": [
                      "norm:rvwmo_atomicity_axiom"
                    ]
                  },
                  {
                    "title": "Progress Axiom",
                    "id": "ax-prog",
                    "children": [],
                    "tags": [
                      "norm:rvwmo_progress_axiom"
                    ]
                  }
                ],
                "tags": [
                  "norm:rvwmo_obeyed"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "CSR Dependency Tracking Granularity",
            "id": "csr-granularity",
            "children": [],
            "tags": []
          },
          {
            "title": "Source and Destination Register Listings",
            "id": "source-dest-regs",
            "children": [],
            "tags": []
          }
        ],
        "tags": [
          "norm:rvwmo_single_hart_op",
          "norm:rvwmo_only_mainmem",
          "norm:rvwmo_excludes_overlap_widths"
        ]
      },
      {
        "title": "\"Ztso\" Extension for Total Store Ordering, Version 1.0",
        "id": "ztso",
        "children": [],
        "tags": [
          "norm:rvtso_adj_rvwmo",
          "norm:ztso_ld",
          "norm:ztso_sd",
          "norm:ztso_amo",
          "norm:ztso_vect_mem"
        ]
      },
      {
        "title": "\"CMO\" Extensions for Base Cache Management Operation ISA, Version 1.0.0",
        "id": "cmo",
        "children": [
          {
            "title": "Pseudocode for instruction semantics",
            "id": "_pseudocode_for_instruction_semantics",
            "children": [],
            "tags": []
          },
          {
            "title": "Introduction",
            "id": "intro-cmo",
            "children": [],
            "tags": []
          },
          {
            "title": "Background",
            "id": "background",
            "children": [
              {
                "title": "Memory and Caches",
                "id": "memory-caches",
                "children": [],
                "tags": []
              },
              {
                "title": "Cache-Block Operations",
                "id": "_cache_block_operations",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Coherent Agents and Caches",
            "id": "coherent-agents-caches",
            "children": [
              {
                "title": "Memory Ordering",
                "id": "_memory_ordering",
                "children": [
                  {
                    "title": "Preserved Program Order",
                    "id": "_preserved_program_order_2",
                    "children": [],
                    "tags": [
                      "norm:PPO_overlap_1",
                      "norm:PPO_overlap_2"
                    ]
                  },
                  {
                    "title": "Load Values",
                    "id": "_load_values",
                    "children": [],
                    "tags": [
                      "norm:invalidate_load_val1",
                      "norm:invalidate_load_val2",
                      "norm:invalidate_load_val3",
                      "norm:invalidate_load_val4"
                    ]
                  }
                ],
                "tags": []
              },
              {
                "title": "Traps",
                "id": "_traps",
                "children": [
                  {
                    "title": "Illegal-Instruction and Virtual-Instruction Exceptions",
                    "id": "_illegal_instruction_and_virtual_instruction_exceptions",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Page-Fault, Guest-Page-Fault, and Access-Fault Exceptions",
                    "id": "_page_fault_guest_page_fault_and_access_fault_exceptions",
                    "children": [],
                    "tags": [
                      "norm:PMP_same",
                      "norm:PMA_same",
                      "norm:cbo_rsv",
                      "norm:cbm_access",
                      "norm:cbm_unperm_fault",
                      "norm:cbm_unperm_translate",
                      "norm:cbz_access",
                      "norm:cbz_unperm_fault",
                      "norm:cbz_unperm_translate",
                      "norm:cbp_access",
                      "norm:cbp_unperm_noexcep",
                      "norm:cbp_unperm_translate",
                      "norm:fault_excep_csr"
                    ]
                  },
                  {
                    "title": "Address-Misaligned Exceptions",
                    "id": "_address_misaligned_exceptions",
                    "children": [],
                    "tags": [
                      "norm:no_addr_misaligned_excep"
                    ]
                  },
                  {
                    "title": "Breakpoint Exceptions and Debug Mode Entry",
                    "id": "_breakpoint_exceptions_and_debug_mode_entry",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Hypervisor Extension",
                    "id": "_hypervisor_extension",
                    "children": [],
                    "tags": [
                      "norm:h_trans_cache"
                    ]
                  }
                ],
                "tags": []
              },
              {
                "title": "Effects on Constrained LR/SC Loops",
                "id": "_effects_on_constrained_lrsc_loops",
                "children": [],
                "tags": []
              },
              {
                "title": "Software Discovery",
                "id": "_software_discovery",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "CSR controls for CMO instructions",
            "id": "csr_state",
            "children": [],
            "tags": [
              "norm:cbo-inval",
              "norm:cbo-clean_cbo-flush",
              "norm:cbo-zero_basedon_xenvcfg-CBZE",
              "norm:cbxe_unaffected"
            ]
          },
          {
            "title": "Extensions",
            "id": "extensions",
            "children": [
              {
                "title": "Cache-Block Management Instructions",
                "id": "Zicbom",
                "children": [],
                "tags": []
              },
              {
                "title": "Cache-Block Zero Instructions",
                "id": "Zicboz",
                "children": [],
                "tags": [
                  "norm:cbo-zero_specified_block"
                ]
              },
              {
                "title": "Cache-Block Prefetch Instructions",
                "id": "Zicbop",
                "children": [],
                "tags": [
                  "norm:prefetch_operating_block"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Instructions",
            "id": "insns",
            "children": [
              {
                "title": "cbo.clean",
                "id": "insns-cbo_clean",
                "children": [],
                "tags": [
                  "norm:cbo-clean_op",
                  "norm:cbo-clean_offset"
                ]
              },
              {
                "title": "cbo.flush",
                "id": "insns-cbo_flush",
                "children": [],
                "tags": [
                  "norm:cbo-flush_op",
                  "norm:cbo-flush_unaligned"
                ]
              },
              {
                "title": "cbo.inval",
                "id": "insns-cbo_inval",
                "children": [],
                "tags": [
                  "norm:cbo-inval_op",
                  "norm:cbo-inval_unaligned"
                ]
              },
              {
                "title": "cbo.zero",
                "id": "insns-cbo_zero",
                "children": [],
                "tags": [
                  "norm:cbo-zero_op",
                  "norm:cbo-zero_unaligned",
                  "norm:cbo-zero_offset"
                ]
              },
              {
                "title": "prefetch.i",
                "id": "insns-prefetch_i",
                "children": [],
                "tags": [
                  "norm:prefetch-i_op"
                ]
              },
              {
                "title": "prefetch.r",
                "id": "insns-prefetch_r",
                "children": [],
                "tags": [
                  "norm:prefetch-r_op"
                ]
              },
              {
                "title": "prefetch.w",
                "id": "insns-prefetch_w",
                "children": [],
                "tags": [
                  "norm:prefetch-w_op"
                ]
              }
            ],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"F\" Extension for Single-Precision Floating-Point, Version 2.2",
        "id": "single-float",
        "children": [
          {
            "title": "F Register State",
            "id": "_f_register_state",
            "children": [],
            "tags": [
              "norm:flen"
            ]
          },
          {
            "title": "Floating-Point Control and Status Register",
            "id": "_floating_point_control_and_status_register",
            "children": [],
            "tags": [
              "norm:fcsr_op_sz_acc",
              "norm:fflags_frm_op_sz_acc",
              "norm:fcsr_rsv",
              "norm:roundingmode_dynamic",
              "norm:roundingmode_rsv",
              "norm:dyn_round_enc",
              "norm:fcsr-fflags_op"
            ]
          },
          {
            "title": "NaN Generation and Propagation",
            "id": "_nan_generation_and_propagation",
            "children": [],
            "tags": [
              "norm:F_canonical_NaN"
            ]
          },
          {
            "title": "Subnormal Arithmetic",
            "id": "_subnormal_arithmetic",
            "children": [],
            "tags": [
              "norm:ieee_std_subnormal",
              "norm:ieee_std_tininess"
            ]
          },
          {
            "title": "Single-Precision Load and Store Instructions",
            "id": "_single_precision_load_and_store_instructions",
            "children": [],
            "tags": [
              "norm:fsw_flw_op",
              "norm:fsw_flw_atomic_align",
              "norm:fsw_flw_bits_maintained",
              "norm:fp_misaligned"
            ]
          },
          {
            "title": "Single-Precision Floating-Point Computational Instructions",
            "id": "single-float-compute",
            "children": [],
            "tags": [
              "norm:fadd-s_fmul-s_op",
              "norm:fsub-s_op",
              "norm:fdiv-s_op",
              "norm:fsqrt-s_op",
              "norm:fp_rd",
              "norm:F_fmt_single",
              "norm:F_rm_field",
              "norm:fmin-s_fmax-s_op",
              "norm:fmin-s_fmax-s_zero_compare",
              "norm:fmin-s_fmax-s_both_nan_input",
              "norm:fmin-s_fmax-s_one_nan_input",
              "norm:fmin-s_fmax-s_signaling_nan_nv",
              "norm:fma_rs3",
              "norm:fmadd-s_op",
              "norm:fmsub-s_op",
              "norm:fnmsub-s_op",
              "norm:fnmadd-s_op",
              "norm:fma_nv_flag"
            ]
          },
          {
            "title": "Single-Precision Floating-Point Conversion and Move Instructions",
            "id": "_single_precision_floating_point_conversion_and_move_instructions",
            "children": [],
            "tags": [
              "norm:fcvt-l-s_fcvt-w-s_op",
              "norm:fcvt-s-w_fcvt-s-l_op",
              "norm:fcvt-wu-s_fcvt-lu-s_fcvt-s-wu_fcvt-s-lu_op",
              "norm:fcvt_long_float_rv64_only",
              "norm:fcvt_unrepresentable_nv",
              "norm:fcvt_int_float_valid_input",
              "norm:fcvt_round",
              "norm:fcvt_nx",
              "norm:fsgnj-s_fsgnjn-s_fsgnjx-s_op",
              "norm:fmv-x-w_op",
              "norm:fmv-w-x_op"
            ]
          },
          {
            "title": "Single-Precision Floating-Point Compare Instructions",
            "id": "_single_precision_floating_point_compare_instructions",
            "children": [],
            "tags": [
              "norm:feq-s_flt-s_fle-s_op",
              "norm:flt-s_fle-s_signaling",
              "norm:feq-s_quiet",
              "norm:feq-s_flt-s_fle-s_NaN_input"
            ]
          },
          {
            "title": "Single-Precision Floating-Point Classify Instruction",
            "id": "_single_precision_floating_point_classify_instruction",
            "children": [],
            "tags": [
              "norm:fclass-s_op"
            ]
          }
        ],
        "tags": [
          "norm:f_ieee_compliance",
          "norm:f_depends_zicsr"
        ]
      },
      {
        "title": "\"D\" Extension for Double-Precision Floating-Point, Version 2.2",
        "id": "_d_extension_for_double_precision_floating_point_version_2_2",
        "children": [
          {
            "title": "D Register State",
            "id": "_d_register_state",
            "children": [],
            "tags": [
              "norm:D_flen_64"
            ]
          },
          {
            "title": "NaN Boxing of Narrower Values",
            "id": "nanboxing",
            "children": [],
            "tags": [
              "norm:fp_nan-boxing",
              "norm:FP_transfer_instrs_narrow_transfer_in",
              "norm:FP_transfer_instrs_narrow_transfer_out",
              "norm:FP_nontransfer_instrs_improper_nan-boxed_input"
            ]
          },
          {
            "title": "Double-Precision Load and Store Instructions",
            "id": "fld_fsd",
            "children": [],
            "tags": [
              "norm:fld_op",
              "norm:fsd_op",
              "norm:fld_fsd_atomic_align",
              "norm:fld_fsd_bits_maintained"
            ]
          },
          {
            "title": "Double-Precision Floating-Point Computational Instructions",
            "id": "_double_precision_floating_point_computational_instructions",
            "children": [],
            "tags": [
              "norm:D_computational_instrs"
            ]
          },
          {
            "title": "Double-Precision Floating-Point Conversion and Move Instructions",
            "id": "fl-compute",
            "children": [],
            "tags": [
              "norm:fcvt-w-d_fcvt-l-d_op",
              "norm:fcvt-d-w_fcvt-d-l_op",
              "norm:fcvt-wu-d_fcvt-lu-d_fcvt-d-wu_fcvt-d-lu_op",
              "norm:fcvt-w-d_fcvt-wu-d_sign_ext",
              "norm:fcvt_long_double_rv64_only",
              "norm:fcvt_int_double_valid_input",
              "norm:fcvt-s-d_fcvt-d-s_op",
              "norm:fcvt_float_rounding",
              "norm:fsgnj-d_fsgnjn-d_fsgnjx-d_op",
              "norm:fmv-x-d_op",
              "norm:fmv-d-x_op",
              "norm:fmv_bits_preserved"
            ]
          },
          {
            "title": "Double-Precision Floating-Point Compare Instructions",
            "id": "_double_precision_floating_point_compare_instructions",
            "children": [],
            "tags": [
              "norm:D_compare_instrs"
            ]
          },
          {
            "title": "Double-Precision Floating-Point Classify Instruction",
            "id": "fl-compare",
            "children": [],
            "tags": [
              "norm:fclass-d_op"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Q\" Extension for Quad-Precision Floating-Point, Version 2.2",
        "id": "fl-class",
        "children": [
          {
            "title": "Quad-Precision Load and Store Instructions",
            "id": "_quad_precision_load_and_store_instructions",
            "children": [],
            "tags": [
              "norm:fsq_flq_op",
              "norm:fsq_flq_atomic_align",
              "norm:fsq_flq_bits_maintained"
            ]
          },
          {
            "title": "Quad-Precision Computational Instructions",
            "id": "_quad_precision_computational_instructions",
            "children": [],
            "tags": [
              "norm:Q_computational_instrs"
            ]
          },
          {
            "title": "Quad-Precision Convert and Move Instructions",
            "id": "quad-compute",
            "children": [],
            "tags": [
              "norm:fcvt-w-q_fcvt-l-q_op",
              "norm:fcvt-q-w_fcvt-q-l_op",
              "norm:fcvt-wu-q_fcvt-lu-q_fcvt-q-wu_fcvt-q-lu_op",
              "norm:fcvt_long_quad_rv64_only",
              "norm:fcvt-s-q_fcvt-q-s_op",
              "norm:fcvt-d-q_fcvt-q-d_op",
              "norm:fsgnj-q_fsgnjn-q_fsgnjx-q_op"
            ]
          },
          {
            "title": "Quad-Precision Floating-Point Compare Instructions",
            "id": "_quad_precision_floating_point_compare_instructions",
            "children": [],
            "tags": [
              "norm:Q_compare_instrs"
            ]
          },
          {
            "title": "Quad-Precision Floating-Point Classify Instruction",
            "id": "quad-float-compare",
            "children": [],
            "tags": [
              "norm:fclass-q_op"
            ]
          }
        ],
        "tags": [
          "norm:Q_flen_128"
        ]
      },
      {
        "title": "\"Zfh\" and \"Zfhmin\" Extensions for Half-Precision Floating-Point, Version 1.0",
        "id": "chap:zfh",
        "children": [
          {
            "title": "Half-Precision Load and Store Instructions",
            "id": "_half_precision_load_and_store_instructions",
            "children": [],
            "tags": [
              "norm:fsh_flh_op",
              "norm:fsh_flh_atomic_align",
              "norm:fsh_flh_bits_maintained"
            ]
          },
          {
            "title": "Half-Precision Computational Instructions",
            "id": "_half_precision_computational_instructions",
            "children": [],
            "tags": [
              "norm:Zfh_computational_instrs"
            ]
          },
          {
            "title": "Half-Precision Conversion and Move Instructions",
            "id": "_half_precision_conversion_and_move_instructions",
            "children": [],
            "tags": [
              "norm:fcvt-w-h_fcvt-l-h_op",
              "norm:fcvt-h-w_fcvt-h-l_op",
              "norm:fcvt-wu-h_fcvt-lu-h_fcvt-h-wu_fcvt-h-lu_op",
              "norm:fcvt_long_half_rv64_only",
              "norm:fcvt-s-h_fcvt-h-s_op",
              "norm:fcvt-d-h_fcvt-h-d_op",
              "norm:fcvt-q-h_fcvt-h-q_op",
              "norm:fsgnj-h_fsgnjn-h_fsgnjx-h_op",
              "norm:fmv-x-h_op",
              "norm:fmv-h-x_op",
              "norm:fmv_half_bits_preverved"
            ]
          },
          {
            "title": "Half-Precision Floating-Point Compare Instructions",
            "id": "flt-pt-to-int-move",
            "children": [],
            "tags": [
              "norm:Zfh_compare_instrs"
            ]
          },
          {
            "title": "Half-Precision Floating-Point Classify Instruction",
            "id": "half-pr-flt-pt-compare",
            "children": [],
            "tags": [
              "norm:fclass-h_op"
            ]
          },
          {
            "title": "\"Zfhmin\" Standard Extension for Minimal Half-Precision Floating-Point",
            "id": "half-pr-flt-class",
            "children": [],
            "tags": [
              "norm:zfhmin"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"BF16\" Extensions for BFloat16-precision Floating-Point, Version 1.0",
        "id": "bf16",
        "children": [
          {
            "title": "Introduction",
            "id": "BF16_introduction",
            "children": [],
            "tags": []
          },
          {
            "title": "Intended Audience",
            "id": "BF16_audience",
            "children": [],
            "tags": []
          },
          {
            "title": "Number Format",
            "id": "BF16_format",
            "children": [
              {
                "title": "BF16 Operand Format",
                "id": "_bf16_operand_format",
                "children": [],
                "tags": []
              },
              {
                "title": "BF16 Behavior",
                "id": "_bf16_behavior",
                "children": [
                  {
                    "title": "Subnormal Numbers:",
                    "id": "_subnormal_numbers",
                    "children": [],
                    "tags": [
                      "norm:bf16_subnorm"
                    ]
                  },
                  {
                    "title": "Infinities:",
                    "id": "_infinities",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "NaNs",
                    "id": "_nans",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Scalar NaN Boxing",
                    "id": "_scalar_nan_boxing",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Rounding Modes:",
                    "id": "_rounding_modes",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Handling exceptions",
                    "id": "_handling_exceptions",
                    "children": [
                      {
                        "title": "Underflow",
                        "id": "_underflow",
                        "children": [],
                        "tags": []
                      }
                    ],
                    "tags": []
                  }
                ],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Extensions",
            "id": "BF16_extensions",
            "children": [
              {
                "title": "Zfbfmin - Scalar BF16 Converts",
                "id": "zfbfmin",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvfbfmin - Vector BF16 Converts",
                "id": "zvfbfmin",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvfbfwma - Vector BF16 widening mul-add",
                "id": "zvfbfwma",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Instructions",
            "id": "BF16_insns",
            "children": [
              {
                "title": "fcvt.bf16.s",
                "id": "insns-fcvt.bf16.s",
                "children": [],
                "tags": [
                  "norm:fcvt-bf16-s_op"
                ]
              },
              {
                "title": "fcvt.s.bf16",
                "id": "insns-fcvt.s.bf16",
                "children": [],
                "tags": [
                  "norm:fcvt-s-bf16_op"
                ]
              },
              {
                "title": "vfncvtbf16.f.f.w",
                "id": "insns-vfncvtbf16.f.f.w",
                "children": [],
                "tags": [
                  "norm:vfncvtbf16-f-f-w_sew_rsv",
                  "norm:vfncvtbf16-f-f-w_op"
                ]
              },
              {
                "title": "vfwcvtbf16.f.f.v",
                "id": "insns-vfwcvtbf16.f.f.v",
                "children": [],
                "tags": [
                  "norm:vfwcvtbf16-f-f-v_sew_rsv",
                  "norm:vfwcvtbf16-f-f-v_op"
                ]
              },
              {
                "title": "vfwmaccbf16",
                "id": "insns-vfwmaccbf16",
                "children": [],
                "tags": [
                  "norm:vfwmaccbf16_sew_rsv",
                  "norm:vfwmaccbf16_op",
                  "norm:vfwmaccbf16_vv",
                  "norm:vfwmaccbf16_vf"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Bibliography",
            "id": "_bibliography",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Zfa\" Extension for Additional Floating-Point Instructions, Version 1.0",
        "id": "zfa",
        "children": [
          {
            "title": "Load-Immediate Instructions",
            "id": "_load_immediate_instructions",
            "children": [],
            "tags": [
              "norm:fli-s_op",
              "norm:fli-d_op",
              "norm:fli-q_op",
              "norm:fli-h_op"
            ]
          },
          {
            "title": "Minimum and Maximum Instructions",
            "id": "_minimum_and_maximum_instructions",
            "children": [],
            "tags": [
              "norm:fmaxm-s_fminm-s_op",
              "norm:fmaxm-d_fminm-d_op",
              "norm:fmaxm-h_fminm-h_op",
              "norm:fmaxm-q_fminm-q_op"
            ]
          },
          {
            "title": "Round-to-Integer Instructions",
            "id": "_round_to_integer_instructions",
            "children": [],
            "tags": [
              "norm:fround-s_op",
              "norm:fround-s_zero_inf",
              "norm:fround-s_nan_nv",
              "norm:froundnx-s_op",
              "norm:fround-d_froundnx-d_op",
              "norm:fround-h_froundnx-h_op",
              "norm:fround-q_froundnx-q_op"
            ]
          },
          {
            "title": "Modular Convert-to-Integer Instruction",
            "id": "_modular_convert_to_integer_instruction",
            "children": [],
            "tags": [
              "norm:fcvtmod-w-d_op",
              "norm:fcvtmod-w-d_flags",
              "norm:fcvtmod-w-d_rsw"
            ]
          },
          {
            "title": "Move Instructions",
            "id": "_move_instructions",
            "children": [],
            "tags": [
              "norm:fmvh-x-d_op",
              "norm:fmvp-d-x_op",
              "norm:fmvh-x-q_op",
              "norm:fmvp-q-x_op"
            ]
          },
          {
            "title": "Comparison Instructions",
            "id": "_comparison_instructions",
            "children": [],
            "tags": [
              "norm:fleq-s_fltq-s_op",
              "norm:fleq-d_fltq-d_op",
              "norm:fleq-h_fltq-h_op",
              "norm:fleq-q_fltq-q_op"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Zfinx\", \"Zdinx\", \"Zhinx\", \"Zhinxmin\" Extensions for Floating-Point in Integer Registers, Version 1.0",
        "id": "sec:zfinx",
        "children": [
          {
            "title": "Processing of Narrower Values",
            "id": "_processing_of_narrower_values",
            "children": [],
            "tags": [
              "norm:Zfinx_narrow_operands",
              "norm:Zfinx_narrow_result"
            ]
          },
          {
            "title": "Zdinx",
            "id": "_zdinx",
            "children": [],
            "tags": [
              "norm:Zdinx_D_instrs",
              "norm:Zdinx_x_regs"
            ]
          },
          {
            "title": "Processing of Wider Values",
            "id": "_processing_of_wider_values",
            "children": [],
            "tags": [
              "norm:Zdinx_x_reg_pair",
              "norm:Zdinx_endianness",
              "norm:Zdinx_x0_write",
              "norm:Zdinx_x0_read"
            ]
          },
          {
            "title": "Zhinx",
            "id": "_zhinx",
            "children": [],
            "tags": [
              "norm:Zhinx_Zfh_instrs",
              "norm:Zhinx_x_regs"
            ]
          },
          {
            "title": "Zhinxmin",
            "id": "_zhinxmin",
            "children": [],
            "tags": [
              "norm:Zfhinxmin_instrs"
            ]
          },
          {
            "title": "Privileged Architecture Implications",
            "id": "_privileged_architecture_implications",
            "children": [],
            "tags": [
              "norm:Zfinx_mstatus-FS_zero",
              "norm:Zfinx_misa-F_D_Q_zero"
            ]
          }
        ],
        "tags": [
          "norm:Zfinx_F_instrs",
          "norm:Zfinx_x_regs"
        ]
      },
      {
        "title": "\"C\" Extension for Compressed Instructions, Version 2.0",
        "id": "compressed",
        "children": [
          {
            "title": "Overview",
            "id": "_overview",
            "children": [],
            "tags": [
              "norm:Zca_align16",
              "norm:Zca_no_misaligned"
            ]
          },
          {
            "title": "Compressed Instruction Formats",
            "id": "_compressed_instruction_formats",
            "children": [],
            "tags": [
              "norm:Zca_regs8",
              "norm:Zc_fp_regs"
            ]
          },
          {
            "title": "Load and Store Instructions",
            "id": "_load_and_store_instructions_2",
            "children": [
              {
                "title": "Stack-Pointer-Based Loads and Stores",
                "id": "_stack_pointer_based_loads_and_stores",
                "children": [],
                "tags": [
                  "norm:c-lwsp_op",
                  "norm:c-lwsp_rsv",
                  "norm:c-ldsp_op",
                  "norm:c-ldsp_rsv",
                  "norm:c-flwsp_op",
                  "norm:c-fldsp_op",
                  "norm:c-swsp_op",
                  "norm:c-sdsp_op",
                  "norm:c-fswsp_op",
                  "norm:c-fsdwsp_op"
                ]
              },
              {
                "title": "Register-Based Loads and Stores",
                "id": "_register_based_loads_and_stores",
                "children": [],
                "tags": [
                  "norm:c-lw_op",
                  "norm:c-ld_op",
                  "norm:c-flw_op",
                  "norm:c-fld_op",
                  "norm:c-sw_op",
                  "norm:c-sd_op",
                  "norm:c-fsw_op",
                  "norm:c-fsd_op"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Control Transfer Instructions",
            "id": "_control_transfer_instructions_2",
            "children": [],
            "tags": [
              "norm:Zca_offsets_mul2",
              "norm:c-j_op",
              "norm:c-jal_op",
              "norm:c-jr_op",
              "norm:c-jr_rsv",
              "norm:c-jalr_op",
              "norm:c-jalr_ebreak",
              "norm:c-beqz_op",
              "norm:c-bnez_op"
            ]
          },
          {
            "title": "Integer Computational Instructions",
            "id": "_integer_computational_instructions_3",
            "children": [
              {
                "title": "Integer Constant-Generation Instructions",
                "id": "_integer_constant_generation_instructions",
                "children": [],
                "tags": [
                  "norm:c-li_op",
                  "norm:c-li_hint",
                  "norm:c-lui_op",
                  "norm:c-lui_rsv",
                  "norm:c-lui_hint"
                ]
              },
              {
                "title": "Integer Register-Immediate Operations",
                "id": "_integer_register_immediate_operations",
                "children": [],
                "tags": [
                  "norm:c-addi_op",
                  "norm:c-addi_hint",
                  "norm:c-addi_nop",
                  "norm:c-addiw_op",
                  "norm:c-addiw_rsv",
                  "norm:c-addi16sp_op",
                  "norm:c-addi16sp_rsv",
                  "norm:c-addi4spn_op",
                  "norm:c-addi4spn_rsv",
                  "norm:c-slli_op",
                  "norm:c-slli_hint",
                  "norm:c-slli_shamt5",
                  "norm:c-srli_op",
                  "norm:c-srli_hint",
                  "norm:c-srli_shamt5",
                  "norm:c-srai_op",
                  "norm:c-andi_op"
                ]
              },
              {
                "title": "Integer Register-Register Operations",
                "id": "_integer_register_register_operations_2",
                "children": [],
                "tags": [
                  "norm:c-mv_op",
                  "norm:c-mv_jr",
                  "norm:c-mv_hint",
                  "norm:c-add_op",
                  "norm:c-add_val",
                  "norm:c-add_hint",
                  "norm:c-and_op",
                  "norm:c-or_op",
                  "norm:c-xor_op",
                  "norm:c-sub_op",
                  "norm:c-addw_op",
                  "norm:c-subw_op"
                ]
              },
              {
                "title": "Defined Illegal Instruction",
                "id": "_defined_illegal_instruction",
                "children": [],
                "tags": [
                  "norm:Zca_illegal"
                ]
              },
              {
                "title": "NOP Instruction",
                "id": "_nop_instruction_2",
                "children": [],
                "tags": [
                  "norm:c-nop_op",
                  "norm:c-nop_hint"
                ]
              },
              {
                "title": "Breakpoint Instruction",
                "id": "_breakpoint_instruction",
                "children": [],
                "tags": [
                  "norm:c-ebreak_op"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Usage of C Instructions in LR/SC Sequences",
            "id": "_usage_of_c_instructions_in_lrsc_sequences",
            "children": [],
            "tags": []
          },
          {
            "title": "HINT Instructions",
            "id": "rvc-hints",
            "children": [],
            "tags": [
              "norm:Zca_hints"
            ]
          },
          {
            "title": "RVC Instruction Set Listings",
            "id": "_rvc_instruction_set_listings",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Zc*\" Extension for Code Size Reduction, Version 1.0.0",
        "id": "Zc",
        "children": [
          {
            "title": "Zc* Overview",
            "id": "_zc_overview",
            "children": [],
            "tags": []
          },
          {
            "title": "C",
            "id": "C",
            "children": [],
            "tags": []
          },
          {
            "title": "Zce",
            "id": "_zce",
            "children": [],
            "tags": []
          },
          {
            "title": "MISA.C",
            "id": "misaC",
            "children": [],
            "tags": [
              "norm:misa-c_set_line",
              "norm:misa-c_set_list"
            ]
          },
          {
            "title": "Zca",
            "id": "_zca",
            "children": [],
            "tags": []
          },
          {
            "title": "Zcf (RV32 only)",
            "id": "_zcf_rv32_only",
            "children": [],
            "tags": []
          },
          {
            "title": "Zcd",
            "id": "_zcd",
            "children": [],
            "tags": []
          },
          {
            "title": "Zcb",
            "id": "_zcb",
            "children": [],
            "tags": []
          },
          {
            "title": "Zcmp",
            "id": "Zcmp",
            "children": [],
            "tags": []
          },
          {
            "title": "Zcmt",
            "id": "Zcmt",
            "children": [],
            "tags": []
          },
          {
            "title": "Zc instruction formats",
            "id": "Zc_formats",
            "children": [],
            "tags": []
          },
          {
            "title": "Zcb instructions",
            "id": "Zcb_instructions",
            "children": [
              {
                "title": "c.lbu",
                "id": "insns-c_lbu",
                "children": [],
                "tags": [
                  "norm:c-lbu_op"
                ]
              },
              {
                "title": "c.lhu",
                "id": "insns-c_lhu",
                "children": [],
                "tags": [
                  "norm:c-lhu_op"
                ]
              },
              {
                "title": "c.lh",
                "id": "insns-c_lh",
                "children": [],
                "tags": [
                  "norm:c-lh_op"
                ]
              },
              {
                "title": "c.sb",
                "id": "insns-c_sb",
                "children": [],
                "tags": [
                  "norm:c-sb_op"
                ]
              },
              {
                "title": "c.sh",
                "id": "insns-c_sh",
                "children": [],
                "tags": [
                  "norm:c-sh_op"
                ]
              },
              {
                "title": "c.zext.b",
                "id": "insns-c_zext_b",
                "children": [],
                "tags": [
                  "norm:c-zext-b_op"
                ]
              },
              {
                "title": "c.sext.b",
                "id": "insns-c_sext_b",
                "children": [],
                "tags": [
                  "norm:c-sext-b_op"
                ]
              },
              {
                "title": "c.zext.h",
                "id": "insns-c_zext_h",
                "children": [],
                "tags": [
                  "norm:c-zext-h_op"
                ]
              },
              {
                "title": "c.sext.h",
                "id": "insns-c_sext_h",
                "children": [],
                "tags": [
                  "norm:c-sext-h_op"
                ]
              },
              {
                "title": "c.zext.w",
                "id": "insns-c_zext_w",
                "children": [],
                "tags": [
                  "norm:c-zext-w_op"
                ]
              },
              {
                "title": "c.not",
                "id": "insns-c_not",
                "children": [],
                "tags": [
                  "norm:c-not_op"
                ]
              },
              {
                "title": "c.mul",
                "id": "insns-c_mul",
                "children": [],
                "tags": [
                  "norm:c-mul_op"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "PUSH/POP register instructions",
            "id": "insns-pushpop",
            "children": [
              {
                "title": "PUSH/POP functional overview",
                "id": "_pushpop_functional_overview",
                "children": [],
                "tags": []
              },
              {
                "title": "Example usage",
                "id": "_example_usage",
                "children": [
                  {
                    "title": "Stack pointer adjustment handling",
                    "id": "pushpop-areg-list",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Register list handling",
                    "id": "_register_list_handling",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              },
              {
                "title": "PUSH/POP Fault handling",
                "id": "pushpop-idempotent-memory",
                "children": [],
                "tags": [
                  "norm:Zcmp_reexecute",
                  "norm:Zcmp_trap",
                  "norm:interrupts_allowed_in_pushpop"
                ]
              },
              {
                "title": "Software view of execution",
                "id": "pushpop-software-view",
                "children": [
                  {
                    "title": "Software view of the PUSH sequence",
                    "id": "_software_view_of_the_push_sequence",
                    "children": [],
                    "tags": [
                      "norm:Zcmp_push_sp_commit",
                      "norm:Zcmp_bus_fault"
                    ]
                  },
                  {
                    "title": "Software view of the POP/POPRET sequence",
                    "id": "_software_view_of_the_poppopret_sequence",
                    "children": [],
                    "tags": [
                      "norm:Zcmp_pop_sp_commit"
                    ]
                  }
                ],
                "tags": []
              },
              {
                "title": "Non-idempotent memory handling",
                "id": "pushpop_non-idem-mem",
                "children": [],
                "tags": []
              },
              {
                "title": "Example RV32I PUSH/POP sequences",
                "id": "_example_rv32i_pushpop_sequences",
                "children": [
                  {
                    "title": "cm.push  \\{ra, s0-s2}, -64",
                    "id": "_cm_push_ra_s0_s2_64",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "cm.push \\{ra, s0-s11}, -112",
                    "id": "_cm_push_ra_s0_s11_112",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "cm.pop   {ra}, 16",
                    "id": "_cm_pop_ra_16",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "cm.pop \\{ra, s0-s3}, 48",
                    "id": "_cm_pop_ra_s0_s3_48",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "cm.pop \\{ra, s0-s4}, 64",
                    "id": "_cm_pop_ra_s0_s4_64",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              },
              {
                "title": "cm.push",
                "id": "insns-cm_push",
                "children": [],
                "tags": [
                  "norm:cm-push_op"
                ]
              },
              {
                "title": "cm.pop",
                "id": "insns-cm_pop",
                "children": [],
                "tags": [
                  "norm:cm-pop_op"
                ]
              },
              {
                "title": "cm.popretz",
                "id": "insns-cm_popretz",
                "children": [],
                "tags": [
                  "norm:cm-popretz_op"
                ]
              },
              {
                "title": "cm.popret",
                "id": "insns-cm_popret",
                "children": [],
                "tags": [
                  "norm:cm-popret_op"
                ]
              },
              {
                "title": "cm.mvsa01",
                "id": "insns-cm_mvsa01",
                "children": [],
                "tags": [
                  "norm:cm-mvsa01_res",
                  "norm:cm-mvsa01_op",
                  "norm:cm-mvsa01_sreg"
                ]
              },
              {
                "title": "cm.mva01s",
                "id": "insns-cm_mva01s",
                "children": [],
                "tags": [
                  "norm:cm-mva01s_op",
                  "norm:cm-mva01s_sreg"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Table Jump Overview",
            "id": "insns-tablejump",
            "children": [
              {
                "title": "jvt",
                "id": "_jvt",
                "children": [],
                "tags": [
                  "norm:Zcmt_entry_sz"
                ]
              },
              {
                "title": "Table Jump Fault handling",
                "id": "tablejump-fault-handling",
                "children": [],
                "tags": [
                  "norm:Zcmt_fetch",
                  "norm:Zcmt_trap"
                ]
              },
              {
                "title": "jvt CSR",
                "id": "csrs-jvt",
                "children": [],
                "tags": [
                  "norm:jvt_reg",
                  "norm:jvt_op",
                  "norm:jvt_base_vm",
                  "norm:jvt_mode_acc"
                ]
              },
              {
                "title": "cm.jt",
                "id": "insns-cm_jt",
                "children": [],
                "tags": [
                  "norm:cm-jt_op"
                ]
              },
              {
                "title": "cm.jalt",
                "id": "insns-cm_jalt",
                "children": [],
                "tags": [
                  "norm:cm-jalt_op"
                ]
              }
            ],
            "tags": [
              "norm:Zcmt_table",
              "norm:Zcmt_endian"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "Bit Manipulation Extensions",
        "id": "bits",
        "children": [
          {
            "title": "\"B\" Extension for Bit Manipulation, Version 1.0.0",
            "id": "_b_extension_for_bit_manipulation_version_1_0_0",
            "children": [],
            "tags": [
              "norm:b_extension_composition"
            ]
          },
          {
            "title": "Zba: Extension for Address generation, Version 1.0.0",
            "id": "zba",
            "children": [],
            "tags": [
              "norm:zba_slli_uw_function"
            ]
          },
          {
            "title": "Zbb: Extension for Basic bit-manipulation, Version 1.0.0",
            "id": "zbb",
            "children": [
              {
                "title": "Logical with negate",
                "id": "_logical_with_negate",
                "children": [],
                "tags": []
              },
              {
                "title": "Count leading/trailing zero bits",
                "id": "_count_leadingtrailing_zero_bits",
                "children": [],
                "tags": []
              },
              {
                "title": "Count population",
                "id": "_count_population",
                "children": [],
                "tags": []
              },
              {
                "title": "Integer minimum/maximum",
                "id": "_integer_minimummaximum",
                "children": [],
                "tags": []
              },
              {
                "title": "Sign extension and zero extension",
                "id": "_sign_extension_and_zero_extension",
                "children": [],
                "tags": [
                  "norm:zbb_sign_zero_extension_function"
                ]
              },
              {
                "title": "Bitwise rotation",
                "id": "_bitwise_rotation",
                "children": [],
                "tags": [
                  "norm:zbb_rotate_semantics"
                ]
              },
              {
                "title": "OR Combine",
                "id": "_or_combine",
                "children": [],
                "tags": [
                  "norm:zbb_orc_b_semantics"
                ]
              },
              {
                "title": "Byte-reverse",
                "id": "_byte_reverse",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Zbc: Extension for Carry-less multiplication, Version 1.0.0",
            "id": "zbc",
            "children": [],
            "tags": [
              "norm:zbc_clmul_clmulh_results",
              "norm:zbc_clmulr_results"
            ]
          },
          {
            "title": "Zbs: Extension for Single-bit instructions, Version 1.0.0",
            "id": "zbs",
            "children": [],
            "tags": [
              "norm:zbs_single_bit_functionality"
            ]
          },
          {
            "title": "Zbkb: Extension for Bit-manipulation for Cryptography, Version 1.0.0",
            "id": "zbkb",
            "children": [],
            "tags": []
          },
          {
            "title": "Zbkc: Extension for Carry-less multiplication for Cryptography, Version 1.0.0",
            "id": "zbkc",
            "children": [],
            "tags": []
          },
          {
            "title": "Zbkx: Extension for Crossbar permutations, Version 1.0.0",
            "id": "zbkx",
            "children": [],
            "tags": [
              "norm:zbkx_lookup_table_model",
              "norm:zbkx_indexing_behavior"
            ]
          },
          {
            "title": "Instructions (in alphabetical order)",
            "id": "insns-b",
            "children": [
              {
                "title": "add.uw",
                "id": "insns-add_uw",
                "children": [],
                "tags": [
                  "norm:add_uw_enc",
                  "norm:add_uw_op"
                ]
              },
              {
                "title": "andn",
                "id": "insns-andn",
                "children": [],
                "tags": [
                  "norm:andn_enc",
                  "norm:andn_op"
                ]
              },
              {
                "title": "bclr",
                "id": "insns-bclr",
                "children": [],
                "tags": [
                  "norm:bclr_enc",
                  "norm:bclr_op"
                ]
              },
              {
                "title": "bclri",
                "id": "insns-bclri",
                "children": [],
                "tags": [
                  "norm:bclri_rv32_enc",
                  "norm:bclri_rv64_enc",
                  "norm:bclri_shamt_rsv_rv32",
                  "norm:bclri_op"
                ]
              },
              {
                "title": "bext",
                "id": "insns-bext",
                "children": [],
                "tags": [
                  "norm:bext_enc",
                  "norm:bext_op"
                ]
              },
              {
                "title": "bexti",
                "id": "insns-bexti",
                "children": [],
                "tags": [
                  "norm:bexti_rv32_enc",
                  "norm:bexti_rv64_enc",
                  "norm:bexti_shamt_rsv_rv32",
                  "norm:bexti_op"
                ]
              },
              {
                "title": "binv",
                "id": "insns-binv",
                "children": [],
                "tags": [
                  "norm:binv_enc",
                  "norm:binv_op"
                ]
              },
              {
                "title": "binvi",
                "id": "insns-binvi",
                "children": [],
                "tags": [
                  "norm:binvi_rv32_enc",
                  "norm:binvi_rv64_enc",
                  "norm:binvi_shamt_rsv_rv32",
                  "norm:binvi_op"
                ]
              },
              {
                "title": "bset",
                "id": "insns-bset",
                "children": [],
                "tags": [
                  "norm:bset_enc",
                  "norm:bset_op"
                ]
              },
              {
                "title": "bseti",
                "id": "insns-bseti",
                "children": [],
                "tags": [
                  "norm:bseti_rv32_enc",
                  "norm:bseti_rv64_enc",
                  "norm:bseti_shamt_rsv_rv32",
                  "norm:bseti_op"
                ]
              },
              {
                "title": "clmul",
                "id": "insns-clmul",
                "children": [],
                "tags": [
                  "norm:clmul_enc",
                  "norm:clmul_op"
                ]
              },
              {
                "title": "clmulh",
                "id": "insns-clmulh",
                "children": [],
                "tags": [
                  "norm:clmulh_enc",
                  "norm:clmulh_op"
                ]
              },
              {
                "title": "clmulr",
                "id": "insns-clmulr",
                "children": [],
                "tags": [
                  "norm:clmulr_enc",
                  "norm:clmulr_op"
                ]
              },
              {
                "title": "clz",
                "id": "insns-clz",
                "children": [],
                "tags": [
                  "norm:clz_enc",
                  "norm:clz_op"
                ]
              },
              {
                "title": "clzw",
                "id": "insns-clzw",
                "children": [],
                "tags": [
                  "norm:clzw_enc",
                  "norm:clzw_op"
                ]
              },
              {
                "title": "cpop",
                "id": "insns-cpop",
                "children": [],
                "tags": [
                  "norm:cpop_enc",
                  "norm:cpop_op"
                ]
              },
              {
                "title": "cpopw",
                "id": "insns-cpopw",
                "children": [],
                "tags": [
                  "norm:cpopw_enc",
                  "norm:cpopw_op"
                ]
              },
              {
                "title": "ctz",
                "id": "insns-ctz",
                "children": [],
                "tags": [
                  "norm:ctz_enc",
                  "norm:ctz_op"
                ]
              },
              {
                "title": "ctzw",
                "id": "insns-ctzw",
                "children": [],
                "tags": [
                  "norm:ctzw_enc",
                  "norm:ctzw_op"
                ]
              },
              {
                "title": "max",
                "id": "insns-max",
                "children": [],
                "tags": [
                  "norm:max_enc",
                  "norm:max_op"
                ]
              },
              {
                "title": "maxu",
                "id": "insns-maxu",
                "children": [],
                "tags": [
                  "norm:maxu_enc",
                  "norm:maxu_op"
                ]
              },
              {
                "title": "min",
                "id": "insns-min",
                "children": [],
                "tags": [
                  "norm:min_enc",
                  "norm:min_op"
                ]
              },
              {
                "title": "minu",
                "id": "insns-minu",
                "children": [],
                "tags": [
                  "norm:minu_enc",
                  "norm:minu_op"
                ]
              },
              {
                "title": "orc.b",
                "id": "insns-orc_b",
                "children": [],
                "tags": [
                  "norm:orc_b_enc",
                  "norm:orc_b_op"
                ]
              },
              {
                "title": "orn",
                "id": "insns-orn",
                "children": [],
                "tags": [
                  "norm:orn_enc",
                  "norm:orn_op"
                ]
              },
              {
                "title": "pack",
                "id": "insns-pack",
                "children": [],
                "tags": [
                  "norm:pack_enc",
                  "norm:pack_op"
                ]
              },
              {
                "title": "packh",
                "id": "insns-packh",
                "children": [],
                "tags": [
                  "norm:packh_enc",
                  "norm:packh_op"
                ]
              },
              {
                "title": "packw",
                "id": "insns-packw",
                "children": [],
                "tags": [
                  "norm:packw_enc",
                  "norm:packw_op"
                ]
              },
              {
                "title": "rev8",
                "id": "insns-rev8",
                "children": [],
                "tags": [
                  "norm:rev8_rv32_enc",
                  "norm:rev8_rv64_enc",
                  "norm:rev8_op"
                ]
              },
              {
                "title": "brev8",
                "id": "insns-brev8",
                "children": [],
                "tags": [
                  "norm:brev8_enc",
                  "norm:brev8_op"
                ]
              },
              {
                "title": "rol",
                "id": "insns-rol",
                "children": [],
                "tags": [
                  "norm:rol_enc",
                  "norm:rol_op"
                ]
              },
              {
                "title": "rolw",
                "id": "insns-rolw",
                "children": [],
                "tags": [
                  "norm:rolw_enc",
                  "norm:rolw_op"
                ]
              },
              {
                "title": "ror",
                "id": "insns-ror",
                "children": [],
                "tags": [
                  "norm:ror_enc",
                  "norm:ror_op"
                ]
              },
              {
                "title": "rori",
                "id": "insns-rori",
                "children": [],
                "tags": [
                  "norm:rori_rv32_enc",
                  "norm:rori_rv64_enc",
                  "norm:rori_op"
                ]
              },
              {
                "title": "roriw",
                "id": "insns-roriw",
                "children": [],
                "tags": [
                  "norm:roriw_enc",
                  "norm:roriw_op"
                ]
              },
              {
                "title": "rorw",
                "id": "insns-rorw",
                "children": [],
                "tags": [
                  "norm:rorw_enc",
                  "norm:rorw_op"
                ]
              },
              {
                "title": "sext.b",
                "id": "insns-sext_b",
                "children": [],
                "tags": [
                  "norm:sext_b_enc",
                  "norm:sext_b_op"
                ]
              },
              {
                "title": "sext.h",
                "id": "insns-sext_h",
                "children": [],
                "tags": [
                  "norm:sext_h_enc",
                  "norm:sext_h_op"
                ]
              },
              {
                "title": "sh1add",
                "id": "insns-sh1add",
                "children": [],
                "tags": [
                  "norm:sh1add_enc",
                  "norm:sh1add_op"
                ]
              },
              {
                "title": "sh1add.uw",
                "id": "insns-sh1add_uw",
                "children": [],
                "tags": [
                  "norm:sh1add_uw_enc",
                  "norm:sh1add_uw_op"
                ]
              },
              {
                "title": "sh2add",
                "id": "insns-sh2add",
                "children": [],
                "tags": [
                  "norm:sh2add_enc",
                  "norm:sh2add_op"
                ]
              },
              {
                "title": "sh2add.uw",
                "id": "insns-sh2add_uw",
                "children": [],
                "tags": [
                  "norm:sh2add_uw_enc",
                  "norm:sh2add_uw_op"
                ]
              },
              {
                "title": "sh3add",
                "id": "insns-sh3add",
                "children": [],
                "tags": [
                  "norm:sh3add_enc",
                  "norm:sh3add_op"
                ]
              },
              {
                "title": "sh3add.uw",
                "id": "insns-sh3add_uw",
                "children": [],
                "tags": [
                  "norm:sh3add_uw_enc",
                  "norm:sh3add_uw_op"
                ]
              },
              {
                "title": "slli.uw",
                "id": "insns-slli_uw",
                "children": [],
                "tags": [
                  "norm:slli_uw_enc",
                  "norm:slli_uw_op"
                ]
              },
              {
                "title": "unzip",
                "id": "insns-unzip",
                "children": [],
                "tags": [
                  "norm:unzip_enc",
                  "norm:unzip_op"
                ]
              },
              {
                "title": "xnor",
                "id": "insns-xnor",
                "children": [],
                "tags": [
                  "norm:xnor_enc",
                  "norm:xnor_op"
                ]
              },
              {
                "title": "xperm8",
                "id": "insns-xperm8",
                "children": [],
                "tags": [
                  "norm:xperm8_enc",
                  "norm:xperm8_op"
                ]
              },
              {
                "title": "xperm4",
                "id": "insns-xperm4",
                "children": [],
                "tags": [
                  "norm:xperm4_enc",
                  "norm:xperm4_op"
                ]
              },
              {
                "title": "zext.h",
                "id": "insns-zext_h",
                "children": [],
                "tags": [
                  "norm:zext_h_rv32_enc",
                  "norm:zext_h_rv64_enc",
                  "norm:zext_h_op"
                ]
              },
              {
                "title": "zip",
                "id": "insns-zip",
                "children": [],
                "tags": [
                  "norm:zip_enc",
                  "norm:zip_op"
                ]
              }
            ],
            "tags": []
          }
        ],
        "tags": [
          "norm:bitmanip_rv32_rv64",
          "norm:bitmanip_w_suffix_semantics",
          "norm:bitmanip_uw_suffix_semantics",
          "norm:bitmanip_bhw_suffix_semantics"
        ]
      },
      {
        "title": "\"V\" Standard Extension for Vector Operations, Version 1.0",
        "id": "vector",
        "children": [
          {
            "title": "Introduction",
            "id": "_introduction_2",
            "children": [],
            "tags": []
          },
          {
            "title": "Implementation-defined Constant Parameters",
            "id": "_implementation_defined_constant_parameters",
            "children": [],
            "tags": [
              "norm:elen",
              "norm:vlen"
            ]
          },
          {
            "title": "Vector Extension Programmer&#8217;s Model",
            "id": "_vector_extension_programmers_model",
            "children": [
              {
                "title": "Vector Registers",
                "id": "_vector_registers",
                "children": [],
                "tags": [
                  "norm:vreg_count"
                ]
              },
              {
                "title": "Vector Context Status in mstatus",
                "id": "_vector_context_status_in_mstatus",
                "children": [],
                "tags": [
                  "norm:mstatus-vs_sstatus-vs_op",
                  "norm:mstatus-vs_op_off",
                  "norm:mstatus-vs_op_initial_clean",
                  "norm:mstatus-sd_op",
                  "norm:mutable_misa_v",
                  "norm:mstatus_vs_exists"
                ]
              },
              {
                "title": "Vector Context Status in vsstatus",
                "id": "_vector_context_status_in_vsstatus",
                "children": [],
                "tags": [
                  "norm:vsstatus-vs_sz_acc",
                  "norm:vsstatus-vs_mstatus-vs_op_off",
                  "norm:vsstatus-vs_mstatus-vs_op_active",
                  "norm:hw_mstatus_vs_dirty_update",
                  "norm:vsstatus-sd_op_vs",
                  "norm:mstatus-sd_op_vs",
                  "norm:vsstatus_vs_exists"
                ]
              },
              {
                "title": "Vector Type (vtype) Register",
                "id": "_vector_type_vtype_register",
                "children": [
                  {
                    "title": "Vector Selected Element Width (vsew[2:0])",
                    "id": "_vector_selected_element_width_vsew20",
                    "children": [],
                    "tags": [
                      "norm:vtype-vsew_op",
                      "norm:vtype-vsew_rsv"
                    ]
                  },
                  {
                    "title": "Vector Register Grouping (vlmul[2:0])",
                    "id": "vector-register-grouping",
                    "children": [],
                    "tags": [
                      "norm:vtype-lmul_val",
                      "norm:vtype-lmul_fval",
                      "norm:vtype-sew_val",
                      "norm:vtype-lmul_fval_rsv",
                      "norm:lmul",
                      "norm:vlmax",
                      "norm:vreg_offgroup_lmul2_rsv",
                      "norm:vreg_offgroup_lmul4_rsv",
                      "norm:vreg_offgroup_lmul8_rsv",
                      "norm:vreg_mask_lmul_indp"
                    ]
                  },
                  {
                    "title": "Vector Tail Agnostic and Vector Mask Agnostic vta and vma",
                    "id": "sec-agnostic",
                    "children": [],
                    "tags": [
                      "norm:vtype-vta-vma_op",
                      "norm:vtype-vta-vma_val",
                      "norm:vreg_mask_tail_agn",
                      "norm:vreg_mask_op",
                      "norm:vreg_agnostic_op",
                      "norm:vreg_mask_tail_op"
                    ]
                  },
                  {
                    "title": "Vector Type Illegal (vill)",
                    "id": "_vector_type_illegal_vill",
                    "children": [],
                    "tags": [
                      "norm:vtype-vill_op"
                    ]
                  }
                ],
                "tags": [
                  "norm:vtype_sz_acc_op",
                  "norm:vtype-fields_sz",
                  "norm:vill_implicit_encoding"
                ]
              },
              {
                "title": "Vector Length (vl) Register",
                "id": "_vector_length_vl_register",
                "children": [],
                "tags": [
                  "norm:vl_acc",
                  "norm:vl_op"
                ]
              },
              {
                "title": "Vector Byte Length (vlenb) Register",
                "id": "_vector_byte_length_vlenb_register",
                "children": [],
                "tags": [
                  "norm:vlenb_acc_op"
                ]
              },
              {
                "title": "Vector Start Index (vstart) Register",
                "id": "_vector_start_index_vstart_register",
                "children": [],
                "tags": [
                  "norm:vstart_acc_sz",
                  "norm:vstart_op",
                  "norm:vstart_update",
                  "norm:vstart_unmodified",
                  "norm:vstart_sz_writable",
                  "norm:vstart_val_rsv",
                  "norm:vstart_vtype_dep"
                ]
              },
              {
                "title": "Vector Fixed-Point Rounding Mode (vxrm) Register",
                "id": "_vector_fixed_point_rounding_mode_vxrm_register",
                "children": [],
                "tags": [
                  "norm:vxrm_val_sz_acc",
                  "norm:vcsr-vxrm_op",
                  "norm:vxrm_op"
                ]
              },
              {
                "title": "Vector Fixed-Point Saturation Flag (vxsat)",
                "id": "_vector_fixed_point_saturation_flag_vxsat",
                "children": [],
                "tags": [
                  "norm:vxsat_op_acc_sz",
                  "norm:vcsr-vxsat_op"
                ]
              },
              {
                "title": "Vector Control and Status (vcsr) Register",
                "id": "_vector_control_and_status_vcsr_register",
                "children": [],
                "tags": [
                  "norm:vcsr-vxrm-vxsat_acc"
                ]
              },
              {
                "title": "State of Vector Extension at Reset",
                "id": "_state_of_vector_extension_at_reset",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Mapping of Vector Elements to Vector Register State",
            "id": "_mapping_of_vector_elements_to_vector_register_state",
            "children": [
              {
                "title": "Mapping for LMUL = 1",
                "id": "_mapping_for_lmul_1",
                "children": [],
                "tags": [
                  "norm:vreg_lmul1_op"
                ]
              },
              {
                "title": "Mapping for LMUL &lt; 1",
                "id": "_mapping_for_lmul_1_2",
                "children": [],
                "tags": [
                  "norm:vreg_flmul_op"
                ]
              },
              {
                "title": "Mapping for LMUL &gt; 1",
                "id": "_mapping_for_lmul_1_3",
                "children": [],
                "tags": [
                  "norm:vreg_lmulge2_op"
                ]
              },
              {
                "title": "Mapping across Mixed-Width Operations",
                "id": "sec-mapping-mixed",
                "children": [],
                "tags": []
              },
              {
                "title": "Mask Register Layout",
                "id": "sec-mask-register-layout",
                "children": [],
                "tags": [
                  "norm:vreg_mask_vtype_indp",
                  "norm:vreg_mask_sz"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Vector Instruction Formats",
            "id": "_vector_instruction_formats",
            "children": [
              {
                "title": "Scalar Operands",
                "id": "_scalar_operands",
                "children": [],
                "tags": [
                  "norm:vreg_scalar_lmul_indp"
                ]
              },
              {
                "title": "Vector Operands",
                "id": "sec-vec-operands",
                "children": [],
                "tags": [
                  "norm:eew_emul",
                  "norm:eew_emul_sew_lmul_dep",
                  "norm:vnarrowing_eew_emul",
                  "norm:emul_offgroup_rsv",
                  "norm:vreg_source_eew_rsv",
                  "norm:vreg_overlap_legal",
                  "norm:vreg_mask_overlap",
                  "norm:vreg_overlap_rsv",
                  "norm:vreg_overlap_agn",
                  "norm:emul_rsv",
                  "norm:vreg_scalar_emul"
                ]
              },
              {
                "title": "Vector Masking",
                "id": "_vector_masking",
                "children": [
                  {
                    "title": "Mask Encoding",
                    "id": "sec-vector-mask-encoding",
                    "children": [],
                    "tags": [
                      "norm:vmask_vm_enc"
                    ]
                  }
                ],
                "tags": [
                  "norm:vmask_inactive_op",
                  "norm:vmask_agn_op",
                  "norm:vreg_vmask",
                  "norm:vreg_vmask_rsv"
                ]
              },
              {
                "title": "Prestart, Active, Inactive, Body, and Tail Element Definitions",
                "id": "sec-inactive-defs",
                "children": [],
                "tags": [
                  "norm:vector_prestart_element",
                  "norm:vector_active_element",
                  "norm:vector_inactive_element",
                  "norm:vector_tail_element",
                  "norm:vstart_vl_dep",
                  "norm:vstart_vl_scalar_indp"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl)",
            "id": "sec-vector-config",
            "children": [
              {
                "title": "vtype encoding",
                "id": "_vtype_encoding",
                "children": [
                  {
                    "title": "Unsupported vtype Values",
                    "id": "_unsupported_vtype_values",
                    "children": [],
                    "tags": [
                      "norm:vtype-vill_val",
                      "norm:vtype-vstart_op",
                      "norm:vtype-vill_val_vill",
                      "norm:vtype-vill_all_bits"
                    ]
                  }
                ],
                "tags": [
                  "norm:vtype_acc"
                ]
              },
              {
                "title": "AVL encoding",
                "id": "_avl_encoding",
                "children": [],
                "tags": [
                  "norm:vsetvl_op",
                  "norm:vsetvl_op_rs1_x0_rd_nx0",
                  "norm:vsetvl_op_rs1_x0_rd_x0",
                  "norm:vtype_vset_rsv",
                  "norm:reserved_vill_set",
                  "norm:vsetivli_op"
                ]
              },
              {
                "title": "Constraints on Setting vl",
                "id": "constraints-on-setting-vl",
                "children": [],
                "tags": [
                  "norm:vl_val_lead-in",
                  "norm:vl_val_list"
                ]
              },
              {
                "title": "Example of strip mining and changes to SEW",
                "id": "example-stripmine-sew",
                "children": [],
                "tags": []
              }
            ],
            "tags": [
              "norm:vset_op"
            ]
          },
          {
            "title": "Vector Loads and Stores",
            "id": "sec-vector-memory",
            "children": [
              {
                "title": "Vector Load/Store Instruction Encoding",
                "id": "_vector_loadstore_instruction_encoding",
                "children": [],
                "tags": [
                  "norm:vector_ls_strided_eew",
                  "norm:vector_ls_indexed_eew"
                ]
              },
              {
                "title": "Vector Load/Store Addressing Modes",
                "id": "_vector_loadstore_addressing_modes",
                "children": [],
                "tags": [
                  "norm:vector_ls_base_stride_regtype",
                  "norm:vector_ls_base",
                  "norm:vector_ls_unit-stride_op",
                  "norm:vector_ls_constant-stride_op",
                  "norm:vector_ls_indexed_op",
                  "norm:vector_ls_bytewise",
                  "norm:vector_ls_xlen_dep",
                  "norm:vector_ls_eew_rsv",
                  "norm:vector_ls_stride_ordered_op",
                  "norm:vector_ls_stride_unordered_op",
                  "norm:vector_ls_stride_unordered_precise",
                  "norm:vector_ls_nf_op",
                  "norm:vector_wholels_nf_op"
                ]
              },
              {
                "title": "Vector Load/Store Width Encoding",
                "id": "sec-vector-loadstore-width-encoding",
                "children": [],
                "tags": [
                  "norm:vector_ls_eew_emul",
                  "norm:vector_ls_emul_rsv",
                  "norm:vector_ls_emul_offgroup_rsv",
                  "norm:vector_ls_indexed_eew_emul",
                  "norm:vector_ls_ins_req",
                  "norm:vector_ls_ins_rsv",
                  "norm:vector_ls_mew_rsv"
                ]
              },
              {
                "title": "Vector Unit-Stride Instructions",
                "id": "_vector_unit_stride_instructions",
                "children": [],
                "tags": [
                  "norm:vector_ls_unit-stride_mask"
                ]
              },
              {
                "title": "Vector Constant-Stride Instructions",
                "id": "_vector_constant_stride_instructions",
                "children": [],
                "tags": [
                  "norm:vector_ls_neg_zero_stride",
                  "norm:vector_ls_constant-stride_unordered",
                  "norm:vector_ls_constant_stride_x0"
                ]
              },
              {
                "title": "Vector Indexed Instructions",
                "id": "_vector_indexed_instructions",
                "children": [],
                "tags": []
              },
              {
                "title": "Unit-stride Fault-Only-First Loads",
                "id": "_unit_stride_fault_only_first_loads",
                "children": [],
                "tags": [
                  "norm:vector_ff_trigger",
                  "norm:vector_ff_op",
                  "norm:vector_ls_overwrite_past_trap",
                  "norm:vector_ff_past_trap",
                  "norm:vector_ff_no_exception",
                  "norm:vector_ff_interrupt_behavior"
                ]
              },
              {
                "title": "Vector Load/Store Segment Instructions",
                "id": "sec-aos",
                "children": [
                  {
                    "title": "Vector Unit-Stride Segment Loads and Stores",
                    "id": "_vector_unit_stride_segment_loads_and_stores",
                    "children": [],
                    "tags": [
                      "norm:vector_ls_seg_unit-stride_op",
                      "norm:vector_ls_seg_unit-stride_vd_vs3",
                      "norm:vector_ls__seg_ff_unit-stride_op",
                      "norm:vector_ff_seg_partial_access",
                      "norm:vector_ls_seg_ff_overload"
                    ]
                  },
                  {
                    "title": "Vector Constant-Stride Segment Loads and Stores",
                    "id": "_vector_constant_stride_segment_loads_and_stores",
                    "children": [],
                    "tags": [
                      "norm:vector_ls_seg_constant-stride_op",
                      "norm:vector_ls_seg_constant-stride_unordered"
                    ]
                  },
                  {
                    "title": "Vector Indexed Segment Loads and Stores",
                    "id": "_vector_indexed_segment_loads_and_stores",
                    "children": [],
                    "tags": [
                      "norm:vector_ls_seg_indexed_op",
                      "norm:vector_ls_seg_indexed_unordered",
                      "norm:vector_ls_seg_indexed_eew_emul_op",
                      "norm:vector_ls_seg_indexed_emul_nfields_val",
                      "norm:vector_ls_seg_indexed_vreg_rsv"
                    ]
                  }
                ],
                "tags": [
                  "norm:nfields",
                  "norm:emul_nfields_rsv",
                  "norm:nfields_op",
                  "norm:vector_ls_seg_rsv",
                  "norm:vector_ls_seg_op",
                  "norm:vector_ls_seg_unordered",
                  "norm:vector_ls_seg_vstart_dep",
                  "norm:vector_ls_seg_partial_access"
                ]
              },
              {
                "title": "Vector Load/Store Whole Register Instructions",
                "id": "_vector_loadstore_whole_register_instructions",
                "children": [],
                "tags": [
                  "norm:vector_ls_seg_wholereg_eew",
                  "norm:vector_ls_seg_wholereg_op",
                  "norm:vector_ls_seg_wholereg_nf_rsv",
                  "norm:vector_ls_seg_wholereg_op_cont",
                  "norm:vector_ls_seg_wholereg_evl",
                  "norm:vector_ls_wholereg_missaligned_exception"
                ]
              }
            ],
            "tags": [
              "norm:vector_load_store_semantics",
              "norm:vector_masked_memory_access",
              "norm:vector_masked_inactive_behavior",
              "norm:vector_ls_vstart"
            ]
          },
          {
            "title": "Vector Memory Alignment Constraints",
            "id": "_vector_memory_alignment_constraints",
            "children": [],
            "tags": [
              "norm:vector_ls_missaligned_exception",
              "norm:vector_ls_scalar_missaligned_independence",
              "norm:vector_ls_scalar_missaligned_dependence"
            ]
          },
          {
            "title": "Vector Memory Consistency Model",
            "id": "_vector_memory_consistency_model",
            "children": [],
            "tags": [
              "norm:vector_ls_program_order",
              "norm:vector_ls_rvwmo",
              "norm:vector_ls_rvtso",
              "norm:vector_ls_indexed-ordered_ordered",
              "norm:vector_ls_indexed-ordered_rvwmo",
              "norm:vl_control_dependency",
              "norm:vmask_control_dependency"
            ]
          },
          {
            "title": "Vector Arithmetic Instruction Formats",
            "id": "_vector_arithmetic_instruction_formats",
            "children": [
              {
                "title": "Vector Arithmetic Instruction encoding",
                "id": "sec-arithmetic-encoding",
                "children": [],
                "tags": [
                  "norm:V_fp_frm",
                  "norm:V_inv_frm_rsv",
                  "norm:vop-vv_vreg_vs2_vs1",
                  "norm:vop-vx_vop-vi_vreg_vs2",
                  "norm:vop-vi_imm_5bit",
                  "norm:vop-vx_xreg_rs1",
                  "norm:vop-vx_rs1_trunc_lsb_sewbits",
                  "norm:vop-vx_rs1_sext_sewbits",
                  "norm:vfop_freg",
                  "norm:vfop_freg_NaNbox_lsb_sewbits",
                  "norm:V_fp_eew_rsv",
                  "norm:V_Zinx_fp_scalar",
                  "norm:V_masked"
                ]
              },
              {
                "title": "Widening Vector Arithmetic Instructions",
                "id": "sec-widening",
                "children": [],
                "tags": [
                  "norm:vwop_vd_eew_emul"
                ]
              },
              {
                "title": "Narrowing Vector Arithmetic Instructions",
                "id": "sec-narrowing",
                "children": [],
                "tags": [
                  "norm:vnop_vd_vs2_eew_emul",
                  "norm:vnop_vs1_eew_emul"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Vector Integer Arithmetic Instructions",
            "id": "sec-vector-integer",
            "children": [
              {
                "title": "Vector Single-Width Integer Add and Subtract",
                "id": "_vector_single_width_integer_add_and_subtract",
                "children": [],
                "tags": [
                  "norm:vadd_vsub_op",
                  "norm:vrsub_op"
                ]
              },
              {
                "title": "Vector Widening Integer Add/Subtract",
                "id": "_vector_widening_integer_addsubtract",
                "children": [],
                "tags": [
                  "norm:vwaddu_vwadd_vwsubu_vwsub_op"
                ]
              },
              {
                "title": "Vector Integer Extension",
                "id": "_vector_integer_extension",
                "children": [],
                "tags": [
                  "norm:vsext_vzext_op",
                  "norm:vsext_vzext_vs_eew_emul",
                  "norm:vsext_vzext_vd_eew_emul",
                  "norm:vsext_vzext_ill_eew_emul_rsv"
                ]
              },
              {
                "title": "Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions",
                "id": "_vector_integer_add_with_carry_subtract_with_borrow_instructions",
                "children": [],
                "tags": [
                  "norm:vmadc_vmsbc_vadc_vsbc_carry_v0",
                  "norm:vadc_vsbc_op",
                  "norm:vadc_vsbc_masked_write_all_elem",
                  "norm:vadc_vsbc_unmasked_rsv",
                  "norm:vmadc_vmsbc_op_masked",
                  "norm:vmadc_vmsbc_op_unmasked",
                  "norm:vmadc_vmsbc_masked_write_all_elem",
                  "norm:vmadc_vmsbc_tail_agnostic",
                  "norm:vmsbc_borrow_neg",
                  "norm:vadc_vsbc_vd_v0_rsv"
                ]
              },
              {
                "title": "Vector Bitwise Logical Instructions",
                "id": "_vector_bitwise_logical_instructions",
                "children": [],
                "tags": [
                  "norm:vand_vor_vxor_op"
                ]
              },
              {
                "title": "Vector Single-Width Shift Instructions",
                "id": "_vector_single_width_shift_instructions",
                "children": [],
                "tags": [
                  "norm:vsll_vsrl_vsra_op",
                  "norm:vsll_vsrl_vsra_shamt"
                ]
              },
              {
                "title": "Vector Narrowing Integer Right Shift Instructions",
                "id": "_vector_narrowing_integer_right_shift_instructions",
                "children": [],
                "tags": [
                  "norm:vnsrl_vnsra_op",
                  "norm:vnsrl_vnsra_shamt"
                ]
              },
              {
                "title": "Vector Integer Compare Instructions",
                "id": "_vector_integer_compare_instructions",
                "children": [],
                "tags": [
                  "norm:vmseq_vmsne_vmsltu_vmslt_vmsleu_vmsle_vmsgtu_vmsgt_op",
                  "norm:vmseq_vmsne_vmsltu_vmslt_vmsleu_vmsle_vmsgtu_vmsgt_vd_v0_legal",
                  "norm:vmseq_vmsne_vmsltu_vmslt_vmsleu_vmsle_vmsgtu_vmsgt_maskundisturbed",
                  "norm:vmseq_vmsne_vmsltu_vmslt_vmsleu_vmsle_vmsgtu_vmsgt_tail_agnostic"
                ]
              },
              {
                "title": "Vector Integer Min/Max Instructions",
                "id": "_vector_integer_minmax_instructions",
                "children": [],
                "tags": [
                  "norm:vminu_vmin_vmaxu_vmax_op"
                ]
              },
              {
                "title": "Vector Single-Width Integer Multiply Instructions",
                "id": "_vector_single_width_integer_multiply_instructions",
                "children": [],
                "tags": [
                  "norm:vmul_vmulh_vmulhu_vmulhsu_op"
                ]
              },
              {
                "title": "Vector Integer Divide Instructions",
                "id": "_vector_integer_divide_instructions",
                "children": [],
                "tags": [
                  "norm:vdivu_vdiv_vremu_vrem_op"
                ]
              },
              {
                "title": "Vector Widening Integer Multiply Instructions",
                "id": "_vector_widening_integer_multiply_instructions",
                "children": [],
                "tags": [
                  "norm:vwmul_wmulu_vwmulsu_op"
                ]
              },
              {
                "title": "Vector Single-Width Integer Multiply-Add Instructions",
                "id": "_vector_single_width_integer_multiply_add_instructions",
                "children": [],
                "tags": [
                  "norm:vmacc_vnmsac_vmadd_vnmsub_op",
                  "norm:vmacc_vnmsac_vmadd_vnmsub_op_lowhalf"
                ]
              },
              {
                "title": "Vector Widening Integer Multiply-Add Instructions",
                "id": "_vector_widening_integer_multiply_add_instructions",
                "children": [],
                "tags": [
                  "norm:vwmaccu_vwmacc_vwmaccsu_vwmaccus_op"
                ]
              },
              {
                "title": "Vector Integer Merge Instructions",
                "id": "_vector_integer_merge_instructions",
                "children": [],
                "tags": [
                  "norm:vmerge_op",
                  "norm:vmerge_all_elem",
                  "norm:vmerge_op_mask"
                ]
              },
              {
                "title": "Vector Integer Move Instructions",
                "id": "_vector_integer_move_instructions",
                "children": [],
                "tags": [
                  "norm:vmv_op",
                  "norm:vmv_vs2_nv0_rsv"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Vector Fixed-Point Arithmetic Instructions",
            "id": "sec-vector-fixed-point",
            "children": [
              {
                "title": "Vector Single-Width Saturating Add and Subtract",
                "id": "_vector_single_width_saturating_add_and_subtract",
                "children": [],
                "tags": [
                  "norm:vsaddu_vsadd_vssubu_vssub_op",
                  "norm:vsaddu_vsadd_vssubu_vssub_op_overflow_vxsat_op_vsaddsub"
                ]
              },
              {
                "title": "Vector Single-Width Averaging Add and Subtract",
                "id": "_vector_single_width_averaging_add_and_subtract",
                "children": [],
                "tags": [
                  "norm:vaaddu_vaadd_vasubu_vasub_op",
                  "norm:vasub_vasubu_op_overflow"
                ]
              },
              {
                "title": "Vector Single-Width Fractional Multiply with Rounding and Saturation",
                "id": "_vector_single_width_fractional_multiply_with_rounding_and_saturation",
                "children": [],
                "tags": [
                  "norm:vsmul_op",
                  "norm:vxsat_op_vsmul"
                ]
              },
              {
                "title": "Vector Single-Width Scaling Shift Instructions",
                "id": "_vector_single_width_scaling_shift_instructions",
                "children": [],
                "tags": [
                  "norm:vssrl_vssra_op",
                  "norm:vssrl_vssra_shamt"
                ]
              },
              {
                "title": "Vector Narrowing Fixed-Point Clip Instructions",
                "id": "_vector_narrowing_fixed_point_clip_instructions",
                "children": [],
                "tags": [
                  "norm:vnclipu_vnclip_op",
                  "norm:vnclipu_vnclip_shamt",
                  "norm:vnclipu_vnclip_rounding",
                  "norm:vnclipu_overflow",
                  "norm:vnclip_overflow",
                  "norm:vxsat_op_vnclip_u"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Vector Floating-Point Instructions",
            "id": "sec-vector-float",
            "children": [
              {
                "title": "Vector Floating-Point Exception Flags",
                "id": "_vector_floating_point_exception_flags",
                "children": [],
                "tags": [
                  "norm:fflags_op_V_fp"
                ]
              },
              {
                "title": "Vector Single-Width Floating-Point Add/Subtract Instructions",
                "id": "_vector_single_width_floating_point_addsubtract_instructions",
                "children": [],
                "tags": [
                  "norm:vfadd_vfsub_vfrsub_op"
                ]
              },
              {
                "title": "Vector Widening Floating-Point Add/Subtract Instructions",
                "id": "_vector_widening_floating_point_addsubtract_instructions",
                "children": [],
                "tags": [
                  "norm:vfwadd_op"
                ]
              },
              {
                "title": "Vector Single-Width Floating-Point Multiply/Divide Instructions",
                "id": "_vector_single_width_floating_point_multiplydivide_instructions",
                "children": [],
                "tags": [
                  "norm:vfmul_vfdiv_vfrdiv_op"
                ]
              },
              {
                "title": "Vector Widening Floating-Point Multiply",
                "id": "_vector_widening_floating_point_multiply",
                "children": [],
                "tags": [
                  "norm:vfwmul_op"
                ]
              },
              {
                "title": "Vector Single-Width Floating-Point Fused Multiply-Add Instructions",
                "id": "_vector_single_width_floating_point_fused_multiply_add_instructions",
                "children": [],
                "tags": [
                  "norm:vfmacc_vfnmacc_vfmsac_vfnmsac_vfmadd_vfnmadd_vfmsub_vfnmsub_op"
                ]
              },
              {
                "title": "Vector Widening Floating-Point Fused Multiply-Add Instructions",
                "id": "_vector_widening_floating_point_fused_multiply_add_instructions",
                "children": [],
                "tags": [
                  "norm:vfwmacc_vfwnmacc_vfwmsac_vfwnmsac_op"
                ]
              },
              {
                "title": "Vector Floating-Point Square-Root Instruction",
                "id": "_vector_floating_point_square_root_instruction",
                "children": [],
                "tags": [
                  "norm:vfsqrt_op"
                ]
              },
              {
                "title": "Vector Floating-Point Reciprocal Square-Root Estimate Instruction",
                "id": "_vector_floating_point_reciprocal_square_root_estimate_instruction",
                "children": [],
                "tags": [
                  "norm:vfrsqrt7_op",
                  "norm:vfrsqrt7_op_unex",
                  "norm:vfrsqrt7_op_precise"
                ]
              },
              {
                "title": "Vector Floating-Point Reciprocal Estimate Instruction",
                "id": "_vector_floating_point_reciprocal_estimate_instruction",
                "children": [],
                "tags": [
                  "norm:vfrec7_op",
                  "norm:vfrec7_op_unex",
                  "norm:vfrec7_op_precise",
                  "norm:vfrec7_op_subnorm",
                  "norm:vfrec7_op_output"
                ]
              },
              {
                "title": "Vector Floating-Point MIN/MAX Instructions",
                "id": "_vector_floating_point_minmax_instructions",
                "children": [],
                "tags": [
                  "norm:vfmin_vfmax_op"
                ]
              },
              {
                "title": "Vector Floating-Point Sign-Injection Instructions",
                "id": "_vector_floating_point_sign_injection_instructions",
                "children": [],
                "tags": [
                  "norm:vfsgnj_vfsgnjn_vfsgnjx_op"
                ]
              },
              {
                "title": "Vector Floating-Point Compare Instructions",
                "id": "_vector_floating_point_compare_instructions",
                "children": [],
                "tags": [
                  "norm:vmfeq_vmfne_vmflt_vmfle_vmfgt_vmfge_op",
                  "norm:vmfeq_vmfne_vmflt_vmfle_vmfgt_vmfge_vd_single_vreg",
                  "norm:vmfeq_vmfne_vmflt_vmfle_vmfgt_vmfge_vd_eq_v0",
                  "norm:vmfeq_vmfne_vmflt_vmfle_vmfgt_vmfge_tail_agnostic",
                  "norm:vmfeq_vmfne_sNaN_invalid",
                  "norm:vmflt_vmfle_vmfgt_vmfge_sqNaN_invalid",
                  "norm:vmfne_vdval1_NaN",
                  "norm:vmfeq_vmflt_vmfle_vmfgt_vmfge_vdval0_NaN"
                ]
              },
              {
                "title": "Vector Floating-Point Classify Instruction",
                "id": "_vector_floating_point_classify_instruction",
                "children": [],
                "tags": [
                  "norm:vfclass_op",
                  "norm:vfclass_op_result",
                  "norm:vfclass_SEWge16"
                ]
              },
              {
                "title": "Vector Floating-Point Merge Instruction",
                "id": "_vector_floating_point_merge_instruction",
                "children": [],
                "tags": [
                  "norm:vfmerge_op",
                  "norm:vfmerge_all_elem",
                  "norm:vfmerge_op_mask"
                ]
              },
              {
                "title": "Vector Floating-Point Move Instruction",
                "id": "_vector_floating_point_move_instruction",
                "children": [],
                "tags": [
                  "norm:vfmv_op",
                  "norm:vfmv_vs2_nv0_rsv"
                ]
              },
              {
                "title": "Single-Width Floating-Point/Integer Type-Convert Instructions",
                "id": "_single_width_floating_pointinteger_type_convert_instructions",
                "children": [],
                "tags": [
                  "norm:vfcvt_op",
                  "norm:vfcvt_op_exceptions",
                  "norm:vfcvt_op_frm"
                ]
              },
              {
                "title": "Widening Floating-Point/Integer Type-Convert Instructions",
                "id": "_widening_floating_pointinteger_type_convert_instructions",
                "children": [],
                "tags": [
                  "norm:vfwcvt_op",
                  "norm:vfwcvt_vreg_constr"
                ]
              },
              {
                "title": "Narrowing Floating-Point/Integer Type-Convert Instructions",
                "id": "_narrowing_floating_pointinteger_type_convert_instructions",
                "children": [],
                "tags": [
                  "norm:vfncvt_op",
                  "norm:vfncvt_vreg_constr"
                ]
              }
            ],
            "tags": [
              "norm:V_fp_EEW_IEEE_nsupported_rsv",
              "norm:Vf_requrires_Vx",
              "norm:mstatus-FS_off_V_fp_ill",
              "norm:mstatus-FS_dirty_V_fp",
              "norm:vsstatus_mstatus-FS_off_hypervisor_V_fp_ill",
              "norm:vsstatus_mstatus-FS_dirty_hypervisor_V_fp"
            ]
          },
          {
            "title": "Vector Reduction Operations",
            "id": "_vector_reduction_operations",
            "children": [
              {
                "title": "Vector Single-Width Integer Reduction Instructions",
                "id": "sec-vector-integer-reduce",
                "children": [],
                "tags": [
                  "norm:vredsum_vredmaxu_vredmax_vredminu_vredmin_vredand_vredor_vredxor_op",
                  "norm:vredsum_vredmaxu_vredmax_vredminu_vredmin_vredand_vredor_vredxor_overflow"
                ]
              },
              {
                "title": "Vector Widening Integer Reduction Instructions",
                "id": "sec-vector-integer-reduce-widen",
                "children": [],
                "tags": [
                  "norm:vwredsumu_op",
                  "norm:vwredsum_op",
                  "norm:vwredsumu_vwredsum_op_overflow"
                ]
              },
              {
                "title": "Vector Single-Width Floating-Point Reduction Instructions",
                "id": "sec-vector-float-reduce",
                "children": [
                  {
                    "title": "Vector Ordered Single-Width Floating-Point Sum Reduction",
                    "id": "_vector_ordered_single_width_floating_point_sum_reduction",
                    "children": [],
                    "tags": [
                      "norm:vfredosum_op",
                      "norm:vfredosum_op_exceptions",
                      "norm:vfredosum_maskoff"
                    ]
                  },
                  {
                    "title": "Vector Unordered Single-Width Floating-Point Sum Reduction",
                    "id": "_vector_unordered_single_width_floating_point_sum_reduction",
                    "children": [],
                    "tags": [
                      "norm:vfredusum_op",
                      "norm:vfredusum_additive_impl",
                      "norm:vfredusum_redtree"
                    ]
                  },
                  {
                    "title": "Vector Single-Width Floating-Point Max and Min Reductions",
                    "id": "_vector_single_width_floating_point_max_and_min_reductions",
                    "children": [],
                    "tags": [
                      "norm:vfredmin_vfredmax_op"
                    ]
                  }
                ],
                "tags": []
              },
              {
                "title": "Vector Widening Floating-Point Reduction Instructions",
                "id": "sec-vector-float-reduce-widen",
                "children": [],
                "tags": [
                  "norm:vfwredosum_vfwredusum_op",
                  "norm:vfwredosum_vfwredusum_op_reduction"
                ]
              }
            ],
            "tags": [
              "norm:vreduction_scalar_def",
              "norm:vreduction_scalar_disregard_LMUL",
              "norm:vreduction_vd_overlap_vs",
              "norm:vreduction_scalar_disregard_maskval",
              "norm:vreduction_tail_policy",
              "norm:vreduction_vl_0",
              "norm:vreduction_trap",
              "norm:vreduction_vstart_n0_ill"
            ]
          },
          {
            "title": "Vector Mask Instructions",
            "id": "sec-vector-mask",
            "children": [
              {
                "title": "Vector Mask-Register Logical Instructions",
                "id": "sec-mask-register-logical",
                "children": [],
                "tags": [
                  "norm:vmask_maskreg_def",
                  "norm:instrgrp_vmask_disregard_vlmul",
                  "norm:vmask_vd_overlap_vs",
                  "norm:vmask_vstart",
                  "norm:vmasklogical_unmasked",
                  "norm:vmasklogical_masked_rsv",
                  "norm:vmasklogical_tail_agnostic",
                  "norm:vmand_vmnand_vmandn_vmxor_vmor_vmnor_vmorn_vmxnor_op"
                ]
              },
              {
                "title": "Vector count population in mask vcpop.m",
                "id": "_vector_count_population_in_mask_vcpop_m",
                "children": [],
                "tags": [
                  "norm:vcpop_vs_single_vreg",
                  "norm:vcpop_op",
                  "norm:vcpop_op_mask",
                  "norm:vcpop_vl0",
                  "norm:vcpop_trap",
                  "norm:vcpop_vstart_n0_ill"
                ]
              },
              {
                "title": "vfirst find-first-set mask bit",
                "id": "_vfirst_find_first_set_mask_bit",
                "children": [],
                "tags": [
                  "norm:vfirst_op",
                  "norm:vfirst_vl0",
                  "norm:vfirst_trap",
                  "norm:vfirst_vstart_n0_ill"
                ]
              },
              {
                "title": "vmsbf.m set-before-first mask bit",
                "id": "_vmsbf_m_set_before_first_mask_bit",
                "children": [],
                "tags": [
                  "norm:vmsbf_op",
                  "norm:vmsbf_tail_agnostic",
                  "norm:vmsbf_trap",
                  "norm:vmsbf_vstart_n0_ill",
                  "norm:vmsbf_vreg_constr"
                ]
              },
              {
                "title": "vmsif.m set-including-first mask bit",
                "id": "_vmsif_m_set_including_first_mask_bit",
                "children": [],
                "tags": [
                  "norm:vmsif_op",
                  "norm:vmsif_tail_agnostic",
                  "norm:vmsif_trap",
                  "norm:vmsif_vstart_n0_ill",
                  "norm:vmsif_vreg_constr"
                ]
              },
              {
                "title": "vmsof.m set-only-first mask bit",
                "id": "_vmsof_m_set_only_first_mask_bit",
                "children": [],
                "tags": [
                  "norm:vmsof_op",
                  "norm:vmsof_tail_agnostic",
                  "norm:vmsof_trap",
                  "norm:vmsof_vstart_n0_ill",
                  "norm:vmsof_vreg_constr"
                ]
              },
              {
                "title": "Example using vector mask instructions",
                "id": "_example_using_vector_mask_instructions",
                "children": [],
                "tags": []
              },
              {
                "title": "Vector Iota Instruction",
                "id": "_vector_iota_instruction",
                "children": [],
                "tags": [
                  "norm:viota_op",
                  "norm:viota_op_masked",
                  "norm:viota_op_zext",
                  "norm:viota_op_overflow",
                  "norm:viota_trap",
                  "norm:viota_restart",
                  "norm:viota_vstart_n0_ill",
                  "norm:viota_vreg_constr"
                ]
              },
              {
                "title": "Vector Element Index Instruction",
                "id": "_vector_element_index_instruction",
                "children": [],
                "tags": [
                  "norm:vid_op",
                  "norm:vid_op_mask",
                  "norm:vid_vs2_nv0_rsv",
                  "norm:vid_op_zext",
                  "norm:vid_op_overflow"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Vector Permutation Instructions",
            "id": "sec-vector-permute",
            "children": [
              {
                "title": "Integer Scalar Move Instructions",
                "id": "_integer_scalar_move_instructions",
                "children": [],
                "tags": [
                  "norm:vmv-x-s_vmv-s-x_ignoreLMUL",
                  "norm:vmv-x-s_op",
                  "norm:vmv-x-s_vstartgevl_vl0",
                  "norm:vmv-s-x_op",
                  "norm:vmv-s-x_vstart_ge_vl",
                  "norm:vmv-s-x_vmv-x-s_masked_rsv"
                ]
              },
              {
                "title": "Floating-Point Scalar Move Instructions",
                "id": "sec-vector-float-move",
                "children": [],
                "tags": [
                  "norm:vfmv-f-s_vfmv-s-f_ignoreLMUL",
                  "norm:vfmv-f-s_op",
                  "norm:vfmv-s-f_op",
                  "norm:vfmv-s-f_vstart_ge_vl",
                  "norm:vfmv-s-f_masked_rsv"
                ]
              },
              {
                "title": "Vector Slide Instructions",
                "id": "_vector_slide_instructions",
                "children": [
                  {
                    "title": "Vector Slide-up Instructions",
                    "id": "_vector_slide_up_instructions",
                    "children": [],
                    "tags": [
                      "norm:vslideup_op",
                      "norm:vslideup_vreg_constr"
                    ]
                  },
                  {
                    "title": "Vector Slide-down Instructions",
                    "id": "_vector_slide_down_instructions",
                    "children": [],
                    "tags": [
                      "norm:vslidedown_op",
                      "norm:vslidedown_op_src"
                    ]
                  },
                  {
                    "title": "Vector Slide-1-up",
                    "id": "_vector_slide_1_up",
                    "children": [],
                    "tags": [
                      "norm:vslide1up-vx_op",
                      "norm:vslide1up-vx_op_rem_elem",
                      "norm:vslide1up-vx_op_vl",
                      "norm:vslide1up-vx_vreg_constr"
                    ]
                  },
                  {
                    "title": "Vector Floating-Point Slide-1-up Instruction",
                    "id": "sec-vfslide1up",
                    "children": [],
                    "tags": [
                      "norm:vslide1up-vf_op"
                    ]
                  },
                  {
                    "title": "Vector Slide-1-down Instruction",
                    "id": "_vector_slide_1_down_instruction",
                    "children": [],
                    "tags": [
                      "norm:vslide1down-vx_op",
                      "norm:vslide1down-vx_op_vl",
                      "norm:vslide1down-vx_op_details"
                    ]
                  },
                  {
                    "title": "Vector Floating-Point Slide-1-down Instruction",
                    "id": "sec-vfslide1down",
                    "children": [],
                    "tags": [
                      "norm:vslide1down-vf_op"
                    ]
                  }
                ],
                "tags": [
                  "norm:vslide_vstart_ge_vl",
                  "norm:vslide_mask"
                ]
              },
              {
                "title": "Vector Register Gather Instructions",
                "id": "_vector_register_gather_instructions",
                "children": [],
                "tags": [
                  "norm:vrgather_vrgatherei16_vs2_uint",
                  "norm:vrgather_vrgatherei16_vs_ignore_vl",
                  "norm:vrgather_vrgatherei16_vl",
                  "norm:vrgather_vrgatherei16_tail",
                  "norm:vrgather_vrgatherei16_mask",
                  "norm:vrgather-vv_op_vrgatherei16-vv_op",
                  "norm:vrgather-vv_sew_lmul",
                  "norm:vrgatherei16-vv_sew_lmul",
                  "norm:vrgather_vrgatherei16_id_ge_VLMAX",
                  "norm:vrgather-vx_vrgather-vi_op",
                  "norm:vrgather_vrgatherei16_vreg_constr"
                ]
              },
              {
                "title": "Vector Compress Instruction",
                "id": "_vector_compress_instruction",
                "children": [
                  {
                    "title": "Synthesizing vdecompress",
                    "id": "_synthesizing_vdecompress",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": [
                  "norm:vcompress_op",
                  "norm:vcompress_enc",
                  "norm:vcompress_masked_rsv",
                  "norm:vcompress_vreg_constr",
                  "norm:vcompress_trap",
                  "norm:vcompress_vstart_n0_ill"
                ]
              },
              {
                "title": "Whole Vector Register Move",
                "id": "_whole_vector_register_move",
                "children": [],
                "tags": [
                  "norm:vmv-nr-r_op",
                  "norm:vmv-nr-r_enc",
                  "norm:vmv-nr-r_nreg_rsv",
                  "norm:vmv-nr-r_vreg_constr",
                  "norm:vmv-nr-r_unaligned_rsv"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Exception Handling",
            "id": "_exception_handling",
            "children": [
              {
                "title": "Precise vector traps",
                "id": "_precise_vector_traps",
                "children": [],
                "tags": []
              },
              {
                "title": "Imprecise vector traps",
                "id": "_imprecise_vector_traps",
                "children": [],
                "tags": []
              },
              {
                "title": "Selectable precise/imprecise traps",
                "id": "_selectable_preciseimprecise_traps",
                "children": [],
                "tags": []
              },
              {
                "title": "Swappable traps",
                "id": "_swappable_traps",
                "children": [],
                "tags": []
              }
            ],
            "tags": [
              "norm:epc_vstart_op_V_trap"
            ]
          },
          {
            "title": "Standard Vector Extensions",
            "id": "sec-vector-extensions",
            "children": [
              {
                "title": "Zvl*: Minimum Vector Length Standard Extensions",
                "id": "_zvl_minimum_vector_length_standard_extensions",
                "children": [],
                "tags": []
              },
              {
                "title": "Zve*: Vector Extensions for Embedded Processors",
                "id": "_zve_vector_extensions_for_embedded_processors",
                "children": [],
                "tags": [
                  "norm:Zve_XLEN",
                  "norm:Zve32f_Zve64x_dependent_Zve32x",
                  "norm:Zve64f_dependent_Zve32f_Zve64x",
                  "norm:Zve64d_dependent_Zve64f",
                  "norm:Zve_precise_traps",
                  "norm:Zve_eew",
                  "norm:Zve_nsupport_eew64_xlen32",
                  "norm:Zve64_eew64_nsupport_vmulh",
                  "norm:Zve64_eew64_nsupport_vsmul",
                  "norm:Zve32x_Zve64x_nsupport_freg",
                  "norm:Zve32x_dependent_Zicsr",
                  "norm:Zve32f_Zve64f_dependent_F"
                ]
              },
              {
                "title": "V: Vector Extension for Application Processors",
                "id": "_v_vector_extension_for_application_processors",
                "children": [],
                "tags": [
                  "norm:misa-V_op",
                  "norm:V_precise_traps",
                  "norm:V_dependent_Zvl128b_Zve64d",
                  "norm:V_supported_eew",
                  "norm:V_instr_config",
                  "norm:V_instr_ls_eew64_nsupported_xlen32",
                  "norm:V_instr_int",
                  "norm:V_instr_fixedpt",
                  "norm:V_instr_red",
                  "norm:V_instr_mask",
                  "norm:V_instr_perm",
                  "norm:V_dependent_F_D"
                ]
              },
              {
                "title": "Zvfhmin: Vector Extension for Minimal Half-Precision Floating-Point",
                "id": "_zvfhmin_vector_extension_for_minimal_half_precision_floating_point",
                "children": [],
                "tags": [
                  "norm:Zvfhmin_dependent_Zve32f"
                ]
              },
              {
                "title": "Zvfh: Vector Extension for Half-Precision Floating-Point",
                "id": "_zvfh_vector_extension_for_half_precision_floating_point",
                "children": [],
                "tags": [
                  "norm:Zvfh_instr",
                  "norm:Zvfh_eew16",
                  "norm:Zvfh_instr_cvt",
                  "norm:Zvfh_dependent_Zve32f_Zfhmin"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Vector Element Groups",
            "id": "vector-element-groups",
            "children": [
              {
                "title": "Element Group Size",
                "id": "_element_group_size",
                "children": [],
                "tags": [
                  "norm:egs_ge_vlmax_rsv"
                ]
              },
              {
                "title": "Setting vl",
                "id": "_setting_vl",
                "children": [],
                "tags": [
                  "norm:egs_vl_rsv",
                  "norm:egs_vl_avl"
                ]
              },
              {
                "title": "Determining EEW",
                "id": "_determining_eew",
                "children": [],
                "tags": [
                  "norm:egs_sew_eew"
                ]
              },
              {
                "title": "Determining EMUL",
                "id": "_determining_emul",
                "children": [],
                "tags": [
                  "norm:egs_lmul_emul"
                ]
              },
              {
                "title": "Element Group Width",
                "id": "_element_group_width",
                "children": [],
                "tags": [
                  "norm:egs_egw"
                ]
              },
              {
                "title": "Masking",
                "id": "_masking",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Vector Instruction Listing",
            "id": "_vector_instruction_listing",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Cryptography Extensions: Scalar &amp; Entropy Source Instructions, Version 1.0.1",
        "id": "crypto_scalar_instructions",
        "children": [
          {
            "title": "Introduction",
            "id": "crypto_scalar_introduction",
            "children": [
              {
                "title": "Intended Audience",
                "id": "crypto_scalar_audience",
                "children": [],
                "tags": []
              },
              {
                "title": "Sail Specifications",
                "id": "crypto_scalar_sail_specifications",
                "children": [],
                "tags": []
              },
              {
                "title": "Policies",
                "id": "crypto_scalar_policies",
                "children": [],
                "tags": []
              }
            ],
            "tags": [
              "norm:zk_scalar_xreg_op"
            ]
          },
          {
            "title": "Extensions Overview",
            "id": "crypto_scalar_extensions",
            "children": [
              {
                "title": "Zbkb - Bitmanip instructions for Cryptography",
                "id": "zbkb-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "Zbkc - Carry-less multiply instructions",
                "id": "zbkc-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "Zbkx - Crossbar permutation instructions",
                "id": "zbkx-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "Zknd - NIST Suite: AES Decryption",
                "id": "zknd",
                "children": [],
                "tags": [
                  "norm:zknd_shared_instr"
                ]
              },
              {
                "title": "Zkne - NIST Suite: AES Encryption",
                "id": "zkne",
                "children": [],
                "tags": [
                  "norm:zkne_shared_instr"
                ]
              },
              {
                "title": "Zknh - NIST Suite: Hash Function Instructions",
                "id": "zknh",
                "children": [],
                "tags": []
              },
              {
                "title": "Zksed - ShangMi Suite: SM4 Block Cipher Instructions",
                "id": "zksed",
                "children": [],
                "tags": []
              },
              {
                "title": "Zksh - ShangMi Suite: SM3 Hash Function Instructions",
                "id": "zksh",
                "children": [],
                "tags": []
              },
              {
                "title": "Zkr - Entropy Source Extension",
                "id": "zkr",
                "children": [],
                "tags": [
                  "norm:zkr_seed_addr"
                ]
              },
              {
                "title": "Zkn - NIST Algorithm Suite",
                "id": "zkn",
                "children": [],
                "tags": [
                  "norm:zkn_impl_all"
                ]
              },
              {
                "title": "Zks - ShangMi Algorithm Suite",
                "id": "zks",
                "children": [],
                "tags": [
                  "norm:zks_impl_all"
                ]
              },
              {
                "title": "Zk - Standard scalar cryptography extension",
                "id": "zk",
                "children": [],
                "tags": [
                  "norm:zk_impl_all"
                ]
              },
              {
                "title": "Zkt - Data Independent Execution Latency",
                "id": "_zkt_data_independent_execution_latency",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Instructions",
            "id": "crypto_scalar_insns",
            "children": [
              {
                "title": "aes32dsi",
                "id": "insns-aes32dsi",
                "children": [],
                "tags": [
                  "norm:aes32dsi_enc",
                  "norm:aes32dsi_op"
                ]
              },
              {
                "title": "aes32dsmi",
                "id": "insns-aes32dsmi",
                "children": [],
                "tags": [
                  "norm:aes32dsmi_enc",
                  "norm:aes32dsmi_op"
                ]
              },
              {
                "title": "aes32esi",
                "id": "insns-aes32esi",
                "children": [],
                "tags": [
                  "norm:aes32esi_enc",
                  "norm:aes32esi_op"
                ]
              },
              {
                "title": "aes32esmi",
                "id": "insns-aes32esmi",
                "children": [],
                "tags": [
                  "norm:aes32esmi_enc",
                  "norm:aes32esmi_op"
                ]
              },
              {
                "title": "aes64ds",
                "id": "insns-aes64ds",
                "children": [],
                "tags": [
                  "norm:aes64ds_enc",
                  "norm:aes64ds_op"
                ]
              },
              {
                "title": "aes64dsm",
                "id": "insns-aes64dsm",
                "children": [],
                "tags": [
                  "norm:aes64dsm_enc",
                  "norm:aes64dsm_op"
                ]
              },
              {
                "title": "aes64es",
                "id": "insns-aes64es",
                "children": [],
                "tags": [
                  "norm:aes64es_enc",
                  "norm:aes64es_op"
                ]
              },
              {
                "title": "aes64esm",
                "id": "insns-aes64esm",
                "children": [],
                "tags": [
                  "norm:aes64esm_enc",
                  "norm:aes64esm_op"
                ]
              },
              {
                "title": "aes64im",
                "id": "insns-aes64im",
                "children": [],
                "tags": [
                  "norm:aes64im_enc",
                  "norm:aes64im_op"
                ]
              },
              {
                "title": "aes64ks1i",
                "id": "insns-aes64ks1i",
                "children": [],
                "tags": [
                  "norm:aes64ks1i_enc",
                  "norm:aes64ks1i_op"
                ]
              },
              {
                "title": "aes64ks2",
                "id": "insns-aes64ks2",
                "children": [],
                "tags": [
                  "norm:aes64ks2_enc",
                  "norm:aes64ks2_op"
                ]
              },
              {
                "title": "andn",
                "id": "insns-andn-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "brev8",
                "id": "insns-brev8-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "clmul",
                "id": "insns-clmul-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "clmulh",
                "id": "insns-clmulh-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "orn",
                "id": "insns-orn-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "pack",
                "id": "insns-pack-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "packh",
                "id": "insns-packh-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "packw",
                "id": "insns-packw-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "rev8",
                "id": "insns-rev8-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "rol",
                "id": "insns-rol-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "rolw",
                "id": "insns-rolw-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "ror",
                "id": "insns-ror-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "rori",
                "id": "insns-rori-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "roriw",
                "id": "insns-roriw-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "rorw",
                "id": "insns-rorw-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "sha256sig0",
                "id": "insns-sha256sig0",
                "children": [],
                "tags": [
                  "norm:sha256sig0_enc",
                  "norm:sha256sig0_op"
                ]
              },
              {
                "title": "sha256sig1",
                "id": "insns-sha256sig1",
                "children": [],
                "tags": [
                  "norm:sha256sig1_enc",
                  "norm:sha256sig1_op"
                ]
              },
              {
                "title": "sha256sum0",
                "id": "insns-sha256sum0",
                "children": [],
                "tags": [
                  "norm:sha256sum0_enc",
                  "norm:sha256sum0_op"
                ]
              },
              {
                "title": "sha256sum1",
                "id": "insns-sha256sum1",
                "children": [],
                "tags": [
                  "norm:sha256sum1_enc",
                  "norm:sha256sum1_op"
                ]
              },
              {
                "title": "sha512sig0h",
                "id": "insns-sha512sig0h",
                "children": [],
                "tags": [
                  "norm:sha512sig0h_enc",
                  "norm:sha512sig0h_op"
                ]
              },
              {
                "title": "sha512sig0l",
                "id": "insns-sha512sig0l",
                "children": [],
                "tags": [
                  "norm:sha512sig0l_enc",
                  "norm:sha512sig0l_op"
                ]
              },
              {
                "title": "sha512sig1h",
                "id": "insns-sha512sig1h",
                "children": [],
                "tags": [
                  "norm:sha512sig1h_enc",
                  "norm:sha512sig1h_op"
                ]
              },
              {
                "title": "sha512sig1l",
                "id": "insns-sha512sig1l",
                "children": [],
                "tags": [
                  "norm:sha512sig1l_enc",
                  "norm:sha512sig1l_op"
                ]
              },
              {
                "title": "sha512sum0r",
                "id": "insns-sha512sum0r",
                "children": [],
                "tags": [
                  "norm:sha512sum0r_enc",
                  "norm:sha512sum0r_op"
                ]
              },
              {
                "title": "sha512sum1r",
                "id": "insns-sha512sum1r",
                "children": [],
                "tags": [
                  "norm:sha512sum1r_enc",
                  "norm:sha512sum1r_op"
                ]
              },
              {
                "title": "sha512sig0",
                "id": "insns-sha512sig0",
                "children": [],
                "tags": [
                  "norm:sha512sig0_enc",
                  "norm:sha512sig0_op"
                ]
              },
              {
                "title": "sha512sig1",
                "id": "insns-sha512sig1",
                "children": [],
                "tags": [
                  "norm:sha512sig1_enc",
                  "norm:sha512sig1_op"
                ]
              },
              {
                "title": "sha512sum0",
                "id": "insns-sha512sum0",
                "children": [],
                "tags": [
                  "norm:sha512sum0_enc",
                  "norm:sha512sum0_op"
                ]
              },
              {
                "title": "sha512sum1",
                "id": "insns-sha512sum1",
                "children": [],
                "tags": [
                  "norm:sha512sum1_enc",
                  "norm:sha512sum1_op"
                ]
              },
              {
                "title": "sm3p0",
                "id": "insns-sm3p0",
                "children": [],
                "tags": [
                  "norm:sm3p0_enc",
                  "norm:sm3p0_op"
                ]
              },
              {
                "title": "sm3p1",
                "id": "insns-sm3p1",
                "children": [],
                "tags": [
                  "norm:sm3p1_enc",
                  "norm:sm3p1_op"
                ]
              },
              {
                "title": "sm4ed",
                "id": "insns-sm4ed",
                "children": [],
                "tags": [
                  "norm:sm4ed_enc",
                  "norm:sm4ed_op"
                ]
              },
              {
                "title": "sm4ks",
                "id": "insns-sm4ks",
                "children": [],
                "tags": [
                  "norm:sm4ks_enc",
                  "norm:sm4ks_op"
                ]
              },
              {
                "title": "unzip",
                "id": "insns-unzip-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "xnor",
                "id": "insns-xnor-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "xperm8",
                "id": "insns-xperm8-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "xperm4",
                "id": "insns-xperm4-sc",
                "children": [],
                "tags": []
              },
              {
                "title": "zip",
                "id": "insns-zip-sc",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Entropy Source",
            "id": "crypto_scalar_es",
            "children": [
              {
                "title": "The seed CSR",
                "id": "crypto_scalar_seed_csr",
                "children": [],
                "tags": [
                  "norm:seed_csr_unpriv",
                  "norm:seed_ro_illegal",
                  "norm:seed_write_ignore",
                  "norm:seed_exec_mode_control",
                  "norm:seed_entropy_unique",
                  "norm:seed_entropy_zero_non_es16",
                  "norm:seed_wipe_on_read",
                  "norm:seed_bist_latch"
                ]
              },
              {
                "title": "Entropy Source Requirements",
                "id": "crypto_scalar_es_req",
                "children": [
                  {
                    "title": "NIST SP 800-90B / FIPS 140-3 Requirements",
                    "id": "crypto_scalar_es_req_90b",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "BSI AIS-31 PTG.2 / Common Criteria Requirements",
                    "id": "crypto_scalar_es_req_ptg2",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Virtual Sources: Security Requirement",
                    "id": "crypto_scalar_es_req_virt",
                    "children": [],
                    "tags": [
                      "norm:seed_min_security_256",
                      "norm:seed_disable_if_weak"
                    ]
                  }
                ],
                "tags": []
              },
              {
                "title": "Access Control to seed",
                "id": "crypto_scalar_es_access",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Data Independent Execution Latency Subset: Zkt",
            "id": "crypto_scalar_zkt",
            "children": [
              {
                "title": "Scope and Goal",
                "id": "_scope_and_goal",
                "children": [],
                "tags": [
                  "norm:zkt_optional_instr",
                  "norm:zkt_impl_must_constant_latency"
                ]
              },
              {
                "title": "Background",
                "id": "_background",
                "children": [],
                "tags": []
              },
              {
                "title": "Specific Instruction Rationale",
                "id": "_specific_instruction_rationale",
                "children": [],
                "tags": []
              },
              {
                "title": "Programming Information",
                "id": "_programming_information",
                "children": [],
                "tags": []
              },
              {
                "title": "Zkt listings",
                "id": "_zkt_listings",
                "children": [
                  {
                    "title": "RVI (Base Instruction Set)",
                    "id": "_rvi_base_instruction_set",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "RVM (Multiply)",
                    "id": "_rvm_multiply",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "RVC (Compressed)",
                    "id": "_rvc_compressed",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Zcb Extension",
                    "id": "_zcb_extension",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "RVK (Scalar Cryptography)",
                    "id": "_rvk_scalar_cryptography",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "RVB (Bitmanip)",
                    "id": "_rvb_bitmanip",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Instruction Rationale",
            "id": "crypto_scalar_appx_rationale",
            "children": [
              {
                "title": "AES Instructions",
                "id": "_aes_instructions",
                "children": [],
                "tags": []
              },
              {
                "title": "SHA2 Instructions",
                "id": "_sha2_instructions",
                "children": [],
                "tags": []
              },
              {
                "title": "SM3 and SM4 Instructions",
                "id": "_sm3_and_sm4_instructions",
                "children": [],
                "tags": []
              },
              {
                "title": "Bitmanip Instructions for Cryptography",
                "id": "crypto_scalar_zkb",
                "children": [
                  {
                    "title": "Rotations",
                    "id": "_rotations",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Bit &amp; Byte Permutations",
                    "id": "_bit_byte_permutations",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Carry-less Multiply",
                    "id": "_carry_less_multiply",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Logic With Negate",
                    "id": "_logic_with_negate",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Packing",
                    "id": "_packing",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Crossbar Permutation Instructions",
                    "id": "_crossbar_permutation_instructions",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Entropy Source Rationale and Recommendations",
            "id": "crypto_scalar_appx_es",
            "children": [
              {
                "title": "Checklists for Design and Self-Certification",
                "id": "_checklists_for_design_and_self_certification",
                "children": [],
                "tags": []
              },
              {
                "title": "Standards and Terminology",
                "id": "_standards_and_terminology",
                "children": [
                  {
                    "title": "Entropy Source (ES)",
                    "id": "crypto_scalar_appx_es_intro-es",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Conditioning: Cryptographic and Non-Cryptographic",
                    "id": "crypto_scalar_appx_es_intro-cond",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Pseudorandom Number Generator (PRNG)",
                    "id": "crypto_scalar_appx_es_intro-prng",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Deterministic Random Bit Generator (DRBG)",
                    "id": "crypto_scalar_appx_es_intro-drbg",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              },
              {
                "title": "Specific Rationale and Considerations",
                "id": "_specific_rationale_and_considerations",
                "children": [
                  {
                    "title": "The seed CSR",
                    "id": "_the_seed_csr",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "NIST SP 800-90B",
                    "id": "_nist_sp_800_90b",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "BSI AIS-31",
                    "id": "_bsi_ais_31",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Virtual Sources",
                    "id": "_virtual_sources",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Security Considerations for Direct Hardware Access",
                    "id": "crypto_scalar_appx_es_access",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              },
              {
                "title": "Security Controls and Health Tests",
                "id": "crypto_scalar_es_security_controls",
                "children": [
                  {
                    "title": "T1: On-demand testing",
                    "id": "_t1_on_demand_testing",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "T2: Continuous checks",
                    "id": "_t2_continuous_checks",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "T3: Fatal error states",
                    "id": "_t3_fatal_error_states",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Information Flows",
                    "id": "_information_flows",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              },
              {
                "title": "Implementation Strategies",
                "id": "crypto_scalar_appx_es_implementation",
                "children": [
                  {
                    "title": "Ring Oscillators",
                    "id": "crypto_scalar_appx_es_noise_sources",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Shot Noise",
                    "id": "_shot_noise",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Other types of noise",
                    "id": "_other_types_of_noise",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Continuous Health Tests",
                    "id": "crypto_scalar_appx_es_cont-tests",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Non-cryptographic Conditioners",
                    "id": "crypto_scalar_appx_es_noncrypto",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Cryptographic Conditioners",
                    "id": "crypto_scalar_appx_es_crypto-cond",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "The Final Random: DRBGs",
                    "id": "crypto_scalar_appx_es_drbgs",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Quantum vs. Classical Random",
                    "id": "crypto_scalar_appx_es_quantum",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Post-Quantum Cryptography",
                    "id": "_post_quantum_cryptography",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              },
              {
                "title": "Suggested GetNoise Test Interface",
                "id": "crypto_scalar_es_getnoise",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Supplementary Materials",
            "id": "crypto_scalar_appx_materials",
            "children": [],
            "tags": []
          },
          {
            "title": "Supporting Sail Code",
            "id": "crypto_scalar_appx_sail",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Cryptography Extensions: Vector Instructions, Version 1.0",
        "id": "_cryptography_extensions_vector_instructions_version_1_0",
        "children": [
          {
            "title": "Introduction",
            "id": "crypto_vector_introduction",
            "children": [
              {
                "title": "Intended Audience",
                "id": "crypto_vector_audience",
                "children": [],
                "tags": []
              },
              {
                "title": "Sail Specifications",
                "id": "crypto_vector_sail_specifications",
                "children": [],
                "tags": []
              },
              {
                "title": "Policies",
                "id": "crypto_vector_policies",
                "children": [],
                "tags": []
              },
              {
                "title": "Element Groups",
                "id": "crypto-vector-element-groups",
                "children": [],
                "tags": [
                  "norm:veccrypto_eeweqsew"
                ]
              },
              {
                "title": "Instruction Constraints",
                "id": "crypto-vector-instruction-constraints",
                "children": [],
                "tags": [
                  "norm:veccrypto_vl_vstart_egsconstr",
                  "norm:veccrypto_vl_vstart_rsv",
                  "norm:veccrypto_lmul_egwconstr",
                  "norm:veccrypto_sew_rsv",
                  "norm:veccrypto_vsins_vs2",
                  "norm:veccrypto_vsins_vdvs2overlap"
                ]
              },
              {
                "title": "Vector-Scalar Instructions",
                "id": "crypto-vector-scalar-instructions",
                "children": [],
                "tags": [
                  "norm:veccrypto_vsins_vd",
                  "norm:veccrypto_vsins_vs2function"
                ]
              },
              {
                "title": "Software Portability",
                "id": "crypto-vector-software-portability",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Extensions Overview",
            "id": "crypto_vector_extensions",
            "children": [
              {
                "title": "Zvbb - Vector Basic Bit-manipulation",
                "id": "zvbb",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvbc - Vector Carry-less Multiplication",
                "id": "zvbc",
                "children": [],
                "tags": [
                  "norm:Zvbc_sew64only"
                ]
              },
              {
                "title": "Zvkb - Vector Cryptography Bit-manipulation",
                "id": "zvkb",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvkg - Vector GCM/GMAC",
                "id": "zvkg",
                "children": [],
                "tags": [
                  "norm:Zvkg_egw128b_elem32b",
                  "norm:Zvkg_dataindeptiming",
                  "norm:Zvkg_vl",
                  "norm:Zvkg_vstart"
                ]
              },
              {
                "title": "Zvkned - NIST Suite: Vector AES Block Cipher",
                "id": "zvkned",
                "children": [],
                "tags": [
                  "norm:Zvkned_egw128b_elem32b",
                  "norm:Zvkned_dataindeptiming",
                  "norm:Zvkned_vl",
                  "norm:Zvkned_vstart"
                ]
              },
              {
                "title": "Zvknh[ab] - NIST Suite: Vector SHA-2 Secure Hash",
                "id": "zvknh",
                "children": [],
                "tags": [
                  "norm:Zvknha_Zvknhb_sha256_egw128b_elem32b",
                  "norm:Zvknhb_sha512_egw256b_elem64b",
                  "norm:Zvknhb_sha256_sha512",
                  "norm:Zvknha_sha256",
                  "norm:Zvknha_Zvknhb_dataindeptiming",
                  "norm:Zvknha_Zvknhb_vl",
                  "norm:Zvknha_Zvknhb_vstart"
                ]
              },
              {
                "title": "Zvksed - ShangMi Suite: SM4 Block Cipher",
                "id": "zvksed",
                "children": [],
                "tags": [
                  "norm:Zvksed_egw128b_elem32b",
                  "norm:Zvksed_dataindeptiming",
                  "norm:Zvksed_vl",
                  "norm:Zvksed_vstart"
                ]
              },
              {
                "title": "Zvksh - ShangMi Suite: SM3 Secure Hash",
                "id": "zvksh",
                "children": [],
                "tags": [
                  "norm:Zvksh_egw256b_elem32b",
                  "norm:Zvksh_dataindeptiming",
                  "norm:Zvksh_vl",
                  "norm:Zvksh_vstart"
                ]
              },
              {
                "title": "Zvkn - NIST Algorithm Suite",
                "id": "zvkn",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvknc - NIST Algorithm Suite with carry-less multiply",
                "id": "zvknc",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvkng - NIST Algorithm Suite with GCM",
                "id": "zvkng",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvks - ShangMi Algorithm Suite",
                "id": "zvks",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvksc - ShangMi Algorithm Suite with carry-less multiplication",
                "id": "zvksc",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvksg - ShangMi Algorithm Suite with GCM",
                "id": "zvksg",
                "children": [],
                "tags": []
              },
              {
                "title": "Zvkt - Vector Data-Independent Execution Latency",
                "id": "zvkt",
                "children": [
                  {
                    "title": "All   instructions",
                    "id": "_all_instructions",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "All  instructions",
                    "id": "_all_instructions_2",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "add/sub",
                    "id": "_addsub",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "add/sub with carry",
                    "id": "_addsub_with_carry",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "compare and set",
                    "id": "_compare_and_set",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "copy",
                    "id": "_copy",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "extend",
                    "id": "_extend",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "logical",
                    "id": "_logical",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "multiply",
                    "id": "_multiply",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "multiply-add",
                    "id": "_multiply_add",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Integer Merge",
                    "id": "_integer_merge",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "permute",
                    "id": "_permute",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "shift",
                    "id": "_shift",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "slide",
                    "id": "_slide",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              }
            ],
            "tags": [
              "norm:Zvknhb_Zvbc_Zvkn_Zvknc_Zvkng_depZve64x",
              "norm:Zvbb_Zvkb_Zvkg_Zvkned_Zvknha_Zvksed_Zvksh_Zvks_Zvksc_Zvksg_Zvkt_depZve32x",
              "norm:veccrypto_indepZkt"
            ]
          },
          {
            "title": "Instructions",
            "id": "crypto_vector_insns",
            "children": [
              {
                "title": "vaesdf.[vv,vs]",
                "id": "insns-vaesdf",
                "children": [],
                "tags": [
                  "norm:vaesdf_final",
                  "norm:vaesdf_ops",
                  "norm:vaesdf_xor_form"
                ]
              },
              {
                "title": "vaesdm.[vv,vs]",
                "id": "insns-vaesdm",
                "children": [],
                "tags": [
                  "norm:vaesdm_mid",
                  "norm:vaesdm_ops",
                  "norm:vaesdm_xor_form",
                  "norm:vaesdm_invmix"
                ]
              },
              {
                "title": "vaesef.[vv,vs]",
                "id": "insns-vaesef",
                "children": [],
                "tags": [
                  "norm:vaesef_final",
                  "norm:vaesef_ops",
                  "norm:vaesef_xor_form"
                ]
              },
              {
                "title": "vaesem.[vv,vs]",
                "id": "insns-vaesem",
                "children": [],
                "tags": [
                  "norm:vaesem_mid",
                  "norm:vaesem_ops",
                  "norm:vaesem_xor_form"
                ]
              },
              {
                "title": "vaeskf1.vi",
                "id": "insns-vaeskf1",
                "children": [],
                "tags": [
                  "norm:vaeskf1_round",
                  "norm:vaeskf1_wordgen",
                  "norm:vaeskf1_uimm_src",
                  "norm:vaeskf1_uimm_map"
                ]
              },
              {
                "title": "vaeskf2.vi",
                "id": "insns-vaeskf2",
                "children": [],
                "tags": [
                  "norm:vaeskf2_round",
                  "norm:vaeskf2_wordgen",
                  "norm:vaeskf2_rcon_lsw",
                  "norm:vaeskf2_rcon_func",
                  "norm:vaeskf2_uimm_src",
                  "norm:vaeskf2_uimm_map"
                ]
              },
              {
                "title": "vaesz.vs",
                "id": "insns-vaesz",
                "children": [],
                "tags": [
                  "norm:vaesz_round0",
                  "norm:vaesz_vs_only",
                  "norm:vaesz_vs2_rk"
                ]
              },
              {
                "title": "vandn.[vv,vx]",
                "id": "insns-vandn",
                "children": [],
                "tags": [
                  "norm:vandn_op",
                  "norm:vandn-vx_rs1",
                  "norm:vandn-vv_vs1"
                ]
              },
              {
                "title": "vbrev.v",
                "id": "insns-vbrev",
                "children": [],
                "tags": [
                  "norm:vbrev-v_op"
                ]
              },
              {
                "title": "vbrev8.v",
                "id": "insns-vbrev8",
                "children": [],
                "tags": [
                  "norm:vbrev8-v_op"
                ]
              },
              {
                "title": "vclmul.[vv,vx]",
                "id": "insns-vclmul",
                "children": [],
                "tags": [
                  "norm:vclmul_sewn64_rsv",
                  "norm:vclmul_op"
                ]
              },
              {
                "title": "vclmulh.[vv,vx]",
                "id": "insns-vclmulh",
                "children": [],
                "tags": [
                  "norm:vclmulh_sewn64_rsv",
                  "norm:vclmulh_op"
                ]
              },
              {
                "title": "vclz.v",
                "id": "insns-vclz",
                "children": [],
                "tags": [
                  "norm:vclz-v_op",
                  "norm:vclz-v_op_zeroinput"
                ]
              },
              {
                "title": "vcpop.v",
                "id": "insns-vcpop",
                "children": [],
                "tags": [
                  "norm:vcpop-v_op"
                ]
              },
              {
                "title": "vctz.v",
                "id": "insns-vctz",
                "children": [],
                "tags": [
                  "norm:vctz-v_op"
                ]
              },
              {
                "title": "vghsh.vv",
                "id": "insns-vghsh",
                "children": [],
                "tags": [
                  "norm:vghsh-vv_sewn32_rsv",
                  "norm:vghsh-vv_op",
                  "norm:vghsh-vv_op_gf",
                  "norm:vghsh-vv_op_coeff",
                  "norm:vghsh-vv_exeindepdata"
                ]
              },
              {
                "title": "vgmul.vv",
                "id": "insns-vgmul",
                "children": [],
                "tags": [
                  "norm:vgmul-vv_sewn32_rsv",
                  "norm:vgmul-vv_op",
                  "norm:vgmul-vv_op_gf",
                  "norm:vgmul-vv_op_coeff",
                  "norm:vgmul-vv_exeindepdata"
                ]
              },
              {
                "title": "vrev8.v",
                "id": "insns-vrev8",
                "children": [],
                "tags": [
                  "norm:vrev8-v_op"
                ]
              },
              {
                "title": "vrol.[vv,vx]",
                "id": "insns-vrol",
                "children": [],
                "tags": [
                  "norm:vrol_op"
                ]
              },
              {
                "title": "vror.[vv,vx,vi]",
                "id": "insns-vror",
                "children": [],
                "tags": [
                  "norm:vror_op"
                ]
              },
              {
                "title": "vsha2c[hl].vv",
                "id": "insns-vsha2c",
                "children": [],
                "tags": [
                  "norm:vsha2chl-vv_Zvknha_sewn32_rsv",
                  "norm:vsha2chl-vv_Zvknhb_sewn32or64_rsv",
                  "norm:vsha2chl-vv_vdoverlapvs1vs2_rsv",
                  "norm:vsha2chl-vv_op_sew32",
                  "norm:vsha2chl-vv_op_sew64",
                  "norm:vsha2chl-vv_op"
                ]
              },
              {
                "title": "vsha2ms.vv",
                "id": "insns-vsha2ms",
                "children": [],
                "tags": [
                  "norm:vsha2ms-vv_Zvknha_sewn32_rsv",
                  "norm:vsha2ms-vv_Zvknhb_sewn32or64_rsv",
                  "norm:vsha2ms-vv_vdoverlapvs1vs2_rsv",
                  "norm:vsha2ms-vv_op_sew32",
                  "norm:vsha2ms-vv_op_sew64",
                  "norm:vsha2ms-vv_op"
                ]
              },
              {
                "title": "vsm3c.vi",
                "id": "insns-vsm3c",
                "children": [],
                "tags": [
                  "norm:vsm3c-vi_sewn32_rsv",
                  "norm:vsm3c-vi_vdoverlapvs2_rsv",
                  "norm:vsm3c-vi_op",
                  "norm:vsm3c-vi_op_sm3",
                  "norm:vsm3c-vi_op_rnd"
                ]
              },
              {
                "title": "vsm3me.vv",
                "id": "insns-vsm3me",
                "children": [],
                "tags": [
                  "norm:vsm3me-vv_sewn32_rsv",
                  "norm:vsm3me-vv_vdoverlapvs2_rsv",
                  "norm:vsm3me-vv_op",
                  "norm:vsm3me-vv_op_sm3"
                ]
              },
              {
                "title": "vsm4k.vi",
                "id": "insns-vsm4k",
                "children": [],
                "tags": [
                  "norm:vsm4k-vi_sewn32_rsv",
                  "norm:vsm4k-vi_op",
                  "norm:vsm4k-vi_op_sm4k",
                  "norm:vsm4k-vi_op_rnd"
                ]
              },
              {
                "title": "vsm4r.[vv,vs]",
                "id": "insns-vsm4r",
                "children": [],
                "tags": [
                  "norm:vsm4r_sewn32_rsv",
                  "norm:vsm4r-vs_vdoverlapvs2_rsv",
                  "norm:vsm4r_op",
                  "norm:vsm4r_op_sm4encdec"
                ]
              },
              {
                "title": "vwsll.[vv,vx,vi]",
                "id": "insns-vwsll",
                "children": [],
                "tags": [
                  "norm:vwsll_op"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Crypto Vector Cryptographic Instructions",
            "id": "crypto_vector_instructions",
            "children": [],
            "tags": []
          },
          {
            "title": "Vector Bitmanip and Carry-less Multiply Instructions",
            "id": "crypto_vector_instructions_Zvbb_Zvbc",
            "children": [],
            "tags": []
          },
          {
            "title": "Supporting Sail Code",
            "id": "crypto_vector_appx_sail",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Control-flow Integrity (CFI)",
        "id": "_control_flow_integrity_cfi",
        "children": [
          {
            "title": "Landing Pad (Zicfilp)",
            "id": "unpriv-forward",
            "children": [
              {
                "title": "Landing Pad Enforcement",
                "id": "_landing_pad_enforcement",
                "children": [],
                "tags": [
                  "norm:zicflip_lpad_expected",
                  "norm:zicflip_indirect_branch_lpad",
                  "norm:zicflip_lpad_label",
                  "norm:zicflip_lpad_imm_enc",
                  "norm:zicflip_elp_lpad_expected"
                ]
              },
              {
                "title": "Landing Pad Instruction",
                "id": "LP_INST",
                "children": [],
                "tags": [
                  "norm:zicflip_lpad_enabled_instr_allowed",
                  "norm:zicflip_lpad_enabled_exception",
                  "norm:zicflip_lpad_alignment_exception",
                  "norm:zicflip_lpad_label_exception",
                  "norm:zicflip_lpad_no_sw_exception"
                ]
              }
            ],
            "tags": [
              "norm:zicflip_lpad_enc"
            ]
          },
          {
            "title": "Shadow Stack (Zicfiss)",
            "id": "unpriv-backward",
            "children": [
              {
                "title": "Zicfiss Instructions Summary",
                "id": "_zicfiss_instructions_summary",
                "children": [],
                "tags": [
                  "norm:zicfiss_sspush_enc",
                  "norm:zicfiss_c-sspush_enc",
                  "norm:zicfiss_sspopchk_enc",
                  "norm:zicfiss_c-sspopchk_enc",
                  "norm:zicfiss_ssrdp_enc",
                  "norm:zicfiss_atomic_swap"
                ]
              },
              {
                "title": "Shadow Stack Pointer (ssp)",
                "id": "_shadow_stack_pointer_ssp",
                "children": [],
                "tags": [
                  "norm:ssp_op",
                  "norm:ssp_addr",
                  "norm:ssp_sz",
                  "norm:ssp-field_1_0"
                ]
              },
              {
                "title": "Zicfiss Instructions",
                "id": "_zicfiss_instructions",
                "children": [],
                "tags": []
              },
              {
                "title": "Push to the Shadow Stack",
                "id": "SS_PUSH",
                "children": [],
                "tags": [
                  "norm:ss_push",
                  "norm:sspush_c-sspush_instr",
                  "norm:sspush_c-sspush_decrement"
                ]
              },
              {
                "title": "Pop from the Shadow Stack",
                "id": "SS_POP",
                "children": [],
                "tags": [
                  "norm:ss_pop",
                  "norm:sspopchk_shadow_return_pop",
                  "norm:sspopchk-c_load_op",
                  "norm:sspop_exception",
                  "norm:sspop_increment"
                ]
              },
              {
                "title": "Read ssp into a Register",
                "id": "SSP_READ",
                "children": [],
                "tags": [
                  "norm:ssrdp_read"
                ]
              },
              {
                "title": "Atomic Swap from a Shadow Stack Location",
                "id": "SSAMOSWAP",
                "children": [],
                "tags": [
                  "norm:rv32_ssamoswap-w_op",
                  "norm:rv64_ssamoswap-w_op",
                  "norm:ssamoswap_address"
                ]
              }
            ],
            "tags": [
              "norm:zicfiss_link_reg_func_enter",
              "norm:zicfiss_link_reg_func_return",
              "norm:zicfiss_stack_compare",
              "norm:zicfiss_enc"
            ]
          }
        ],
        "tags": [
          "norm:cfi_call_term",
          "norm:cfi_return_term",
          "norm:cfi_indirect-jump_term"
        ]
      },
      {
        "title": "\"Zilsd\", \"Zclsd\" Extensions for Load/Store pair for RV32, Version 1.0",
        "id": "sec:zilsd",
        "children": [
          {
            "title": "Load/Store pair instructions (Zilsd)",
            "id": "zilsd",
            "children": [],
            "tags": [
              "norm:Zilsd_align8_no_exc",
              "norm:Zilsd_align8_atomic",
              "norm:Zilsd_align4_atomic",
              "norm:Zilsd_ld_resume_trap"
            ]
          },
          {
            "title": "Compressed Load/Store pair instructions (Zclsd)",
            "id": "zclsd",
            "children": [],
            "tags": []
          },
          {
            "title": "Use of x0 as operand",
            "id": "_use_of_x0_as_operand",
            "children": [],
            "tags": [
              "norm:Zilsd_ld_x0",
              "norm:Zilsd_c-ldsp_x0",
              "norm:Zilsd_sd_x0"
            ]
          },
          {
            "title": "Exception Handling",
            "id": "_exception_handling_2",
            "children": [],
            "tags": [
              "norm:Zilsd_RVWMO_exc_misaligned",
              "norm:Zilsd_align4_two_4byte"
            ]
          },
          {
            "title": "Instructions",
            "id": "_instructions",
            "children": [
              {
                "title": "ld",
                "id": "insns-ld",
                "children": [],
                "tags": [
                  "norm:Zilsd_ld_op"
                ]
              },
              {
                "title": "sd",
                "id": "insns-sd",
                "children": [],
                "tags": [
                  "norm:Zilsd_sd_op"
                ]
              },
              {
                "title": "c.ldsp",
                "id": "insns-cldsp",
                "children": [],
                "tags": [
                  "norm:Zilsd_c-ldsp_op"
                ]
              },
              {
                "title": "c.sdsp",
                "id": "insns-csdsp",
                "children": [],
                "tags": [
                  "norm:Zilsd_c-sdsp_op"
                ]
              },
              {
                "title": "c.ld",
                "id": "insns-cld",
                "children": [],
                "tags": [
                  "norm:Zilsd_c-ld_op"
                ]
              },
              {
                "title": "c.sd",
                "id": "insns-csd",
                "children": [],
                "tags": [
                  "norm:Zilsd_c-sd_op"
                ]
              }
            ],
            "tags": []
          }
        ],
        "tags": [
          "norm:Zilsd_reg_pairs",
          "norm:Zilsd_bits_to_pair"
        ]
      },
      {
        "title": "RV32/64G Instruction Set Listings",
        "id": "rv32-64g",
        "children": [],
        "tags": [
          "norm:lui_enc",
          "norm:auipc_enc",
          "norm:jal_enc",
          "norm:jalr_enc",
          "norm:beq_enc",
          "norm:bne_enc",
          "norm:blt_enc",
          "norm:bge_enc",
          "norm:bltu_enc",
          "norm:bgeu_enc",
          "norm:lb_enc",
          "norm:lh_enc",
          "norm:lw_enc",
          "norm:lbu_enc",
          "norm:lhu_enc",
          "norm:sb_enc",
          "norm:sh_enc",
          "norm:sw_enc",
          "norm:addi_enc",
          "norm:slti_enc",
          "norm:sltiu_enc",
          "norm:xori_enc",
          "norm:ori_enc",
          "norm:andi_enc",
          "norm:slli_enc",
          "norm:srli_enc",
          "norm:srai_enc",
          "norm:add_enc",
          "norm:sub_enc",
          "norm:sll_enc",
          "norm:slt_enc",
          "norm:sltu_enc",
          "norm:xor_enc",
          "norm:srl_enc",
          "norm:sra_enc",
          "norm:or_enc",
          "norm:and_enc",
          "norm:fence_enc",
          "norm:fence-tso_enc",
          "norm:pause_enc",
          "norm:ecall_enc",
          "norm:ebreak_enc",
          "norm:lwu_enc",
          "norm:ld_enc",
          "norm:sd_enc",
          "norm:addiw_enc",
          "norm:slliw_enc",
          "norm:srliw_enc",
          "norm:sraiw_enc",
          "norm:addw_enc",
          "norm:subw_enc",
          "norm:sllw_enc",
          "norm:srlw_enc",
          "norm:sraw_enc",
          "norm:mul_enc",
          "norm:mulh_enc",
          "norm:mulhsu_enc",
          "norm:mulhu_enc",
          "norm:div_enc",
          "norm:divu_enc",
          "norm:rem_enc",
          "norm:remu_enc",
          "norm:mulw_enc",
          "norm:divw_enc",
          "norm:divuw_enc",
          "norm:remw_enc",
          "norm:remuw_enc"
        ]
      },
      {
        "title": "ISA Extension Naming Conventions",
        "id": "naming",
        "children": [
          {
            "title": "Case Sensitivity",
            "id": "_case_sensitivity",
            "children": [],
            "tags": []
          },
          {
            "title": "Base Integer ISA",
            "id": "_base_integer_isa",
            "children": [],
            "tags": []
          },
          {
            "title": "Instruction-Set Extension Names",
            "id": "_instruction_set_extension_names",
            "children": [],
            "tags": []
          },
          {
            "title": "Underscores",
            "id": "_underscores",
            "children": [],
            "tags": []
          },
          {
            "title": "Additional Standard Unprivileged Extension Names",
            "id": "_additional_standard_unprivileged_extension_names",
            "children": [],
            "tags": []
          },
          {
            "title": "Supervisor-level Instruction-Set Extension Names",
            "id": "_supervisor_level_instruction_set_extension_names",
            "children": [],
            "tags": []
          },
          {
            "title": "Hypervisor-level Instruction-Set Extension Names",
            "id": "_hypervisor_level_instruction_set_extension_names",
            "children": [],
            "tags": []
          },
          {
            "title": "Machine-level Instruction-Set Extension Names",
            "id": "_machine_level_instruction_set_extension_names",
            "children": [],
            "tags": []
          },
          {
            "title": "Non-Standard Extension Names",
            "id": "_non_standard_extension_names",
            "children": [],
            "tags": []
          },
          {
            "title": "Version Numbers",
            "id": "_version_numbers",
            "children": [],
            "tags": []
          },
          {
            "title": "Subset Naming Convention",
            "id": "_subset_naming_convention",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "RVWMO Explanatory Material, Version 0.1",
        "id": "_rvwmo_explanatory_material_version_0_1",
        "children": [
          {
            "title": "Why RVWMO?",
            "id": "whyrvwmo",
            "children": [],
            "tags": []
          },
          {
            "title": "Litmus Tests",
            "id": "litmustests",
            "children": [],
            "tags": []
          },
          {
            "title": "Explaining the RVWMO Rules",
            "id": "_explaining_the_rvwmo_rules",
            "children": [
              {
                "title": "Preserved Program Order and Global Memory Order",
                "id": "_preserved_program_order_and_global_memory_order",
                "children": [],
                "tags": []
              },
              {
                "title": "Load value axiom",
                "id": "loadvalueaxiom",
                "children": [],
                "tags": []
              },
              {
                "title": "Atomicity axiom",
                "id": "atomicityaxiom",
                "children": [],
                "tags": []
              },
              {
                "title": "Progress axiom",
                "id": "mm-progress",
                "children": [],
                "tags": []
              },
              {
                "title": "Overlapping-Address Orderings (Rules 1-3)",
                "id": "mm-overlap",
                "children": [],
                "tags": []
              },
              {
                "title": "Fences (Rule 4)",
                "id": "mm-fence",
                "children": [],
                "tags": []
              },
              {
                "title": "Explicit Synchronization (Rules 5-8)",
                "id": "sec:memory:acqrel",
                "children": [],
                "tags": []
              },
              {
                "title": "Syntactic Dependencies (Rules 9-11)",
                "id": "sec:memory:dependencies",
                "children": [],
                "tags": []
              },
              {
                "title": "Pipeline Dependencies (Rules 12-13)",
                "id": "memory-ppopipeline",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Beyond Main Memory",
            "id": "_beyond_main_memory",
            "children": [
              {
                "title": "Coherence and Cacheability",
                "id": "_coherence_and_cacheability",
                "children": [],
                "tags": []
              },
              {
                "title": "I/O Ordering",
                "id": "_io_ordering",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Code Porting and Mapping Guidelines",
            "id": "memory_porting",
            "children": [],
            "tags": []
          },
          {
            "title": "Implementation Guidelines",
            "id": "_implementation_guidelines",
            "children": [
              {
                "title": "Possible Future Extensions",
                "id": "_possible_future_extensions",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Known Issues",
            "id": "discrepancies",
            "children": [
              {
                "title": "Mixed-size RSW",
                "id": "mixedrsw",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Formal Memory Model Specifications, Version 0.1",
        "id": "_formal_memory_model_specifications_version_0_1",
        "children": [
          {
            "title": "Formal Axiomatic Specification in Alloy",
            "id": "alloy",
            "children": [],
            "tags": []
          },
          {
            "title": "Formal Axiomatic Specification in Herd",
            "id": "sec:herd",
            "children": [],
            "tags": []
          },
          {
            "title": "An Operational Memory Model",
            "id": "operational",
            "children": [
              {
                "title": "Intra-instruction Pseudocode Execution",
                "id": "pseudocode_exec",
                "children": [],
                "tags": []
              },
              {
                "title": "Instruction Instance State",
                "id": "inst_state",
                "children": [],
                "tags": []
              },
              {
                "title": "Hart State",
                "id": "_hart_state",
                "children": [],
                "tags": []
              },
              {
                "title": "Shared Memory State",
                "id": "_shared_memory_state",
                "children": [],
                "tags": []
              },
              {
                "title": "Transitions",
                "id": "transitions",
                "children": [
                  {
                    "title": "Fetch instruction",
                    "id": "fetch",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Initiate memory load operations",
                    "id": "initiate_load",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Satisfy memory load operation by forwarding from unpropagated stores",
                    "id": "sat_by_forwarding",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Satisfy memory load operation from memory",
                    "id": "sat_from_mem",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Complete load operations",
                    "id": "complete_loads",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Early sc fail",
                    "id": "early_sc_fail",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Paired sc",
                    "id": "paired_sc",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Initiate memory store operation footprints",
                    "id": "initiate_store_footprint",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Instantiate memory store operation values",
                    "id": "instantiate_store_value",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Commit store instruction",
                    "id": "commit_stores",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Propagate store operation",
                    "id": "prop_store",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Commit and propagate store operation of an sc",
                    "id": "commit_sc",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Late sc fail",
                    "id": "late_sc_fail",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Complete store operations",
                    "id": "complete_stores",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Satisfy, commit and propagate operations of an AMO",
                    "id": "do_amo",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Commit fence",
                    "id": "commit_fence",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Register read",
                    "id": "reg_read",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Register write",
                    "id": "reg_write",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Pseudocode internal step",
                    "id": "sail_interp",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Finish instruction",
                    "id": "finish",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              },
              {
                "title": "Limitations",
                "id": "limitations",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Vector Assembly Code Examples",
        "id": "_vector_assembly_code_examples",
        "children": [
          {
            "title": "Vector-vector add example",
            "id": "_vector_vector_add_example",
            "children": [],
            "tags": []
          },
          {
            "title": "Example with mixed-width mask and compute.",
            "id": "_example_with_mixed_width_mask_and_compute",
            "children": [],
            "tags": []
          },
          {
            "title": "Memcpy example",
            "id": "_memcpy_example",
            "children": [],
            "tags": []
          },
          {
            "title": "Conditional example",
            "id": "_conditional_example",
            "children": [],
            "tags": []
          },
          {
            "title": "SAXPY example",
            "id": "_saxpy_example",
            "children": [],
            "tags": []
          },
          {
            "title": "SGEMM example",
            "id": "_sgemm_example",
            "children": [],
            "tags": []
          },
          {
            "title": "Division approximation example",
            "id": "_division_approximation_example",
            "children": [],
            "tags": []
          },
          {
            "title": "Square root approximation example",
            "id": "_square_root_approximation_example",
            "children": [],
            "tags": []
          },
          {
            "title": "C standard library strcmp example",
            "id": "_c_standard_library_strcmp_example",
            "children": [],
            "tags": []
          },
          {
            "title": "Fractional Lmul example",
            "id": "_fractional_lmul_example",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Calling Convention for Vector State (Not authoritative - Placeholder Only)",
        "id": "_calling_convention_for_vector_state_not_authoritative_placeholder_only",
        "children": [],
        "tags": []
      },
      {
        "title": "Bit Manipulation Extensions Assembly Code Examples",
        "id": "_bit_manipulation_extensions_assembly_code_examples",
        "children": [
          {
            "title": "strlen",
            "id": "_strlen",
            "children": [],
            "tags": []
          },
          {
            "title": "strcmp",
            "id": "_strcmp",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Historical Rationale for Extensions",
        "id": "_historical_rationale_for_extensions",
        "children": [
          {
            "title": "\"Zihintpause\" Extension for Pause Hint",
            "id": "_zihintpause_extension_for_pause_hint",
            "children": [],
            "tags": []
          },
          {
            "title": "\"Zicond\" Extension for Integer Conditional Operations",
            "id": "_zicond_extension_for_integer_conditional_operations",
            "children": [],
            "tags": []
          },
          {
            "title": "\"Zacas\" Extension for Atomic Compare-and-Swap (CAS) Instructions",
            "id": "_zacas_extension_for_atomic_compare_and_swap_cas_instructions",
            "children": [],
            "tags": []
          },
          {
            "title": "\"Zabha\" Extension for Byte and Halfword Atomic Memory Operations, Version 1.0",
            "id": "_zabha_extension_for_byte_and_halfword_atomic_memory_operations_version_1_0_2",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Index",
        "id": "_index",
        "children": [],
        "tags": []
      },
      {
        "title": "Bibliography",
        "id": "_bibliography_2",
        "children": [],
        "tags": []
      }
    ],
    "tags": []
  }
}
