{
  "tags": {
    "norm:always-priv-level": "At any time, a RISC-V hardware thread (hart) is running at some\nprivilege level encoded as a mode in one or more CSRs (control and\nstatus registers).",
    "norm:priv-levels-txt": "Three RISC-V privilege levels are currently defined",
    "norm:priv-levels-tbl": "Level|Encoding|Name|Abbreviation\n===\n0\n1\n2\n3|00\n01\n10\n11|User/Application\nSupervisor\nReserved\nMachine|U\nS\n&#160;\nM\n===",
    "norm:non-priv-exc": "attempts to perform operations not\npermitted by the current privilege mode will cause an exception to be\nraised.",
    "norm:m-level-high-priv-only-mandatory": "The machine level has the highest privileges and\nis the only mandatory privilege level for a RISC-V hardware platform.",
    "norm:priv-combs-txt": "Implementations might provide anywhere from 1 to 3 privilege modes",
    "norm:priv-combs-tbl": "Number of levels|Supported Modes|Intended Usage\n===\n1\n2\n3|M\nM, U\nM, S, U|Simple embedded systems\nSecure embedded systems\nSystems running Unix-like operating systems\n===",
    "norm:m-mode-mandatory": "All hardware implementations must provide M-mode",
    "norm:Zicsr_higher_priv": "although CSRs and instructions are associated with one privilege\nlevel, they are also accessible at all higher privilege levels.",
    "norm:Zicsr_rw": "The top two bits (csr[11:10]) indicate whether the register is read/write (00,01, or 10) or read-only (11).",
    "norm:Zicsr_access": "The next two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.",
    "norm:Zicsr_illegal_mode": "Attempts to access a CSR without appropriate privilege level\nraise illegal-instruction exceptions or, as described in\n&lt;&lt;sec:hcauses&gt;&gt;, virtual-instruction exceptions.",
    "norm:Zicsr_illegal_acc": "Attempts to write a read-only register raise illegal-instruction exceptions.",
    "norm:Zicwr_write_ro": "A read/write register might also contain some bits that are\nread-only, in which case writes to the read-only bits are ignored.",
    "norm:Zicsr_debug-illegal": "0x7B0-0x7BF are only visible to debug mode.\nImplementations should raise illegal-instruction exceptions on\nmachine-mode access to the latter set of registers.",
    "norm:Zicsr_wpri_roz": "For forward compatibility, implementations that do not\nfurnish these fields must make them read-only zero. These fields are\nlabeled WPRI in the register descriptions.",
    "norm:Zicsr_wlrl": "Software\nshould not write anything other than legal values to such a field, and\nshould not assume a read will return a legal value unless the last write\nwas of a legal value, or the register has not been written since another\noperation (e.g., reset) set the register to a legal value. These fields\nare labeled WLRL in the register descriptions.",
    "norm:Zicsr_wlrl_exception_param": "Implementations are permitted but not required to raise an\nillegal-instruction exception if an instruction attempts to write a\nnon-supported value to a WLRL field.",
    "norm:Zicsr_warl": "Implementations will not raise an exception on writes of unsupported\nvalues to a WARL field.",
    "norm:M_highest_priv_mode": "machine-mode (M-mode), which is the highest privilege mode in a RISC-V\nhart.",
    "norm:M_mode_at_reset": "M-mode is used for low-level access to a hardware platform and\nis the first mode entered at reset.",
    "norm:M_access_all_lower_priv_CSRs": "M-mode code can access all CSRs at lower privilege levels.",
    "norm:misa_acc": "The misa CSR is a WARL read-write register",
    "norm:misa_always_rd": "This register must be readable in any implementation",
    "norm:misa_csr_implemented": "a value of zero can be returned to indicate the misa register has not been implemented",
    "norm:misa_enc_img": "",
    "norm:misa_mxl_op_isa": "The MXL (Machine XLEN) field encodes the native base integer ISA width as\nshown in &lt;&lt;norm:misa_mxl_enc&gt;&gt;.",
    "norm:misa_mxl_acc": "The MXL field is read-only.",
    "norm:misa_mxl_op_nz": "If misa is nonzero, the\nMXL field indicates the effective XLEN in M-mode, a constant termed MXLEN.",
    "norm:xlen_le_mxlen": "XLEN is never greater than MXLEN, but XLEN might be smaller than MXLEN in\nless-privileged modes.",
    "norm:misa_mxl_enc": "MXL|XLEN\n===\n1\n2\n3|32\n64\nReserved\n===",
    "norm:misa_sz": "The misa CSR is MXLEN bits wide.",
    "norm:misa_extensions_enc_txt": "The Extensions field encodes the presence of the standard extensions,\nwith a single bit per letter of the alphabet (bit 0 encodes presence of\nextension \"A\" , bit 1 encodes presence of extension \"B\", through to\nbit 25 which encodes \"Z\").",
    "norm:misa_i_op": "The \"I\" bit will be set for the RV32I and RV64I base ISAs",
    "norm:misa_e_op": "the \"E\" bit will be set for RV32E and RV64E.",
    "norm:misa_extensions_warl_op": "The Extensions field is a WARL field that can contain writable bits where the\nimplementation allows the supported ISA to be modified.",
    "norm:misa_extensions_rst": "At reset, the Extensions field shall contain the maximal set of supported extensions,\nand \"I\" shall be selected over \"E\" if both are available.",
    "norm:misa_extensions_disabling": "When a standard extension is disabled by clearing its bit in misa, the instructions and CSRs defined or modified by the extension revert to their defined or reserved behaviors as if the extension is not implemented.",
    "norm:misa_extensions_impl_def": "For a given RISC-V execution environment, an instruction, extension, or other feature of the RISC-V ISA is ordinarily judged to be implemented or not by the observable execution behavior in that environment. For example, the F extension is said to be implemented for an execution environment if and only if the instructions that the RISC-V Unprivileged ISA defines for F execute as specified.",
    "norm:misa_extensions_disabling_def": "With this definition of implemented, disabling an extension by clearing its bit in misa results in the extension being considered not implemented in M-mode. For example, setting misa.F=0 results in the F extension being not implemented for M-mode, because the F extension&#8217;s instructions will not act as the Unprivileged ISA requires but may instead raise an illegal-instruction exception.",
    "norm:misa_extensions_rsv_ret_0": "All bits that are reserved for future use must return zero when read.",
    "norm:misa_extensions_enc_tbl": "Bit|Character|Description\n===\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25|A\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\nQ\nR\nS\nT\nU\nV\nW\nX\nY\nZ|Atomic extension\nB extension\nCompressed extension\nDouble-precision floating-point extension\nRV32E/64E base ISA\nSingle-precision floating-point extension\nReserved\nHypervisor extension\nRV32I/64I base ISA\nReserved\nReserved\nReserved\nInteger Multiply/Divide extension\nTentatively reserved for User-Level Interrupts extension\nReserved\nTentatively reserved for Packed-SIMD extension\nQuad-precision floating-point extension\nReserved\nSupervisor mode implemented\nReserved\nUser mode implemented\nVector extension\nReserved\nNon-standard extensions present\nReserved\nReserved\n===",
    "norm:misa_x_op": "The \"X\" bit will be set if there are any non-standard extensions.",
    "norm:misa_b_op": "When the \"B\" bit is 1, the implementation supports the instructions provided by the\nZba, Zbb, and Zbs extensions.",
    "norm:misa_m_op": "When the \"M\" bit is 1, the implementation supports all multiply and\ndivision instructions defined by the M extension.",
    "norm:Zmmul_misa_m": "if the Zmmul extension is supported then\nthe multiply instructions it specifies are supported irrespective\nof the value of the \"M\" bit.",
    "norm:misa_s_op": "When the \"S\" bit is 1, the implementation supports supervisor mode.",
    "norm:misa_u_op": "When the \"U\" bit is 1, the implementation supports user mode.",
    "norm:misa_e_acc": "The \"E\" bit is read-only.",
    "norm:misa_e_not_i": "Unless misa is all read-only zero, the\n\"E\" bit always reads as the complement of the \"I\" bit.",
    "norm:misa_extensions_dependencies": "If an ISA feature x depends on an ISA feature y, then attempting to\nenable feature x but disable feature y results in both features\nbeing disabled.",
    "norm:misa_inc_ialign": "Writing misa may increase IALIGN, e.g., by disabling the \"C\"\nextension. If an instruction that would write misa increases IALIGN,\nand the subsequent instruction's address is not IALIGN-bit aligned, the\nwrite to misa is suppressed, leaving misa unchanged.",
    "norm:mvendorid_sz_acc_op": "The mvendorid CSR is a 32-bit read-only register providing the JEDEC\nmanufacturer ID of the provider of the core.",
    "norm:mvendorid_always_rd": "This register must be readable in any implementation, but a value of 0 can be returned to\nindicate the field is not implemented or that this is a non-commercial implementation.",
    "norm:mvendorid_enc": "JEDEC manufacturer IDs are ordinarily encoded as a sequence of one-byte\ncontinuation codes 0x7f, terminated by a one-byte ID not equal to\n0x7f, with an odd parity bit in the most-significant bit of each byte.\nmvendorid encodes the number of one-byte continuation codes in the\nBank field, and encodes the final byte in the Offset field, discarding\nthe parity bit.",
    "norm:marchid_sz_acc_op": "The marchid CSR is an MXLEN-bit read-only register encoding the base\nmicroarchitecture of the hart.",
    "norm:marchid_always_rd": "This register must be readable in any\nimplementation, but a value of 0 can be returned to indicate the field is not implemented.",
    "norm:mimpid_op": "The mimpid CSR provides a unique encoding of the version of the\nprocessor implementation.",
    "norm:mimpid_always_rd": "This register must be readable in any\nimplementation, but a value of 0 can be returned to indicate that the field is not implemented.",
    "norm:mhartid_sz_acc_op": "The mhartid CSR is an MXLEN-bit read-only register containing the\ninteger ID of the hardware thread running the code.",
    "norm:mhartid_always_rd": "This register must be readable in any implementation.",
    "norm:mhartid_one_is_zero": "one hart must have a hart ID of zero.",
    "norm:mhartid_unique": "Hart IDs must be unique within the execution environment.",
    "norm:mstatus_sz_acc": "The mstatus register is an MXLEN-bit read/write register formatted as\nshown in &lt;&lt;mstatusreg-rv32&gt;&gt; for RV32 and &lt;&lt;mstatusreg&gt;&gt; for RV64.",
    "norm:mstatush_sz_acc": "For RV32 only, mstatush is a 32-bit read/write register formatted as shown in &lt;&lt;mstatushreg&gt;&gt;.",
    "norm:mstatush_enc": "Bits 30:4 of mstatush generally contain the same fields found in bits 62:36 of mstatus for RV64. Fields SD, SXL, and UXL do not exist in mstatush.",
    "norm:mstatus_mie_sie_op1": "Global interrupt-enable bits, MIE and SIE, are provided for M-mode and\nS-mode respectively.",
    "norm:mstatus_mie_sie_op2": "When a hart is executing in privilege mode x, interrupts are globally\nenabled when xIE=1 and globally disabled when xIE=0.",
    "norm:mstatus_xie_intr_en_dis": "Interrupts for lower-privilege modes, w&lt;x,\nare always globally disabled regardless of the setting of any global wIE bit for the\nlower-privilege mode.  Interrupts for higher-privilege modes, y&gt;x,\nare always globally enabled regardless of the\nsetting of the global yIE bit for the higher-privilege mode.",
    "norm:mstatus_sie_spie_rdonly0": "If supervisor mode is not implemented, then SIE and SPIE are read-only 0.",
    "norm:mstatus_xpie_xpp_op": "each privilege mode x that can respond to\ninterrupts has a two-level stack of interrupt-enable bits and privilege modes.\nxPIE holds the value of the interrupt-enable bit active prior\nto the trap, and xPP holds the previous privilege mode.",
    "norm:mstatus_xpp_enc": "The xPP fields can only hold privilege modes up to x",
    "norm:mstatus_mpp_sz": "MPP is two bits wide",
    "norm:mstatus_spp_sz": "SPP is one bit wide.",
    "norm:mstatus_xpie_xie_xpp_trap_op": "When a trap is taken from privilege mode y\ninto privilege mode x, xPIE is set to the value of xIE; xIE is\nset to 0; and xPP is set to y.",
    "norm:mstatus_xret_op": "When executing an xRET instruction, supposing\nxPP holds the value y, xIE is set to xPIE; the privilege mode is\nchanged to y; xPIE is set to 1; and xPP is set to the\nleast-privileged supported mode (U if U-mode is implemented, else M). If\ny{ne}M, xRET also sets MPRV=0.",
    "norm:mstatus_xpp_warl": "xPP fields are WARL fields that can hold only privilege mode x and any implemented privilege mode lower than x.",
    "norm:mstatus_xpp_rdonly0": "If privilege mode x is not implemented, then xPP must be read-only 0.",
    "norm:mstatus_mdt_sz_warl": "The M-mode-disable-trap (MDT) bit is a WARL field introduced by the Smdbltrp extension.",
    "norm:mstatus_mdt_rst": "Upon reset, the MDT field is set to 1.",
    "norm:mstatus_mie_clr_by_mdt": "When the MDT bit is set to 1 by an explicit CSR write,\nthe MIE (Machine Interrupt Enable) bit is cleared to 0.",
    "norm:mstatus_mie_clr_by_mdt_rv64": "For RV64, this clearing occurs regardless of the value written, if any, to the MIE bit by the same write.",
    "norm:mstatus_mie_set_mdt_0": "The MIE bit can only be set to 1 by an\nexplicit CSR write if the MDT bit is already 0",
    "norm:mstatus_mie_set_mdt_0_rv64": "or, for RV64, is being set to 0 by the same write",
    "norm:trap_exp": "When a trap is to be taken into M-mode, if the MDT bit is currently 0, it is then set to 1, and the trap is delivered as expected.",
    "norm:trap_unexp_mdt_1": "However, if MDT is already set to 1, then this is an unexpected trap.",
    "norm:trap_unexp_rnmi": "When the Smrnmi extension\nis implemented, a trap caused by an RNMI is not considered an unexpected trap\nirrespective of the state of the MDT bit.",
    "norm:mstatus_mdt_not_set_rnmi": "A trap caused by an RNMI does not set the MDT bit.",
    "norm:trap_unexp_mnstatus_nmie_0": "a trap that occurs when executing in M-mode with\nmnstatus.NMIE set to 0 is an unexpected trap.",
    "norm:trap_unexp_hndl_lead-in": "In the event of a unexpected trap, the handling is as follows:",
    "norm:trap_unexp_hndl_rnmi": "When the Smrnmi extension is implemented and mnstatus.NMIE is 1, the hart\ntraps to the RNMI handler. To deliver this trap, the mnepc and mncause\nregisters are written with the values that the unexpected trap would have\nwritten to the mepc and mcause registers respectively. The privilege\nmode information fields in the mnstatus register are written to indicate\nM-mode and its NMIE field is set to 0.",
    "norm:trap_unexp_hndl_no_rnmi": "When the Smrnmi extension is not implemented, or if the Smrnmi extension is\nimplemented and mnstatus.NMIE is 0, the hart enters a critical-error state\nwithout updating any architectural state, including the pc. This state\ninvolves ceasing execution, disabling all interrupts (including NMIs), and\nasserting a critical-error signal to the platform.",
    "norm:critical-error": "The actions performed by the platform when a hart asserts a critical-error signal\nare platform-specific. The range of possible actions include restarting\nthe affected hart or restarting the entire platform, among others.",
    "norm:mstatus_mdt_clr_mret_sret": "The MRET and SRET instructions, when executed in M-mode, set the MDT bit to 0.",
    "norm:sstatus_sdt_clr_mret_sret": "If the new privilege mode is U, VS, or VU, then sstatus.SDT is also set to 0.",
    "norm:vsstatus_sdt_clr_mret_sret": "Additionally, if it is VU, then vsstatus.SDT is also set to 0.",
    "norm:mstatus_mdt_clr_mnret": "The MNRET instruction, provided by the Smrnmi extension, sets the MDT bit to 0 if the new privilege mode is not M.",
    "norm:sstatus_sdt_clr_mnret": "If it is U, VS, or VU, then sstatus.SDT is also set to 0.",
    "norm:vsstatus_sdt_clr_mnret": "Additionally, if it is VU, then vsstatus.SDT is also set to 0.",
    "norm:mstatus_sxl_uxl_warl_op": "For RV64 harts, the SXL and UXL fields are WARL fields that control the\nvalue of XLEN for S-mode and U-mode, respectively.",
    "norm:mstatus_sxl_uxl_enc": "The encoding of these fields is the same as the MXL field of misa, shown in &lt;&lt;norm:misa_mxl_enc&gt;&gt;.",
    "norm:sxlen_uxlen": "The effective XLEN in S-mode and U-mode are termed SXLEN and UXLEN, respectively.",
    "norm:mstatus_sxl_uxl_sxlen_uxlen_mxlen32": "When MXLEN=32, the SXL and UXL fields do not exist, and SXLEN=32 and UXLEN=32.",
    "norm:mstatus_sxl_acc_mxlen64": "When MXLEN=64, if S-mode is not supported, then SXL is read-only zero.\nOtherwise, it is a WARL field that encodes the current value of SXLEN.",
    "norm:mstatus_sxl_rdonly_mxlen64": "an implementation may make SXL be a read-only field whose\nvalue always ensures that SXLEN=MXLEN.",
    "norm:mstatus_uxl_acc_mxlen64": "When MXLEN=64, if U-mode is not supported, then UXL is read-only zero.\nOtherwise, it is a WARL field that encodes the current value of UXLEN.",
    "norm:mstatus_uxl_rdonly_mxlen64": "an implementation may make UXL be a read-only field whose\nvalue always ensures that UXLEN=MXLEN or UXLEN=SXLEN.",
    "norm:mstatus_uxl_legal_vals_smode": "If S-mode is implemented, the set of legal values that the UXL field may assume excludes those that would cause UXLEN to be greater than SXLEN.",
    "norm:xlen_reduction_op": "Whenever XLEN in any mode is set to a value less than the widest supported XLEN, all operations must ignore source operand register bits above the configured XLEN, and must sign-extend results to fill the entire widest supported XLEN in the destination register. Similarly, pc bits above XLEN are ignored, and when the pc is written, it is sign-extended to fill the widest supported XLEN.",
    "norm:xlen_reduction_hint_op1": "Some HINT instructions are encoded as integer computational instructions that overwrite their destination register with its current value, e.g., c.addi x8, 0. When such a HINT is executed with XLEN &lt; MXLEN and bits MXLEN..XLEN of the destination register not all equal to bit XLEN-1, it is implementation-defined whether bits MXLEN..XLEN of the destination register are unchanged or are overwritten with copies of bit XLEN-1.",
    "norm:xlen_reduction_hint_op2": "This definition allows implementations to elide register write-back for\nsome HINTs, while allowing them to execute other HINTs in the same manner as\nother integer computational instructions.\nThe implementation choice is observable only by privilege modes with an XLEN\nsetting greater than the current XLEN; it is invisible to the current\nprivilege mode.",
    "norm:mstatus_mprv_ldst_op": "When MPRV=0, explicit memory accesses\nbehave as normal, using the translation and\nprotection mechanisms of the current privilege mode. When MPRV=1, load\nand store memory addresses are translated and protected, and endianness\nis applied, as though the current privilege mode were set to MPP.",
    "norm:mstatus_mprv_inst_xlat_op": "Instruction address-translation and protection are unaffected by the\nsetting of MPRV.",
    "norm:mstatus_mprv_rdonly0_no_umode": "MPRV is read-only 0 if U-mode is not supported.",
    "norm:mstatus_mprv_clr_mret_sret_less_priv": "An MRET or SRET instruction that changes the privilege mode to a mode\nless privileged than M also sets MPRV=0.",
    "norm:mstatus_mxr_op": "When MXR=0, only loads from pages marked readable (R=1 in &lt;&lt;sv32pte&gt;&gt;) will succeed.\nWhen MXR=1, loads from pages marked either readable or executable (R=1 or\nX=1) will succeed.  MXR has no effect when page-based virtual memory is not in effect.",
    "norm:mstatus_mxr_rdonly0_no_smode": "MXR is read-only 0 if S-mode is not supported.",
    "norm:mstatus_sum_op": "When SUM=0, S-mode memory accesses to pages that are accessible by U-mode\n(U=1 in &lt;&lt;sv32pte&gt;&gt;) will fault. When SUM=1, these accesses are permitted.",
    "norm:mstatus_sum_op_no-vm": "SUM has no effect when page-based virtual memory is not in effect.",
    "norm:mstatus_sum_op_mprv_mpp": "while SUM is ordinarily ignored when not\nexecuting in S-mode, it is in effect when MPRV=1 and MPP=S.",
    "norm:mstatus_sum_rdonly0": "SUM is read-only 0 if S-mode is not supported or if satp.MODE is read-only 0.",
    "norm:mstatus_mxr_sum_op_acc_fault": "The MXR and SUM mechanisms only affect the interpretation of permissions encoded in page-table entries. In particular, they have no impact on whether access-fault exceptions are raised due to PMAs or PMP.",
    "norm:mstatus_mstatush_xbe_warl": "The MBE, SBE, and UBE bits in mstatus and mstatush are WARL fields",
    "norm:endianness_inst_fetch_little": "Instruction fetches are always little-endian.",
    "norm:mstatus_mbe_op": "MBE controls whether non-instruction-fetch memory accesses made from M-mode (assuming mstatus.MPRV=0) are little-endian (MBE=0) or big-endian (MBE=1).",
    "norm:mstatus_sbe_op": "If S-mode is not supported, SBE is read-only 0. Otherwise, SBE controls whether explicit load and store memory accesses made from S-mode are little-endian (SBE=0) or big-endian (SBE=1).",
    "norm:mstatus_ube_op": "If U-mode is not supported, UBE is read-only 0. Otherwise, UBE controls whether explicit load and store memory accesses made from U-mode are little-endian (UBE=0) or big-endian (UBE=1).",
    "norm:mstatus_sbe_implicit": "For implicit accesses to supervisor-level memory management data\nstructures, such as page tables, endianness is always controlled by SBE.",
    "norm:mstatus_sbe_change_fence": "Since changing SBE alters the implementation’s interpretation of these\ndata structures, if any such data structures remain in use across a\nchange to SBE, M-mode software must follow such a change to SBE by\nexecuting an SFENCE.VMA instruction with rs1=x0 and rs2=x0.",
    "norm:mstatus_sbe_rocopy": "If S-mode is supported, an implementation may make SBE be a read-only\ncopy of MBE.",
    "norm:mstatus_ube_rocopy": "If U-mode is supported, an implementation may make UBE be a\nread-only copy of either MBE or SBE.",
    "norm:mstatus_tvm_warl_op": "The TVM (Trap Virtual Memory) bit is a WARL field that supports intercepting supervisor virtual-memory management operations. When TVM=1, attempts to read or write the satp CSR or execute an SFENCE.VMA or SINVAL.VMA instruction while executing in S-mode will raise an illegal-instruction exception. When TVM=0, these operations are permitted in S-mode. TVM is read-only 0 when S-mode is not supported.",
    "norm:mstatus_tw_warl": "The TW (Timeout Wait) bit is a WARL field that supports intercepting the WFI\ninstruction (see &lt;&lt;wfi&gt;&gt;).",
    "norm:mstatus_tw_op": "When TW=0, the WFI\ninstruction may execute in modes less privileged than M when not prevented for\nsome other reason. When TW=1, then if WFI is executed in any\nless-privileged mode, and it does not complete within an\nimplementation-specific, bounded time limit, the WFI instruction causes\nan illegal-instruction exception.",
    "norm:mstatus_tw_always_illegal": "An implementation may have WFI always\nraise an illegal-instruction exception in modes less privileged than M when\nTW=1, even if there are pending globally-disabled interrupts when the\ninstruction is executed.",
    "norm:mstatus_tw_acc": "TW is read-only 0 when there are no modes less privileged than M.",
    "norm:mstatus_tw_umode_op": "When S-mode is implemented, then executing WFI in U-mode causes an\nillegal-instruction exception, regardless of the value of the TW bit, unless the\ninstruction completes within an implementation-specific, bounded time limit.",
    "norm:mstatus_tsr_warl": "The TSR (Trap SRET) bit is a WARL field that supports intercepting the\nsupervisor exception return instruction, SRET.",
    "norm:mstatus_tsr_op": "When TSR=1, attempts to\nexecute SRET while executing in S-mode will raise an illegal-instruction\nexception. When TSR=0, this operation is permitted in S-mode.",
    "norm:mstatus_tsr_acc": "TSR is read-only 0 when S-mode is not supported.",
    "norm:mstatus_fs_vs_warl": "The FS[1:0] and VS[1:0] WARL fields",
    "norm:mstatus_fs_op": "The FS field encodes the status of the\nfloating-point unit state, including the floating-point registers\nf0–f31 and the CSRs fcsr, frm, and fflags.",
    "norm:mstatus_vs_op": "The VS field encodes the status of the\nvector extension state, including the vector\nregisters v0–v31 and the CSRs vcsr, vxrm, vxsat, vstart,\nvl, vtype, and vlenb.",
    "norm:mstatus_xs_op1": "The XS field encodes the status of\nadditional user-mode extensions and associated state.",
    "norm:mstatus_fs_vs_xs_enc": "Status|FS and VS Meaning|XS Meaning\n===\n0\n1\n2\n3|Off\nInitial\nClean\nDirty|All off\nNone dirty or clean, some on\nNone dirty, some clean\nSome dirty\n===",
    "norm:mstatus_fs_acc1": "If the F extension is implemented, the FS field shall not be read-only zero.",
    "norm:mstatus_fs_acc2": "If neither the F extension nor S-mode is implemented, then FS is read-only zero.",
    "norm:mstatus_fs_rdonly0_s-no-f": "If S-mode is implemented but the F extension is not, FS\nmay optionally be read-only zero.",
    "norm:mstatus_vs_acc1": "If the v registers are implemented, the VS field shall not be read-only zero.",
    "norm:mstatus_vs_acc2": "If neither the v registers nor S-mode is implemented, then VS is\nread-only zero.",
    "norm:mstatus_vs_rdonly0_s-no-v": "If S-mode is implemented but the v registers are not,\nVS may optionally be read-only zero.",
    "norm:mstatus_xs_acc": "In harts without additional user extensions requiring new state, the\nXS field is read-only zero.",
    "norm:mstatus_xs_equiv": "Every additional extension with state\nprovides a CSR field that encodes the equivalent of the XS states.",
    "norm:mstatus_xs_op2": "The XS field represents a summary of all extensions' status as shown in\n&lt;&lt;norm:mstatus_fs_vs_xs_enc&gt;&gt;.",
    "norm:mstatus_sd_acc": "The SD bit is a read-only bit",
    "norm:mstatus_sd_op": "summarizes whether either the FS, VS,\nor XS fields signal the presence of some dirty state that will require\nsaving extended user context to memory.",
    "norm:mstatus_sd_rdonly0": "If FS, XS, and VS are all read-only zero, then SD is also always zero.",
    "norm:mstatus_fs_vs_xs_off_op": "When an extension's status is set to Off, any instruction that attempts\nto read or write the corresponding state will cause an\nillegal-instruction exception.",
    "norm:mstatus_fs_vs_xs_initial_op": "When the status is Initial, the corresponding\nstate should have an initial constant value.",
    "norm:mstatus_fs_vs_xs_clean_op": "When the status is Clean,\nthe corresponding state is potentially different from the initial value,\nbut matches the last value stored on a context swap.",
    "norm:mstatus_fs_vs_xs_dirty_op": "When the status is Dirty,\nthe corresponding state has potentially been modified since the last context save.",
    "norm:mstatus_fs_vs_xs_update_indep_priv": "The status fields will\nalso be updated during execution of instructions, regardless of privilege mode.",
    "norm:mstatus_fs_wr": "Changing the setting of FS has no effect on the contents of the\nfloating-point register state. In particular, setting FS=Off does not\ndestroy the state, nor does setting FS=Initial clear the contents.",
    "norm:mstatus_vs_wr": "the setting of VS has no effect on the contents of the vector\nregister state.",
    "norm:mstatus_fs_imprecise": "Implementations may choose to track the dirtiness of the floating-point\nregister state imprecisely by reporting the state to be dirty even when\nit has not been modified.\nOn some implementations, some instructions\nthat do not mutate the floating-point state may cause the state to\ntransition from Initial or Clean to Dirty.",
    "norm:mstatus_fs_no_dirty_track": "dirtiness might not be tracked at all, in which case the valid FS states\nare Off and Dirty, and an attempt to set FS to Initial or Clean causes\nit to be set to Dirty.",
    "norm:mstatus_fs_no_change_dirty": "If an instruction explicitly or implicitly writes a floating-point\nregister or the fcsr but does not alter its contents, and FS=Initial\nor FS=Clean, it is implementation-defined whether FS transitions to\nDirty.",
    "norm:mstatus_vs_imprecise": "Implementations may choose to track the dirtiness of the vector register\nstate in an analogous imprecise fashion, including possibly setting VS\nto Dirty when software attempts to set VS=Initial or VS=Clean.",
    "norm:mstatus_vs_no_change_dirty": "When VS=Initial or VS=Clean, it is implementation-defined whether an\ninstruction that writes a vector register or vector CSR but does not\nalter its contents causes VS to transition to Dirty.",
    "norm:mstatus_spelp_mpelp_op": "The Zicfilp extension adds the SPELP and MPELP fields that hold the previous\nELP, and are updated as specified in &lt;&lt;ZICFILP_FORWARD_TRAPS&gt;&gt;.",
    "norm:mstatus_spelp_mpelp_enc_lead-in": "The x`PELP` fields are encoded as follows:",
    "norm:mstatus_spelp_mpelp_enc_list": "0 - NO_LP_EXPECTED - no landing pad instruction expected.\n1 - LP_EXPECTED - a landing pad instruction is expected.",
    "norm:mtvec_sz_warl_acc": "The mtvec register is an MXLEN-bit WARL read/write register that holds\ntrap vector configuration, consisting of a vector base address (BASE)\nand a vector mode (MODE).",
    "norm:mtvec_enc": "",
    "norm:mtvec_mandatory": "The mtvec register must always be implemented",
    "norm:mtvec_rdonly": "can contain a read-only value.",
    "norm:mtvec_base_align_4B": "The value in the BASE field must\nalways be aligned on a 4-byte boundary",
    "norm:mtvec_base_align_func_mode": "the MODE setting may impose\nadditional alignment constraints on the value in the BASE field.",
    "norm:mtvec_mode_enc": "Value|Name|Description\n===\n0\n1\n≥2|Direct\nVectored\n---|All traps set pc to BASE.\nAsynchronous interrupts set pc to BASE+4×cause.\nReserved\n===",
    "norm:mtvec_mode_direct_op": "When MODE=Direct, all traps into\nmachine mode cause the pc to be set to the address in the BASE field.",
    "norm:mtvec_mode_vectored_op": "When MODE=Vectored, all synchronous exceptions into machine mode cause\nthe pc to be set to the address in the BASE field, whereas interrupts\ncause the pc to be set to the address in the BASE field plus four\ntimes the interrupt cause number.",
    "norm:reset_nmi_addr": "Reset and NMI vector locations are given in a platform specification.",
    "norm:trap_def_M-mode": "By default, all traps at any privilege level are handled in machine\nmode",
    "norm:medeleg_mideleg_op1": "implementations can provide individual read/write bits within medeleg\nand mideleg to indicate that certain exceptions and interrupts should\nbe processed directly by a lower privilege level.",
    "norm:medeleg_sz_acc": "The machine exception delegation register (medeleg) is a 64-bit read/write register.",
    "norm:mideleg_sz_acc": "The machine interrupt delegation (mideleg) register is an MXLEN-bit\nread/write register.",
    "norm:medeleg_mideleg_mandatory_S-mode": "In harts with S-mode, the medeleg and mideleg registers must\nexist",
    "norm:medeleg_mideleg_op2": "setting a bit in medeleg or mideleg will delegate the\ncorresponding trap, when occurring in S-mode or U-mode, to the S-mode\ntrap handler.",
    "norm:medeleg_mideleg_omit_wo_S-mode": "In harts without S-mode, the medeleg and mideleg registers should not exist.",
    "norm:trap_del_S-mode": "When a trap is delegated to S-mode",
    "norm:trap_del_S-mode_op": "the scause register is written\nwith the trap cause; the sepc register is written with the virtual\naddress of the instruction that took the trap; the stval register is\nwritten with an exception-specific datum; the SPP field of mstatus is\nwritten with the active privilege mode at the time of the trap; the SPIE\nfield of mstatus is written with the value of the SIE field at the\ntime of the trap; and the SIE field of mstatus is cleared.",
    "norm:trap_del_S-mode_no_M-mode": "The mcause, mepc, and mtval registers and the MPP and MPIE fields of\nmstatus are not written.",
    "norm:medeleg_mideleg_warl": "An implementation can choose to subset the delegatable traps, with the\nsupported delegatable bits found by writing one to every bit location,\nthen reading back the value in medeleg or mideleg to see which bit\npositions hold a one.",
    "norm:medeleg_no_rd1": "An implementation shall not have any bits of medeleg be read-only one",
    "norm:mideleg_no_rd1": "an implementation shall not fix as read-only one\nany bits of mideleg corresponding to machine-level interrupts",
    "norm:mideleg_rd1_lower_level": "may do so for lower-level interrupts",
    "norm:trap_never_trans_lower": "Traps never transition from a more-privileged mode to a less-privileged mode.\nFor example, if M-mode has delegated illegal-instruction\nexceptions to S-mode, and M-mode software later executes an illegal\ninstruction, the trap is taken in M-mode, rather than being delegated to S-mode.",
    "norm:trap_horiz": "traps may be taken horizontally. Using the same\nexample, if M-mode has delegated illegal-instruction exceptions to\nS-mode, and S-mode software later executes an illegal instruction, the\ntrap is taken in S-mode.",
    "norm:trap_del_intr_priv_lvl": "Delegated interrupts result in the interrupt being masked at the\ndelegator privilege level. For example, if the supervisor timer\ninterrupt (STI) is delegated to S-mode by setting mideleg[5], STIs\nwill not be taken when executing in M-mode. By contrast, if mideleg[5]\nis clear, STIs can be taken in any mode and regardless of current mode\nwill transfer control to M-mode.",
    "norm:medeleg_enc_img": "",
    "norm:medeleg_enc_txt": "medeleg has a bit position allocated for every synchronous exception\nshown in &lt;&lt;norm:mcause_exccode_enc_img&gt;&gt;, with the index of the\nbit position equal to the value returned in the mcause register",
    "norm:medelegh_sz_acc_enc_xlen32": "When XLEN=32, medelegh is a 32-bit read/write register\nthat aliases bits 63:32 of medeleg.",
    "norm:medelegh_omit_xlen64": "The medelegh register does not exist when XLEN=64.",
    "norm:mideleg_enc_img": "",
    "norm:mideleg_enc_txt": "mideleg holds trap delegation bits for individual interrupts, with the\nlayout of bits matching those in the mip register",
    "norm:medeleg_when_rd0": "For exceptions that cannot occur in less privileged modes, the\ncorresponding medeleg bits should be read-only zero. In particular,\nmedeleg[11] is read-only zero.",
    "norm:medeleg_16_no_rd0": "The medeleg[16] is read-only zero as double trap is not delegatable.",
    "norm:mip_sz_acc": "The mip register is an MXLEN-bit read/write register containing\ninformation on pending interrupts",
    "norm:mie_sz_acc": "mie is the corresponding\nMXLEN-bit read/write register containing interrupt enable bits.",
    "norm:mip_mie_enc_txt": "Interrupt cause number i (as reported in CSR mcause,\n&lt;&lt;mcause&gt;&gt;) corresponds with bit i in both mip and mie.\nBits 15:0 are allocated to standard interrupt causes only, while\nbits 16 and above are designated for platform use.",
    "norm:mip_enc_img": "",
    "norm:mie_enc_img": "",
    "norm:intr_mip_mie_op": "An interrupt i will trap to M-mode (causing the privilege mode to\nchange to M-mode) if all of the following are true: (a) either the\ncurrent privilege mode is M and the MIE bit in the mstatus register is\nset, or the current privilege mode has less privilege than M-mode;\n(b) bit i is set in both mip and mie; and (c) if register\nmideleg exists, bit i is not set in mideleg.",
    "norm:intr_mip_mie_bounded_time": "These conditions for an interrupt trap to occur must be evaluated in a\nbounded amount of time from when an interrupt becomes, or ceases to be,\npending in mip,",
    "norm:intr_mip_mie_xret_csrwr": "be evaluated immediately following the\nexecution of an xRET instruction or an explicit write to a CSR on\nwhich these interrupt trap conditions expressly depend (including mip,\nmie, mstatus, and mideleg).",
    "norm:intr_M-mode_highest_pri": "Interrupts to M-mode take priority over any interrupts to lower privilege modes.",
    "norm:mip_bits_wr_or_rdonly": "Each individual bit in register mip may be writable or may be read-only.",
    "norm:mip_bits_wr_op": "When bit i in mip is writable, a pending interrupt i\ncan be cleared by writing 0 to this bit.",
    "norm:mip_bits_rdonly_op": "If interrupt i can become pending but bit i in mip is read-only, the implementation must\nprovide some other mechanism for clearing the pending interrupt.",
    "norm:mie_bits_wr": "A bit in mie must be writable if the corresponding interrupt can ever become pending.",
    "norm:mie_bits_rdonly0": "Bits of mie that are not writable must be read-only zero.",
    "norm:mip_mie_std_enc_txt": "The standard portions (bits 15:0) of the mip and mie registers are\nformatted as shown in &lt;&lt;norm:mip_std_enc_img&gt;&gt; and &lt;&lt;norm:mie_std_enc_img&gt;&gt; respectively.",
    "norm:mip_std_enc_img": "",
    "norm:mie_std_enc_img": "",
    "norm:mip_meip_mie_meie_op": "Bits mip.MEIP and mie.MEIE are the interrupt-pending and\ninterrupt-enable bits for machine-level external interrupts.",
    "norm:mip_meip_rdonly": "MEIP is read-only in mip, and is set and cleared by a platform-specific\ninterrupt controller.",
    "norm:mip_mtip_mie_mtie_op": "Bits mip.MTIP and mie.MTIE are the interrupt-pending and\ninterrupt-enable bits for machine timer interrupts.",
    "norm:mip_mtip_rdonly": "MTIP is read-only in the mip register, and is cleared by writing to\nthe memory-mapped machine-mode timer compare register.",
    "norm:mip_msip_mie_msie_op": "Bits mip.MSIP and mie.MSIE are the interrupt-pending and\ninterrupt-enable bits for machine-level software interrupts.",
    "norm:mip_msip_rdonly": "MSIP is read-only in mip, and is written by accesses to memory-mapped control\nregisters, which are used to provide machine-level interprocessor interrupts.",
    "norm:msip_sz_acc": "A hart's memory-mapped msip register is a 32-bit read/write register",
    "norm:msip_enc": "bits 31--1 read as zero and bit 0 contains the MSIP bit.",
    "norm:msip_update_max_time": "When the memory-mapped msip register changes, it is guaranteed to be\nreflected in mip.MSIP eventually, but not necessarily immediately.",
    "norm:mip_msip_mie_msie_maybe_rdonly0": "If a system has only one hart, or\nif a platform standard supports the delivery of machine-level\ninterprocessor interrupts through external interrupts (MEI) instead,\nthen mip.MSIP and mie.MSIE may both be read-only zeros.",
    "norm:mip_sxip_mie_sxie_rdonly0": "If supervisor mode is not implemented, bits SEIP, STIP, and SSIP of\nmip and SEIE, STIE, and SSIE of mie are read-only zeros.",
    "norm:mip_seip_mie_seie_op": "If supervisor mode is implemented, bits mip.SEIP and mie.SEIE are\nthe interrupt-pending and interrupt-enable bits for supervisor-level external interrupts.",
    "norm:mip_seip_acc": "SEIP is writable in mip",
    "norm:intr_sei_op": "Supervisor-level external interrupts are made pending based on the logical-OR of the\nsoftware-writable SEIP bit and the signal from the external interrupt controller.",
    "norm:mip_seip_rdcsr": "When mip is read with a CSR instruction, the value of the\nSEIP bit returned in the rd destination register is the logical-OR of\nthe software-writable bit and the interrupt signal from the interrupt\ncontroller",
    "norm:mip_seip_wrcsr": "the signal from the interrupt controller is not used to\ncalculate the value written to SEIP. Only the software-writable SEIP bit\nparticipates in the read-modify-write sequence of a CSRRS or CSRRC instruction.",
    "norm:mip_stip_mie_stie_op": "If supervisor mode is implemented, its mip.STIP and mie.STIE are\nthe interrupt-pending and interrupt-enable bits for supervisor-level timer interrupts.",
    "norm:mip_stip_no-stimecmp_acc": "If the stimecmp register is not implemented, STIP is writable in\nmip",
    "norm:mip_stip_no-stimecmp_op2": "may be written by M-mode software to deliver timer interrupts to\nS-mode.",
    "norm:mip_stip_stimecmp_acc": "If the stimecmp (supervisor-mode timer compare) register is\nimplemented, STIP is read-only in mip",
    "norm:mip_stip_stimecmp_op2": "reflects the supervisor-level timer\ninterrupt signal resulting from stimecmp.",
    "norm:mip_stip_stimecmp_clr": "This timer interrupt signal is\ncleared by writing stimecmp with a value greater than the current time value.",
    "norm:mip_ssip_mie_ssie_op": "If supervisor mode is implemented, bits mip.SSIP and mie.SSIE are\nthe interrupt-pending and interrupt-enable bits for supervisor-level software interrupts.",
    "norm:mip_ssip_acc": "SSIP is writable in mip",
    "norm:mip_ssip_intr_ctrl": "may also be set to 1\nby a platform-specific interrupt controller.",
    "norm:mip_lcofip_mie_lcofie_op": "If the Sscofpmf extension is implemented, bits mip.LCOFIP and mie.LCOFIE\nare the interrupt-pending and interrupt-enable bits for local-counter-overflow interrupts.",
    "norm:mip_lcofip_acc": "LCOFIP is read-write in mip",
    "norm:mip_lcofip_op2": "reflects the occurrence of a local\ncounter-overflow overflow interrupt request resulting from any of the mhpmeventn.OF bits being set.",
    "norm:mip_lcofip_mie_lcofie_rdonly0": "If the Sscofpmf extension is not implemented, mip.LCOFIP and mie.LCOFIE are\nread-only zeros.",
    "norm:intr_M-mode_pri": "Multiple simultaneous interrupts destined for M-mode are handled in the\nfollowing decreasing priority order: MEI, MSI, MTI, SEI, SSI, STI, LCOFI.",
    "norm:mcycle_op": "The mcycle CSR counts the number of clock cycles executed by the processor\ncore on which the hart is running.",
    "norm:minstret_op": "The minstret CSR counts the number of instructions the hart has retired.",
    "norm:mcycle_minstret_sz": "The mcycle and minstret registers have 64-bit precision on all RV32 and RV64 harts.",
    "norm:mcycle_minstret_rst": "The counter registers have an arbitrary value after the hart is reset,\nand can be written with a given value.",
    "norm:mcycle_minstret_wr": "Any CSR write takes effect after the writing instruction has otherwise completed.",
    "norm:mcycle_shared": "The mcycle CSR may be\nshared between harts on the same core, in which case writes to mcycle\nwill be visible to those harts.",
    "norm:mhpmcounter_num": "The hardware performance monitor includes 29 additional 64-bit event\ncounters, mhpmcounter3-mhpmcounter31.",
    "norm:mhpmevent_sz_warl_op": "The event selector CSRs,\nmhpmevent3-mhpmevent31, are 64-bit WARL registers that control which\nevent causes the corresponding counter to increment.",
    "norm:mhpmevent_enc": "The meaning of these events is defined by the platform,\nbut event 0 is defined to mean \"no event.\"",
    "norm:mhpmcounter_mandatory": "All counters should be implemented",
    "norm:mhpmcounter_mhpmevent_rdonly0": "a legal implementation is to make both the counter and its corresponding event selector be read-only 0.",
    "norm:mhpmcounter_warl": "The mhpmcounters are WARL registers",
    "norm:mhpmcounter_sz": "support up to 64 bits of precision on RV32 and RV64.",
    "norm:mcycleh_minstreth_mhpmh_op": "reads of the mcycleh, minstreth, mhpmcounternh, and mhpmeventnh\nCSRs return bits 63-32 of the corresponding register, and writes change only bits 63-32.",
    "norm:mhpmeventh_presence": "The mhpmeventnh CSRs are provided only if the Sscofpmf extension is implemented.",
    "norm:mcounteren_sz": "The counter-enable mcounteren register is a 32-bit register",
    "norm:mcounteren_op": "controls the availability of the hardware performance-monitoring\ncounters to the next-lower privileged mode.",
    "norm:mcounteren_enc_img": "",
    "norm:mcounteren_inc_inaccessible": "The settings in this register only control accessibility. The act of\nreading or writing this register does not affect the underlying\ncounters, which continue to increment even when not accessible.",
    "norm:mcounteren_clr_ill_inst_exc": "When the CY, TM, IR, or HPMn bit in the mcounteren register is\nclear, attempts to read the cycle, time, instret, or\nhpmcountern register while executing in S-mode or U-mode will cause an\nillegal-instruction exception.",
    "norm:mcounteren_set_nxt_priv": "When one of these bits is set, access to\nthe corresponding register is permitted in the next implemented\nprivilege mode (S-mode if implemented, otherwise U-mode).",
    "norm:mcounteren_tm_clr": "when the TM bit in the mcounteren register is clear, attempts to\naccess the stimecmp or vstimecmp register while executing in a mode less\nprivileged than M will cause an illegal-instruction exception.",
    "norm:mcounteren_tm_set": "When this bit is set, access to the stimecmp or vstimecmp register is permitted in S-mode\nif implemented, and access to the vstimecmp register (via stimecmp) is\npermitted in VS-mode if implemented and not otherwise prevented by the TM bit in\nhcounteren.",
    "norm:cycle_instret_hpmcounter_op_rdonly": "The cycle, instret, and hpmcountern CSRs are read-only shadows of mcycle, minstret, and mhpmcounter n, respectively.",
    "norm:time_op_rdonly": "The time CSR is a read-only shadow of the memory-mapped mtime register.",
    "norm:cycleh_instreth_hpmcounternh_op_rdonly": "when XLEN=32, the cycleh, instreth and hpmcounternh CSRs\nare read-only shadows of mcycleh, minstreth and mhpmcounternh, respectively.",
    "norm:timeh_op_rdonly": "When XLEN=32, the timeh CSR is a read-only shadow of the\nupper 32 bits of the memory-mapped mtime register",
    "norm:mcounteren_flds_mandatory_warl": "In harts with U-mode, the mcounteren must be\nimplemented, but all fields are WARL",
    "norm:mcounteren_flds_rdonly0": "may be read-only zero, indicating reads to the\ncorresponding counter will cause an illegal-instruction exception when\nexecuting in a less-privileged mode.",
    "norm:mcounteren_presence": "In harts without U-mode, the mcounteren register should not exist.",
    "norm:mcounterinhibit_enc_img": "",
    "norm:mcounterinhibit_sz_warl_op1": "The counter-inhibit register mcountinhibit is a 32-bit\nWARL register that controls which of the hardware performance-monitoring counters increment.",
    "norm:mcounterinhibit_only_inc": "The settings in this register only control whether the\ncounters increment; their accessibility is not affected by the setting\nof this register.",
    "norm:mcounterinhibit_op2": "When the CY, IR, or HPMn bit in the mcountinhibit register is clear,\nthe mcycle, minstret, or mhpmcountern register increments as usual.\nWhen the CY, IR, or HPMn bit is set, the corresponding counter does\nnot increment.",
    "norm:mcounterinhibit_cy_shared": "The mcycle CSR may be shared between harts on the same core,\nin which case the mcountinhibit.CY field is also shared between those harts,\nand so writes to mcountinhibit.CY will be visible to those harts.",
    "norm:mcounterinhibit_not_impl": "If the mcountinhibit register is not implemented, the implementation\nbehaves as though the register were set to zero.",
    "norm:mscratch_sz_acc": "The mscratch register is an MXLEN-bit read/write register dedicated\nfor use by machine mode.",
    "norm:mscratch_enc_img": "",
    "norm:mepc_sz_acc": "mepc is an MXLEN-bit read/write register",
    "norm:mepc_align": "The low bit of mepc (mepc[0]) is always zero. On implementations that support only IALIGN=32, the two low bits (mepc[1:0]) are always zero.",
    "norm:mepc_bit1_dyn_ialign_op": "If an implementation allows IALIGN to be either 16 or 32 (by changing\nCSR misa, for example), then, whenever IALIGN=32, bit mepc[1] is\nmasked on reads so that it appears to be 0. This masking occurs also for\nthe implicit read by the MRET instruction. Though masked, mepc[1]\nremains writable when IALIGN=32.",
    "norm:mepc_warl": "mepc is a WARL register",
    "norm:mepc_inv_addr_conv": "Prior to writing mepc, implementations may convert an\ninvalid address into some other invalid address that mepc is capable of holding.",
    "norm:mepc_op": "When a trap is taken into M-mode, mepc is written with the virtual\naddress of the instruction that was interrupted or that encountered the\nexception. Otherwise, mepc is never written by the implementation,\nthough it may be explicitly written by software.",
    "norm:mepc_enc_img": "",
    "norm:mcause_sz_acc": "The mcause register is an MXLEN-bit read-write register",
    "norm:mcause_op": "When a trap is taken into\nM-mode, mcause is written with a code indicating the event that\ncaused the trap. Otherwise, mcause is never written by the\nimplementation, though it may be explicitly written by software.",
    "norm:mcause_intr_op": "The Interrupt bit in the mcause register is set if the trap was\ncaused by an interrupt.",
    "norm:mcause_exccode_op": "The Exception Code field contains a code identifying\nthe last exception or interrupt.",
    "norm:mcause_exccode_wlrl": "The Exception Code is a WLRL field, so is only guaranteed to hold supported exception codes.",
    "norm:mcause_enc_img": "",
    "norm:mcause_exccode_ld_ldrsv": "Note that load and load-reserved instructions generate load exceptions",
    "norm:mcause_exccode_st_sc_amo": "store, store-conditional, and AMO instructions generate\nstore/AMO exceptions.",
    "norm:mcause_exccode_pri1": "If an instruction may raise multiple synchronous exceptions, the\ndecreasing priority order of &lt;&lt;norm:exc_priority&gt;&gt; indicates which\nexception is taken and reported in mcause.",
    "norm:mcause_exccode_enc_img": "Interrupt|Exception Code|Description\n===\n1\n1\n1\n1|0\n1\n2\n3|Reserved\nSupervisor software interrupt\nReserved\nMachine software interrupt¶1\n1\n1\n1|4\n5\n6\n7|Reserved\nSupervisor timer interrupt\nReserved\nMachine timer interrupt¶1\n1\n1\n1|8\n9\n10\n11|Reserved\nSupervisor external interrupt\nReserved\nMachine external interrupt¶1\n1\n1\n1|12\n13\n14-15\n≥16|Reserved\nCounter-overflow interrupt\nReserved\nDesignated for platform use¶0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0|0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20-23\n24-31\n32-47\n48-63\n≥64|Instruction address misaligned\nInstruction access fault\nIllegal instruction\nBreakpoint\nLoad address misaligned\nLoad access fault\nStore/AMO address misaligned\nStore/AMO access fault\nEnvironment call from U-mode\nEnvironment call from S-mode\nReserved\nEnvironment call from M-mode\nInstruction page fault\nLoad page fault\nReserved\nStore/AMO page fault\nDouble trap\nReserved\nSoftware check\nHardware error\nReserved\nDesignated for custom use\nReserved\nDesignated for custom use\nReserved\n===",
    "norm:exc_priority": "Priority|Exc.Code|Description\n===\nHighest|3|Instruction address breakpoint¶|12, 1|During instruction address translation:\nFirst encountered page fault or access fault¶|1|With physical address for instruction:\nInstruction access fault¶|2\n0\n8,9,11\n3\n3|Illegal instruction\nInstruction address misaligned\nEnvironment call\nEnvironment break\nLoad/store/AMO address breakpoint¶|4,6|Optionally:\nLoad/store/AMO address misaligned¶|13, 15, 5, 7|During address translation for an explicit memory access:\nFirst encountered page fault or access fault¶|5,7|With physical address for an explicit memory access:\nLoad/store/AMO access fault¶Lowest|4,6|If not higher priority:\nLoad/store/AMO address misaligned\n===",
    "norm:mcause_exccode_pri2": "Load/store/AMO address-misaligned exceptions may have either higher or\nlower priority than load/store/AMO page-fault and access-fault exceptions.",
    "norm:menvcfg-stce": "The Sstc extension adds the STCE (STimecmp Enable) bit to menvcfg CSR. When the Sstc extension is not implemented, STCE is read-only zero. The STCE bit enables stimecmp for S-mode when set to one. When this extension is implemented and STCE in menvcfg is zero, an attempt to access stimecmp in a mode other than M-mode raises an illegal-instruction exception, STCE in henvcfg is read-only zero, and STIP in mip and sip reverts to its defined behavior as if this extension is not implemented. Further, if the H extension is implemented, then hip.VSTIP also reverts its defined behavior as if this extension is not implemented.",
    "norm:menvcfg-cbze": "The Zicboz extension adds the CBZE (Cache Block Zero instruction enable) field to menvcfg. When the CBZE field is set to 1, it enables execution of the cache block zero instruction, CBO.ZERO, in modes less privileged than M. Otherwise, the instruction raises an illegal-instruction exception in modes less privileged than M. When the Zicboz extension is not implemented, CBZE is read-only zero.",
    "norm:menvcfg-cbcfe": "The Zicbom extension adds the CBCFE (Cache Block Clean and Flush instruction Enable) field to menvcfg. When the CBCFE field is set to 1, it enables execution of the cache block clean instruction (CBO.CLEAN) and the cache block flush instruction (CBO.FLUSH) in modes less privileged than M. Otherwise, these instructions raise an illegal-instruction exception in modes less privileged than M. When the Zicbom extension is not implemented, CBCFE is read-only zero.",
    "norm:menvcfg-cbie": "The Zicbom extension adds the CBIE (Cache Block Invalidate instruction Enable)\nWARL field to menvcfg to control execution of the cache block invalidate\ninstruction (CBO.INVAL) in modes less privileged than M. When CBIE is set to\n00b, the instruction raises an illegal-instruction exception in modes less\nprivileged than M. When the Zicbom extension is not implemented, CBIE is\nread-only zero. The encoding 10b is reserved.",
    "norm:cbo-inval_m-mode_op0": "When CBIE is set to 01b\nor 11b, and when enabled for execution in modes less privileged than M, it\nbehaves as follows:",
    "norm:cbo-inval_m-mode_op1": "",
    "norm:cbo-inval_m-mode_op2": "",
    "norm:Smdbltrp_with_Smrnmi_op": "When the Smrnmi extension (&lt;&lt;rnmi&gt;&gt;) is implemented, it enables\ninvocation of the RNMI handler on a double trap in M-mode to handle the\ncritical error.",
    "norm:CTR_DEPTH": "The number of records that can be held in the buffer depends upon both the implementation (the maximum supported depth) and the CTR configuration (the software selected depth).",
    "norm:Smctr_recording_criteria": "Only qualified transfers are recorded.  Qualified transfers are those that meet the filtering criteria, which include the privilege mode and the transfer type.",
    "norm:Smctr_transfer_steps": "Recorded transfers are inserted at the write pointer, which is then incremented, while older recorded transfers may be overwritten once the buffer is full. Or the user can enable RAS (Return Address Stack) emulation mode, where only function calls are recorded, and function returns pop the last call record.  The source PC, target PC, and some optional metadata (transfer type, elapsed cycles) are stored for each recorded transfer.",
    "norm:Smctr_CTR_CSR_interface": "The CTR buffer is accessible through an indirect CSR interface, such that software can specify which logical entry in the buffer it wishes to read or write.  Logical entry 0 always corresponds to the youngest recorded transfer, followed by entry 1 as the next youngest, and so on.",
    "norm:Smctr_scope": "The machine-level extension, Smctr, encompasses all newly added Control Status Registers (CSRs), instructions, and behavior modifications for a hart across all privilege levels.",
    "norm:Ssctr_transfer_steps": "The corresponding supervisor-level extension, Ssctr, is essentially identical to Smctr, except that it excludes machine-level CSRs and behaviors not intended to be directly accessible at the supervisor level.",
    "norm:Smctr_Ssctr_depend": "Smctr and Ssctr depend on both the implementation of S-mode and the Sscsrind extension.",
    "norm:Ssctr_mctrctl-sz_acc_op": "The mctrctl register is a 64-bit read/write register that enables and configures the CTR capability.",
    "norm:mctrctl-mode_op": "Enable transfer recording in the selected privileged mode(s).",
    "norm:mctrctl-rasemu_op": "Enables RAS (Return Address Stack) Emulation Mode.",
    "norm:mctrctl-mte_op": "Enables recording of traps to M-mode when M=0.",
    "norm:mctrctl-ste_op": "Enables recording of traps to S-mode when S=0.",
    "norm:mctrctl-bpfrz_op": "Set sctrstatus.FROZEN on a breakpoint exception that traps to M-mode or S-mode.",
    "norm:mctrctl-lcofifrz_op": "Set sctrstatus.FROZEN on local-counter-overflow interrupt (LCOFI) that traps to M-mode or S-mode.",
    "norm:mctrctl-excinh_op": "Inhibit recording of exceptions.",
    "norm:mctrctl-intrinh_op": "Inhibit recording of interrupts.",
    "norm:mctrctl-tretinh_op": "Inhibit recording of trap returns.",
    "norm:mctrctl-ntbren_op": "Enable recording of not-taken branches.",
    "norm:mctrctl-tkbrinh_op": "Inhibit recording of taken branches.",
    "norm:mctrctl-indcallinh_op": "Inhibit recording of indirect calls.",
    "norm:mctrctl-dircallinh_op": "Inhibit recording of direct calls.",
    "norm:mctrctl-indjmpinh_op": "Inhibit recording of indirect jumps (without linkage).",
    "norm:mctrctl-dirjmpinh_op": "Inhibit recording of direct jumps (without linkage).",
    "norm:mctrctl-corswapinh_op": "Inhibit recording of co-routine swaps.",
    "norm:mctrctl-retinh_op": "Inhibit recording of function returns.",
    "norm:mctrctl-indljmpinh_op": "Inhibit recording of other indirect jumps (with linkage).",
    "norm:mctrctl-dirljmpinh_op": "Inhibit recording of other direct jumps (with linkage).",
    "norm:mctrctl-custom_op": "WARL bits designated for custom use.",
    "norm:mctrctl-impl": "All fields are optional except for M, S, U, and BPFRZ.  All unimplemented fields are read-only 0, while all implemented fields are writable.  If the Sscofpmf extension is implemented, LCOFIFRZ must be writable.",
    "norm:Ssctr_sctrctl_op": "The sctrctl register provides supervisor mode access to a subset of mctrctl.",
    "norm:Ssctr_sctrctl_acc": "Bits 2 and 9 in sctrctl are read-only 0. As a result, the M and MTE fields in mctrctl are not accessible through sctrctl.  All other mctrctl fields are accessible through sctrctl.",
    "norm:Ssctr_vsctrctl_sz_acc_op": "If the H extension is implemented, the vsctrctl register is a 64-bit read/write register that is VS-mode's version of supervisor register sctrctl.  When V=1, vsctrctl substitutes for the usual sctrctl, so instructions that normally read or modify sctrctl actually access vsctrctl instead.",
    "norm:vsctr-s_op": "Enable transfer recording in VS-mode.",
    "norm:vsctrctl-u_op": "Enable transfer recording in VU-mode.",
    "norm:vsctrctl-ste_op": "Enables recording of traps to VS-mode when S=0.",
    "norm:vsctrctl-bpfrz_op": "Set sctrstatus.FROZEN on a breakpoint exception that traps to VS-mode.",
    "norm:vsctrctl-lcofifrz_op": "Set sctrstatus.FROZEN on local-counter-overflow interrupt (LCOFI) that traps to VS-mode.",
    "norm:sctrdepth": "The 32-bit sctrdepth register specifies the depth of the CTR buffer.",
    "norm:sctrdepth-depth_op0": "WARL field that selects the depth of the CTR buffer.",
    "norm:sctrdepth-depth_op1": "The depth of the CTR buffer dictates the number of entries to which the hardware records transfers. For a depth of N, the hardware records transfers to entries 0..N-1. All &lt;&lt;_entry_registers, Entry Registers&gt;&gt; read as '0' and are read-only when the selected entry is in the range N to 255.  When the depth is increased, the newly accessible entries contain unspecified but legal values.",
    "norm:sctrdepth-depth_param": "It is implementation-specific which DEPTH value(s) are supported.",
    "norm:sctrdepth_mode": "Attempts to access sctrdepth from VS-mode or VU-mode raise a virtual-instruction exception, unless CTR state enable access restrictions apply.",
    "norm:sctrstatus": "The 32-bit sctrstatus register grants access to CTR status information and is updated by the hardware whenever CTR is active.  CTR is active when the current privilege mode is enabled for recording and CTR is not frozen.",
    "norm:sctrstatus-wrptr": "WARL field that indicates the physical CTR buffer entry to be written next.  It is incremented after new transfers are recorded (see &lt;&lt;Behavior&gt;&gt;), though there are exceptions when xctrctl.RASEMU=1, see &lt;&lt;RAS (Return Address Stack) Emulation Mode&gt;&gt;.  For a given CTR depth (where depth = 2^(DEPTH+4)^), WRPTR wraps to 0 on an increment when the value matches depth-1, and to depth-1 on a decrement when the value is 0.  Bits above those needed to represent depth-1 (e.g., bits 7:4 for a depth of 16) are read-only 0. On depth changes, WRPTR holds an unspecified but legal value.",
    "norm:sctrstatus-frozen_op": "Inhibit transfer recording.",
    "norm:Ssctr_sctrstatus_acc": "Undefined bits in sctrstatus are WPRI. Status fields may be added by future extensions,\nand software should ignore but preserve any fields that it does not recognize.  Undefined  bits must be implemented as read-only 0, unless a custom extension is implemented and enabled",
    "norm:siselect_acc_op": "The siselect index range 0x200 through 0x2FF is reserved for CTR logical entries 0 through 255. When siselect holds a value in this range, sireg provides access to ctrsource, sireg2 provides access to ctrtarget, and sireg3 provides access to ctrdata.  sireg4, sireg5, and sireg6 are read-only 0.",
    "norm:vsiselect_op": "When vsiselect holds a value in 0x200..0x2FF, the vsireg* registers provide access to the same CTR entry register state as the analogous sireg* registers.  There is not a separate set of entry registers for V=1.",
    "norm:ctrsource_op": "The ctrsource register contains the source program counter, which is the pc of the recorded control transfer instruction, or the epc of the recorded trap.",
    "norm:ctrsource_ctrtartget_ctrdata_Vbit": "The valid (V) bit is set by the hardware when a transfer is recorded in the selected CTR buffer entry, and implies that data in ctrsource, ctrtarget, and ctrdata is valid for this entry.",
    "norm:Ssctr_ctrsource_sz_acc_op": "ctrsource is an MXLEN-bit WARL register that must be able to hold all valid virtual or physical addresses that can serve as a pc. It need not be able to hold any invalid addresses; implementations may convert an invalid address into a valid address that the register is capable of holding.  When XLEN &lt; MXLEN, both explicit writes (by software) and implicit writes (for recorded transfers) will be zero-extended.",
    "norm:ctrtarget_op": "The ctrtarget register contains the target (destination) program counter\nof the recorded transfer.",
    "norm:ctrtarget_pc_next_br": "For a not-taken branch, ctrtarget holds the PC of the next sequential instruction following the branch.",
    "norm:ctrtarget_misp": "The optional MISP bit is set by the hardware\nwhen the recorded transfer is an instruction whose target or\ntaken/not-taken direction was mispredicted by the branch predictor. MISP\nis read-only 0 when not implemented.",
    "norm:ctrtarget_sz_acc": "ctrtarget is an MXLEN-bit WARL register that must be able to hold all valid virtual or physical addresses that can serve as a pc. It need not be able to hold any invalid addresses; implementations may convert an invalid address into a valid address that the register is capable of holding.  When XLEN &lt; MXLEN, both explicit writes (by software) and implicit writes (by recorded transfers) will be zero-extended.",
    "norm:ctrdata_sz_acc": "The ctrdata register contains metadata for the recorded transfer. This\nregister must be implemented, though all fields within it are optional.\nUnimplemented fields are read-only 0.  ctrdata is a 64-bit register.",
    "norm:ctrdata-type": "Identifies the type of the control flow transfer recorded in the entry, using the encodings listed in xref:transfer-type-defs[xrefstyle=short].  Implementations that do not support this field will report 0.",
    "norm:ctrdata-ccv": "Cycle Count Valid.",
    "norm:ctrdata-cc": "Cycle Count, composed of the Cycle Count Exponent (CCE, in\nCC[15:12]) and Cycle Count Mantissa (CCM, in CC[11:0]).",
    "norm:ctrdata_undef": "Undefined bits in ctrdata are WPRI. Undefined bits must be implemented as read-only 0, unless a &lt;&lt;_custom_extensions, custom extension&gt;&gt; is implemented and enabled.",
    "norm:sctrclr_op1": "Zeroes all  CTR &lt;&lt;_entry_registers, Entry Registers&gt;&gt;, for all DEPTH values",
    "norm:sctrclr_op2": "Zeroes the CTR cycle counter and CCV",
    "norm:sctrclr_acc": "Any read of ctrsource, ctrtarget, or ctrdata that follows SCTRCLR, such that it precedes the next qualified control transfer, will return the value 0.  Further, the first recorded transfer following SCTRCLR will have ctrdata.CCV=0.",
    "norm:sctrclr_exceptions": "SCTRCLR raises an illegal-instruction exception in U-mode, and a virtual-instruction exception in VU-mode, unless CTR state enable access restrictions apply.",
    "norm:mstateen_ctr1": "When mstateen0.CTR=1, accesses to CTR register state behave as described in &lt;&lt;CSRs&gt;&gt; and &lt;&lt;Entry Registers&gt;&gt; above, while SCTRCLR behaves as described in &lt;&lt;Supervisor CTR Clear Instruction&gt;&gt;.",
    "norm:mstateen_ctr0": "When mstateen0.CTR=0 and the privilege mode is less privileged than M-mode, the following operations raise an illegal-instruction exception:",
    "norm:mstateen_ctr0_execpt1": "Attempts to access sctrctl, vsctrctl, sctrdepth, or sctrstatus",
    "norm:mstateen_ctr0_execpt2": "Attempts to access sireg* when siselect is in 0x200..0x2FF, or vsireg* when vsiselect is in 0x200..0x2FF",
    "norm:mstateen_ctr0_execpt3": "Execution of the SCTRCLR instruction",
    "norm:mstateen_ctr0_qualified_transfer": "When mstateen0.CTR=0, qualified control transfers executed in privilege modes less privileged than M-mode will continue to implicitly update entry registers and sctrstatus.",
    "norm:hstateen_ctr": "If the H extension is implemented and mstateen0.CTR=1, the hstateen0.CTR bit controls access to supervisor CTR state when V=1.  This state includes sctrctl (really vsctrctl), sctrstatus, and sireg* (really vsireg*) when siselect (really vsiselect) is in 0x200..0x2FF.  hstateen0.CTR is read-only 0 when mstateen0.CTR=0.",
    "norm:hstateen_vs": "When mstateen0.CTR=1 and hstateen0.CTR=1, VS-mode accesses to supervisor CTR state behave as described in &lt;&lt;CSRs&gt;&gt; and &lt;&lt;Entry Registers&gt;&gt; above, while SCTRCLR behaves as described in &lt;&lt;Supervisor CTR Clear Instruction&gt;&gt;.  When mstateen0.CTR=1 and hstateen0.CTR=0, both VS-mode accesses to supervisor CTR state and VS-mode execution of SCTRCLR raise a virtual-instruction exception.",
    "norm:hstateen0_CTR0-V1_op": "When hstateen0.CTR=0, qualified control transfers executed while V=1 will continue to implicitly update entry registers and sctrstatus.",
    "norm:ctr_behavior": "CTR records qualified control transfers.  Control transfers are qualified if they meet the following criteria:",
    "norm:ctr_behavior_criteria0": "The current privilege mode is enabled",
    "norm:ctr_behavior_criteri1": "The transfer type is not inhibited",
    "norm:ctr_behavior_criteria2": "sctrstatus.FROZEN is not set",
    "norm:ctr_behavior_criteria3": "The transfer completes/retires",
    "norm:ctr_stack": "Such qualified transfers update the &lt;&lt;_entry_registers, Entry Registers&gt;&gt; at logical entry 0.  As a result, older entries are pushed down the stack; the record previously in logical entry 0 moves to logical entry 1, the record in logical entry 1 moves to logical entry 2, and so on.  If the CTR buffer is full, the oldest recorded entry (previously at entry depth-1) is lost.",
    "norm:ctr_validbit": "Recorded transfers will set the ctrsource.V bit to 1, and will update all implemented record fields.",
    "norm:trap_enabled": "Traps between enabled privilege modes are recorded as normal.",
    "norm:trap_disabled_src": "Traps from a disabled privilege mode to an enabled privilege mode are partially recorded, such that the ctrsource.PC is 0.",
    "norm:trap_disabled_tgt": "Traps from an enabled mode to a disabled mode, known as external traps, are not recorded by default.",
    "norm:trapret_enabled": "Trap returns between enabled privilege modes are recorded as normal.",
    "norm:trapret_to_disabled": "Trap returns from an enabled mode back to a disabled mode are partially recorded, such that ctrtarget.PC is 0.",
    "norm:trapret_from_disabled": "Trap returns from a disabled mode to an enabled mode are not recorded.",
    "norm:debug_recording_inhibited": "Recording in Debug Mode is always inhibited. Transfers into and out of Debug Mode are never recorded.",
    "norm:trap_ee": "Recorded",
    "norm:trap_ed": "External trap.  Not recorded by default,",
    "norm:trap_de": "Recorded, ctrsource.PC is 0.",
    "norm:trap_dd": "Not recorded.",
    "norm:trapret_ee": "Recorded.",
    "norm:trapret_ed": "Recorded, ctrtarget.PC is 0.",
    "norm:trapret_de": "Not recorded.",
    "norm:trapret_dd": "Not recorded.",
    "norm:exttrap_def": "External traps are traps from a privilege mode enabled for CTR recording to a privilege mode that is not enabled for CTR recording.  By default external traps are not recorded, but privileged software running in the target mode of the trap can opt-in to allowing CTR to record external traps into that mode. The xctrctl.xTE bits allow M-mode, S-mode, and VS-mode to opt-in separately.",
    "norm:exttrap_requirements": "External trap recording depends not only on the target mode, but on any intervening modes, which are modes that are more privileged than the source mode but less privileged than the target mode.  Not only must the external trap enable bit for the target mode be set, but the external trap enable bit(s) for any intervening modes must also be set.",
    "norm:exttrap_us": "sctrctl.STE",
    "norm:exttrap_um": "mctrctl.MTE, sctrctl.STE",
    "norm:exttrap_sm": "mctrctl.MTE",
    "norm:exttrap_vuvs": "vsctrctl.STE",
    "norm:exttrap_vuhs": "sctrctl.STE, vsctrctl.STE",
    "norm:exttrap_vum": "mctrctl.MTE, sctrctl.STE, vsctrctl.STE",
    "norm:exttrap_vshs": "sctrctl.STE",
    "norm:exttrap_vsm": "mctrctl.MTE, sctrctl.STE",
    "norm:exttrap_ctrtarget0": "In records for external traps, the ctrtarget.PC is 0.",
    "norm:exttrap_implreq": "If external trap recording is implemented, mctrctl.MTE and sctrctl.STE must be implemented, while vsctrctl.STE must be implemented if the H extension is implemented.",
    "norm:ttf_default": "Default CTR behavior, when all transfer type filter bits (xctrctl[47:32]) are unimplemented or 0, is to record all control transfers within enabled privileged modes. By setting transfer type filter bits, software can opt out of recording select transfer types, or opt into recording non-default operations.  All transfer type filter bits are optional.",
    "norm:ttype0": "Not used by CTR",
    "norm:ttype1": "Exception",
    "norm:ttype2": "Interrupt",
    "norm:ttype3": "Trap return",
    "norm:ttype4": "Not-taken branch",
    "norm:ttype5": "Taken branch",
    "norm:ttype8": "Indirect call",
    "norm:ttype9": "Direct call",
    "norm:ttype10": "Indirect jump (without linkage)",
    "norm:ttype11": "Direct jump (without linkage)",
    "norm:ttype12": "Co-routine swap",
    "norm:ttype13": "Function return",
    "norm:ttype14": "Other indirect jump (with linkage)",
    "norm:ttype15": "Other direct jump (with linkage)",
    "norm:various_jump_enc": "Encodings 8 through 15 refer to various encodings of jump instructions.  The types are distinguished as described below.",
    "norm:ctrdata_cc_supported_param": "The ctrdata register may optionally include a count of CPU cycles elapsed since the prior CTR record.  The elapsed cycle count value is represented by the CC field, which has a 12-bit mantissa component (Cycle Count Mantissa, or CCM) and a 4-bit exponent component (Cycle Count Exponent, or CCE).",
    "norm:ccounter_inc": "The elapsed cycle counter (CtrCycleCounter) increments at the same rate as the mcycle counter.  Only cycles while CTR is active are counted, where active implies that the current privilege mode is enabled for recording and CTR is not frozen.  The CC field is encoded such that CCE holds 0 if the CtrCycleCounter value is less than 4096, otherwise it holds the index of the most significant one bit in the CtrCycleCounter value, minus 11.  CCM holds CtrCycleCounter bits CCE+10:CCE-1.",
    "norm:ccounter_reset": "The CtrCycleCounter is reset on writes to xctrctl, and on execution of SCTRCLR, to ensure that any accumulated cycle counts do not persist across a context switch.",
    "norm:ccounter_impl": "An implementation that supports cycle counting must implement CCV and all\nCCM bits, but may implement 0..4 exponent bits in CCE. Unimplemented CCE\nbits are read-only 0. For implementations that support transfer type\nfiltering, it is recommended to implement at least 3 exponent bits. This\nallows capturing the full latency of most functions, when recording only\ncalls and returns.",
    "norm:ccsize0": "4095",
    "norm:ccsize1": "8191",
    "norm:ccsize2": "32764",
    "norm:ccsize3": "524224",
    "norm:ccsize4": "134201344",
    "norm:ccounter_sat": "The CC value saturates when all implemented bits in CCM and CCE are 1.",
    "norm:ccounter_ccv": "The CC value is valid only when the Cycle Count Valid (CCV) bit is set.  If CCV=0, the CC value might not hold the correct count of elapsed active cycles since the last recorded transfer.  The next record will have CCV=0 after a write to xctrctl, or execution of SCTRCLR, since CtrCycleCounter is reset.  CCV should additionally be cleared after any other implementation-specific scenarios where active cycles might not be counted in CtrCycleCounter.",
    "norm:ctrctl_rasemu_op": "When the optional xctrctl.RASEMU bit is implemented and set to 1, transfer recording behavior is altered to emulate the behavior of a return-address stack (RAS).",
    "norm:sctrstatus-frozen_set": "When sctrctl.LCOFIFRZ=1 and a local-counter-overflow interrupt\n(LCOFI) traps (as a result of an HPM counter overflow) to M-mode or to S-mode, sctrstatus.FROZEN is set by hardware. This inhibits CTR recording until software clears FROZEN. The LCOFI trap itself is not recorded.",
    "norm:freeze_bp": "Similarly, on a breakpoint exception that traps to M-mode or S-mode with sctrctl.BPFRZ=1, FROZEN is set by hardware. The breakpoint exception itself is not recorded.",
    "norm:freeze_vs": "If the H extension is implemented, freeze behavior for LCOFIs and breakpoint exceptions that trap to VS-mode is determined by the LCOFIFRZ and BPFRZ values, respectively, in vsctrctl.  This includes virtual LCOFIs pended by a hypervisor.",
    "norm:custom_bits": "Any custom CTR extension must be associated with a non-zero value within the designated custom bits in xctrctl.  When the custom bits hold a non-zero value that enables a custom extension, the extension may alter standard CTR behavior, and may define new custom status fields within sctrstatus or the CTR &lt;&lt;_entry_registers, Entry Registers&gt;&gt;.  All custom status fields, and standard status fields whose behavior is altered by the custom extension, must revert to standard behavior when the custom bits hold zero.  This includes read-only 0 behavior for any bits undefined by any implemented standard extensions.",
    "norm:sstatus": "The sstatus register is an SXLEN-bit read/write register formatted as shown in  when SXLEN=32 and  when SXLEN=64. The sstatus register keeps track of the processor&#8217;s current operating state.",
    "norm:sstatus-spp": "The SPP bit indicates the privilege level at which a hart was executing before entering supervisor mode. When a trap is taken, SPP is set to 0 if the trap originated from user mode, or 1 otherwise. When an SRET instruction (see ) is executed to return from the trap handler, the privilege level is set to user mode if the SPP bit is 0, or supervisor mode if the SPP bit is 1; SPP is then set to 0.",
    "norm:sstatus-sie": "The SIE bit enables or disables all interrupts in supervisor mode. When SIE is clear, interrupts are not taken while in supervisor mode. When the hart is running in user-mode, the value in SIE is ignored, and supervisor-level interrupts are enabled. The supervisor can disable individual interrupt sources using the sie CSR.",
    "norm:sstatus-spie": "The SPIE bit indicates whether supervisor interrupts were enabled prior to trapping into supervisor mode. When a trap is taken into supervisor mode, SPIE is set to SIE, and SIE is set to 0. When an SRET instruction is executed, SIE is set to SPIE, then SPIE is set to 1.",
    "norm:sstatus-uxl": "The UXL field controls the value of XLEN for U-mode, termed UXLEN, which may differ from the value of XLEN for S-mode, termed SXLEN. The encoding of UXL is the same as that of the MXL field of misa, shown in .",
    "norm:sstatus-uxl_sz": "When SXLEN=32, the UXL field does not exist, and UXLEN=32. When SXLEN=64, it is a WARL field that encodes the current value of UXLEN. In particular, an implementation may make UXL be a read-only field whose value always ensures that UXLEN=SXLEN.",
    "norm:sstatus-uxl_behavior": "If UXLEN≠SXLEN, instructions executed in the narrower mode must ignore source register operand bits above the configured XLEN, and must sign-extend results to fill the widest supported XLEN in the destination register.",
    "norm:hint_sxlen_param": "Some HINT instructions are encoded as integer computational instructions that overwrite their destination register with its current value, e.g., c.addi x8, 0. When such a HINT is executed with XLEN &lt; SXLEN and bits SXLEN..XLEN of the destination register not all equal to bit XLEN-1, it is implementation-defined whether bits SXLEN..XLEN of the destination register are unchanged or are overwritten with copies of bit XLEN-1.",
    "norm:sstatus-mxr": "The MXR (Make eXecutable Readable) bit modifies the privilege with which loads access virtual memory. When MXR=0, only loads from pages marked readable (R=1 in ) will succeed. When MXR=1, loads from pages marked either readable or executable (R=1 or X=1) will succeed. MXR has no effect when page-based virtual memory is not in effect.",
    "norm:sstatus-sum": "The SUM (permit Supervisor User Memory access) bit modifies the privilege with which S-mode loads and stores access virtual memory. When SUM=0, S-mode memory accesses to pages that are accessible by U-mode (U=1 in ) will fault. When SUM=1, these accesses are permitted. SUM has no effect when page-based virtual memory is not in effect, nor when executing in U-mode. Note that S-mode can never execute instructions from user pages, regardless of the state of SUM.",
    "norm:sstatus-sum_satp-mode": "SUM is read-only 0 if satp.MODE is read-only 0.",
    "norm:sstatus-ube": "The UBE bit is a WARL field that controls the endianness of explicit memory accesses made from U-mode, which may differ from the endianness of memory accesses in S-mode. An implementation may make UBE be a read-only field that always specifies the same endianness as for S-mode.",
    "norm:sstatus-ube_implicit": "UBE has no effect on instruction fetches, which are implicit memory accesses that are always little-endian.",
    "norm:sstatus-spelp": "Access to the SPELP field, added by Zicfilp, accesses the homonymous fields of mstatus when V=0, and the homonymous fields of vsstatus when V=1.",
    "norm:sstatus-sdt": "The S-mode-disable-trap (SDT) bit is a WARL field introduced by the Ssdbltrp extension to address double trap (See ) at privilege modes lower than M.",
    "norm:sstatus-sdt_sstatus-sie_overwrite": "When the SDT bit is set to 1 by an explicit CSR write, the SIE (Supervisor Interrupt Enable) bit is cleared to 0. This clearing occurs regardless of the value written, if any, to the SIE bit by the same write. The SIE bit can only be set to 1 by an explicit CSR write if the SDT bit is being set to 0 by the same write or is already 0.",
    "norm:sstatus-sdt_trap": "When a trap is to be taken into S-mode, if the SDT bit is currently 0, it is then set to 1, and the trap is delivered as expected. However, if SDT is already set to 1, then this is an unexpected trap. In the event of an unexpected trap, a double-trap exception trap is delivered into M-mode. To deliver this trap, the hart writes registers, except mcause and mtval2, with the same information that the unexpected trap would have written if it was taken into M-mode. The mtval2 register is then set to what would be otherwise written into the mcause register by the unexpected trap. The mcause register is set to 16, the double-trap exception code.",
    "norm:sstatus-sdt_sret": "An SRET instruction sets the SDT bit to 0.",
    "norm:stvec": "The stvec register is an SXLEN-bit read/write register that holds trap vector configuration, consisting of a vector base address (BASE) and a vector mode (MODE).",
    "norm:stvec_op": "The BASE field in stvec is a  field that can hold any valid virtual or physical address, subject to the following alignment constraints: the address must be 4-byte aligned, and MODE settings other than Direct might impose additional alignment constraints on the value in the BASE field.",
    "norm:stvec_sz_base": "Note that the CSR contains only bits XLEN-1 through 2 of the address BASE. When used as an address, the lower two bits are filled with zeroes to obtain an XLEN-bit address that is always aligned on a 4-byte boundary.",
    "norm:sip_sie": "The sip register is an SXLEN-bit read/write register containing information on pending interrupts, while sie is the corresponding SXLEN-bit read/write register containing interrupt enable bits. Interrupt cause number i (as reported in CSR scause, ) corresponds with bit i in both sip and sie. Bits 15:0 are allocated to standard interrupt causes only, while bits 16 and above are designated for platform use.",
    "norm:sie_sip_supervisor_strap": "An interrupt i will trap to S-mode if both of the following are true: (a) either the current privilege mode is S and the SIE bit in the sstatus register is set, or the current privilege mode has less privilege than S-mode; and (b) bit i is set in both sip and sie.",
    "norm:sie_sip_strap_time_constraint": "These conditions for an interrupt trap to occur must be evaluated in a bounded amount of time from when an interrupt becomes, or ceases to be, pending in sip, and must also be evaluated immediately following the execution of an SRET instruction or an explicit write to a CSR on which these interrupt trap conditions expressly depend (including sip, sie and sstatus).",
    "norm:s_interrupt_priority": "Interrupts to S-mode take priority over any interrupts to lower privilege modes.",
    "norm:sip_acc": "Each individual bit in register sip may be writable or may be\nread-only.",
    "norm:sip_op": "When bit i in sip is writable, a pending interrupt i\ncan be cleared by writing 0 to this bit. If interrupt i can become\npending but bit i in sip is read-only, the implementation must\nprovide some other mechanism for clearing the pending interrupt (which\nmay involve a call to the execution environment).",
    "norm:sie_acc": "A bit in sie must be writable if the corresponding interrupt can ever\nbecome pending. Bits of sie that are not writable are read-only zero.",
    "norm:sip_sie_bits_sz": "The standard portions (bits 15:0) of registers sip and sie are formatted as shown in Figures  and  respectively.",
    "norm:sip-seip_sie-seie": "Bits sip.SEIP and sie.SEIE are the interrupt-pending and interrupt-enable bits for supervisor-level external interrupts. If implemented, SEIP is read-only in sip, and is set and cleared by the execution environment, typically through a platform-specific interrupt controller.",
    "norm:sip-stip_sie-stie": "Bits sip.STIP and sie.STIE are the interrupt-pending and interrupt-enable bits for supervisor-level timer interrupts. If implemented, STIP is read-only in sip. When the Sstc extension is not implemented, STIP is set and cleared by the execution environment. When the Sstc extension is implemented, STIP reflects the timer interrupt signal resulting from stimecmp. The sip.STIP bit, in response to timer interrupts generated by stimecmp, is set by writing stimecmp with a value that is less than or equal to time, and is cleared by writing stimecmp with a value greater than time.",
    "norm:sip-ssip_sie-ssie": "Bits sip.SSIP and sie.SSIE are the interrupt-pending and interrupt-enable bits for supervisor-level software interrupts. If implemented, SSIP is writable in sip and may also be set to 1 by a platform-specific interrupt controller.",
    "norm:sip_sie_Sscofpmf": "If the Sscofpmf extension is implemented, bits sip.LCOFIP and sie.LCOFIE are the interrupt-pending and interrupt-enable bits for local-counter-overflow interrupts. LCOFIP is read-write in sip and reflects the occurrence of a local counter-overflow overflow interrupt request resulting from any of the mhpmeventn.OF bits being set. If the Sscofpmf extension is not implemented, sip.LCOFIP and sie.LCOFIE are read-only zeros.",
    "norm:sip_sie_unimpl": "Each standard interrupt type (SEI, STI, SSI, or LCOFI) may not be implemented, in which case the corresponding interrupt-pending and interrupt-enable bits are read-only zeros. All bits in sip and sie are WARL fields. The implemented interrupts may be found by writing one to every bit location in sie, then reading back to see which bit positions hold a one.",
    "norm:sip_sie_priority_bit_order": "Multiple simultaneous interrupts destined for supervisor mode are handled in the following decreasing priority order: SEI, SSI, STI, LCOFI.",
    "norm:supervisor_timer_scheduling": "The implementation must provide a facility for scheduling timer interrupts in terms of the real-time counter, time.",
    "norm:scounteren": "The counter-enable (scounteren) CSR is a 32-bit register that controls the availability of the hardware performance monitoring counters to U-mode.",
    "norm:scounteren_op": "When the CY, TM, IR, or HPMn bit in the scounteren register is clear, attempts to read the cycle, time, instret, or hpmcountern register while executing in U-mode will cause an illegal-instruction exception. When one of these bits is set, access to the corresponding register is permitted.",
    "norm:scounteren_acc": "scounteren must be implemented. However, any of the bits may be read-only zero, indicating reads to the corresponding counter will cause an exception when executing in U-mode. Hence, they are effectively WARL fields.",
    "norm:sscratch": "The sscratch CSR is an SXLEN-bit read/write register, dedicated for use by the supervisor. Typically, sscratch is used to hold a pointer to the hart-local supervisor context while the hart is executing user code. At the beginning of a trap handler, software normally uses a CSRRW instruction to swap sscratch with an integer register to obtain an initial working register.",
    "norm:sepc": "sepc is an SXLEN-bit read/write CSR formatted as shown in . The low bit of sepc (sepc[0]) is always zero. On implementations that support only IALIGN=32, the two low bits (sepc[1:0]) are always zero.",
    "norm:sepc_op_mask_ialign32": "If an implementation allows IALIGN to be either 16 or 32 (by changing CSR misa, for example), then, whenever IALIGN=32, bit sepc[1] is masked on reads so that it appears to be 0. This masking occurs also for the implicit read by the SRET instruction. Though masked, sepc[1] remains writable when IALIGN=32.",
    "norm:sepc_acc_invalid_addr": "sepc is a WARL register that must be able to hold all valid virtual addresses. It need not be capable of holding all possible invalid addresses. Prior to writing sepc, implementations may convert an invalid address into some other invalid address that sepc is capable of holding.",
    "norm:sepc_op_trap_write": "When a trap is taken into S-mode, sepc is written with the virtual address of the instruction that was interrupted or that encountered the exception. Otherwise, sepc is never written by the implementation, though it may be explicitly written by software.",
    "norm:scause": "The scause CSR is an SXLEN-bit read-write register formatted as shown in . When a trap is taken into S-mode, scause is written with a code indicating the event that caused the trap. Otherwise, scause is never written by the implementation, though it may be explicitly written by software.",
    "norm:scause-exception_code_acc": "The\nException Code is a WLRL field.",
    "norm:scause-exception_code_sz": "It is required to hold the values 0–31\n(i.e., bits 4–0 must be implemented), but otherwise it is only\nguaranteed to hold supported exception codes.",
    "norm:scause-interrupt": "The Interrupt bit in the scause register is set if the trap was caused by an interrupt. The Exception Code field contains a code identifying the last exception or interrupt.  lists the possible exception codes for the current supervisor ISAs. The Exception Code is a WLRL field. It is required to hold the values 0–31 (i.e., bits 4–0 must be implemented), but otherwise it is only guaranteed to hold supported exception codes.",
    "norm:stval": "The stval CSR is an SXLEN-bit read-write register formatted as shown in . When a trap is taken into S-mode, stval is written with exception-specific information to assist software in handling the trap. Otherwise, stval is never written by the implementation, though it may be explicitly written by software. The hardware platform will specify which exceptions must set stval informatively, which may unconditionally set it to zero, and which may exhibit either behavior, depending on the underlying event that caused the exception.",
    "norm:stval_op_faulting_addr": "If stval is written with a nonzero value when a breakpoint, address-misaligned, access-fault, page-fault, or hardware-error exception occurs on an instruction fetch, load, or store, then stval will contain the faulting virtual address.",
    "norm:stval_op_breakpoint": "On a breakpoint exception raised by an EBREAK or C.EBREAK instruction, stval is written with either zero or the virtual address of the instruction.",
    "norm:stval_op_load_store_fault": "If stval is written with a nonzero value when a misaligned load or store causes an access-fault, page-fault, or hardware-error exception, then stval will contain the virtual address of the portion of the access that caused the fault.",
    "norm:stval_faulting_address_variable_instr": "If stval is written with a nonzero value when an instruction access-fault, page-fault, or hardware-error exception occurs on a hart with variable-length instructions, then stval will contain the virtual address of the portion of the instruction that caused the fault, while sepc will point to the beginning of the instruction.",
    "norm:stval_op_illegal_instr": "The stval register can optionally also be used to return the faulting instruction bits on an illegal-instruction exception (sepc points to the faulting instruction in memory). If stval is written with a nonzero value when an illegal-instruction exception occurs, then stval will contain the shortest of:",
    "norm:stval_op_illegal_instr_format": "The value loaded into stval on an illegal-instruction exception is right-justified and all unused upper bits are cleared to zero.",
    "norm:stval_exception_info": "On a trap caused by a software-check exception, the stval register holds the cause for the exception. The following encodings are defined:",
    "norm:stval_op_other_traps": "For other traps, stval is set to zero, but a future standard may redefine stval’s setting for other traps.",
    "norm:stval_acc": "stval is a WARL register that must be able to hold all valid virtual addresses and the value 0. It need not be capable of holding all possible invalid addresses. Prior to writing stval, implementations may convert an invalid address into some other invalid address that stval is capable of holding. If the feature to return the faulting instruction bits is implemented, stval must also be able to hold all values less than 2N, where N is the smaller of SXLEN and ILEN.",
    "norm:senvcfg": "The senvcfg CSR is an SXLEN-bit read/write register, formatted as shown in , that controls certain characteristics of the U-mode execution environment.",
    "norm:senvcfg-fiom": "If bit FIOM (Fence of I/O implies Memory) is set to one in senvcfg, FENCE instructions executed in U-mode are modified so the requirement to order accesses to device I/O implies also the requirement to order main memory accesses.  details the modified interpretation of FENCE instruction bits PI, PO, SI, and SO in U-mode when FIOM=1.",
    "norm:senvcfg-fiom_op_atomic": "Similarly, for U-mode when FIOM=1, if an atomic instruction that accesses a region ordered as device I/O has its aq and/or rl bit set, then that instruction is ordered as though it accesses both device I/O and memory.",
    "norm:senvcfg-fiom_acc": "If satp.MODE is read-only zero (always Bare), the implementation may make FIOM read-only zero.",
    "norm:senvcfg-cbze": "The Zicboz extension adds the CBZE (Cache Block Zero instruction enable) field to senvcfg. The CBZE field controls execution of the cache block zero instruction (CBO.ZERO) in U-mode. Execution of CBO.ZERO in U-mode is enabled only if execution of the instruction is enabled for use in S-mode and CBZE is set to 1; otherwise, an illegal-instruction exception is raised. When the Zicboz extension is not implemented, CBZE is read-only zero.",
    "norm:senvcfg-cbcfe": "The Zicbom extension adds the CBCFE (Cache Block Clean and Flush instruction Enable) field to senvcfg to control execution of the CBO.CLEAN and CBO.FLUSH instructions in U-mode. Execution of these instructions in U-mode is enabled only if execution of these instructions is enabled for use in S-mode and CBCFE is set to 1; otherwise, an illegal-instruction exception is raised. When the Zicbom extension is not implemented, CBCFE is read-only zero.",
    "norm:senvcfg-cbie": "The Zicbom extension adds the CBIE (Cache Block Invalidate instruction Enable) WARL field to senvcfg to control execution of the CBO.INVAL instruction in U-mode. The encoding 10b is reserved. When the Zicbom extension is not implemented, CBIE is read-only zero. Execution of CBO.INVAL in U-mode is enabled only if execution of the instruction is enabled for use in S-mode and CBIE is set to 01b or 11b; otherwise, an illegal-instruction exception is raised.",
    "norm:cbo-inval_s-mode_op0": "If CBO.INVAL is enabled in S-mode to perform a flush operation, then when the\ninstruction is enabled in U-mode it performs a flush operation, even if CBIE\nis set to 11b. Otherwise, the instruction behaves as follows, depending on the\nCBIE encoding:",
    "norm:cbo-inval_s-mode_op1": "",
    "norm:cbo-inval_s-mode_op2": "",
    "norm:senvcfg-pmm_Ssnpm": "If the Ssnpm extension is implemented, the PMM field enables or disables pointer masking (see ) for the next-lower privilege mode (U/VU), according to the values in . If Ssnpm is not implemented, PMM is read-only zero. The PMM field is read-only zero for RV32.",
    "norm:senvcfg-lpe_Zicfilp": "The Zicfilp extension adds the LPE field in senvcfg. When the LPE field is set to 1, the Zicfilp extension is enabled in VU/U-mode. When the LPE field is 0, the Zicfilp extension is not enabled in VU/U-mode and the following rules apply to VU/U-mode:",
    "norm:senvcfg-sse_Zicfilp": "The Zicfiss extension adds the SSE field in senvcfg. When the SSE field is set to 1, the Zicfiss extension is activated in VU/U-mode. When the SSE field is 0, the Zicfiss extension remains inactive in VU/U-mode, and the following rules apply:",
    "norm:satp": "The satp CSR is an SXLEN-bit read/write register, formatted as shown in  for SXLEN=32 and  for SXLEN=64, which controls supervisor-mode address translation and protection. This register holds the physical page number (PPN) of the root page table, i.e., its supervisor physical address divided by 4 KiB; an address space identifier (ASID), which facilitates address-translation fences on a per-address-space basis; and the MODE field, which selects the current address-translation scheme. Further details on the access to this register are described in .",
    "norm:satp-mode": "shows the encodings of the MODE field when SXLEN=32 and SXLEN=64. When MODE=Bare, supervisor virtual addresses are equal to supervisor physical addresses, and there is no additional memory protection beyond the physical memory protection scheme described in . To select MODE=Bare, software must write zero to the remaining fields of satp (bits 30–0 when SXLEN=32, or bits 59–0 when SXLEN=64). Attempting to select MODE=Bare with a nonzero pattern in the remaining fields has an UNSPECIFIED effect on the value that the remaining fields assume and an UNSPECIFIED effect on address translation and protection behavior.",
    "norm:satp-mode_sxlen32": "When SXLEN=32, the only other valid setting for MODE is Sv32, a paged virtual-memory scheme described in .",
    "norm:satp-mode_sxlen64": "When SXLEN=64, three paged virtual-memory schemes are defined: Sv39, Sv48, and Sv57, described in , , and , respectively. One additional scheme, Sv64, will be defined in a later version of this specification. The remaining MODE settings are reserved for future use and may define different interpretations of the other fields in satp.",
    "norm:satp-mode_op_unsupported": "Implementations are not required to support all MODE settings, and if satp is written with an unsupported MODE, the entire write has no effect; no fields in satp are modified.",
    "norm:satp-asidlen": "The number of ASID bits is UNSPECIFIED and may be zero. The number of implemented ASID bits, termed ASIDLEN, may be determined by writing one to every bit position in the ASID field, then reading back the value in satp to see which bit positions in the ASID field hold a one. The least-significant bits of ASID are implemented first: that is, if ASIDLEN &gt; 0, ASID[ASIDLEN-1:0] is writable. The maximal value of ASIDLEN, termed ASIDMAX, is 9 for Sv32 or 16 for Sv39, Sv48, and Sv57.",
    "norm:satp_op_active": "The satp CSR is considered active when the effective privilege mode is S-mode or U-mode. Executions of the address-translation algorithm may only begin using a given value of satp when satp is active.",
    "norm:satp_op_sfence-vma": "Note that writing satp does not imply any ordering constraints between page-table updates and subsequent address translations, nor does it imply any invalidation of address-translation caches. If the new address space’s page tables have been modified, or if an ASID is reused, it may be necessary to execute an SFENCE.VMA instruction (see ) after, or in some cases before, writing satp.",
    "norm:stimecmp-stimecmph_sz_acc": "The stimecmp CSR is a 64-bit register and\nhas 64-bit precision on all RV32 and RV64 systems.\nIn RV32 only, accesses to the stimecmp CSR access the low 32 bits,\nwhile accesses to the stimecmph CSR access the high 32 bits of stimecmp.",
    "norm:mip_sip-stip_op": "A supervisor timer interrupt becomes pending, as reflected in the STIP bit in the mip and sip registers whenever time contains a value greater than or equal to stimecmp, treating the values as unsigned integers. If the result of this comparison changes, it is guaranteed to be reflected in STIP eventually, but not necessarily immediately. The interrupt remains posted until stimecmp becomes greater than time, typically as a result of writing stimecmp. The interrupt will be taken based on the standard interrupt enable and delegation rules.",
    "norm:sfence-vma_ordering": "Executing an SFENCE.VMA instruction guarantees that any previous stores\nalready visible to the current RISC-V hart are ordered before certain\nimplicit references by subsequent instructions in that hart to the\nmemory-management data structures. The specific set of operations\nordered by SFENCE.VMA is determined by rs1 and rs2, as described\nbelow.",
    "norm:sfence-vma_invalidation": "SFENCE.VMA is also used to invalidate entries in the\naddress-translation cache associated with a hart (see &lt;&lt;sv32algorithm&gt;&gt;).",
    "norm:sfence-vma_op": "The supervisor memory-management fence instruction SFENCE.VMA is used to synchronize updates to in-memory memory-management data structures with current execution. Instruction execution causes implicit reads and writes to these data structures; however, these implicit references are ordinarily not ordered with respect to explicit loads and stores. Executing an SFENCE.VMA instruction guarantees that any previous stores already visible to the current RISC-V hart are ordered before certain implicit references by subsequent instructions in that hart to the memory-management data structures. The specific set of operations ordered by SFENCE.VMA is determined by rs1 and rs2, as described below. SFENCE.VMA is also used to invalidate entries in the address-translation cache associated with a hart (see ). Further details on the behavior of this instruction are described in  and .",
    "norm:sfence-vma_all_asid_va": "If rs1=x0 and rs2=x0, the fence orders all reads and writes\nmade to any level of the page tables, for all address spaces. The fence\nalso invalidates all address-translation cache entries, for all address\nspaces.",
    "norm:sfence-vma_asid_only": "If rs1=x0 and rs2{ne}x0, the fence orders all\nreads and writes made to any level of the page tables, but only for the\naddress space identified by integer register rs2. Accesses to global\nmappings (see &lt;&lt;translation&gt;&gt;) are not ordered. The\nfence also invalidates all address-translation cache entries matching\nthe address space identified by integer register rs2, except for\nentries containing global mappings.",
    "norm:sfence-vma_va_all_asid": "If rs1{ne}x0 and rs2=x0, the fence orders only\nreads and writes made to leaf page table entries corresponding to the\nvirtual address in rs1, for all address spaces. The fence also\ninvalidates all address-translation cache entries that contain leaf page\ntable entries corresponding to the virtual address in rs1, for all\naddress spaces.",
    "norm:sfence-vma_va_asid": "If rs1{ne}x0 and rs2{ne}x0, the\nfence orders only reads and writes made to leaf page table entries\ncorresponding to the virtual address in rs1, for the address space\nidentified by integer register rs2. Accesses to global mappings are\nnot ordered. The fence also invalidates all address-translation cache\nentries that contain leaf page table entries corresponding to the\nvirtual address in rs1 and that match the address space identified by\ninteger register rs2, except for entries containing global mappings.",
    "norm:sfence-vma_invalid_va": "If the value held in rs1 is not a valid virtual address, then the SFENCE.VMA instruction has no effect. No exception is raised in this case.",
    "norm:sfence-vma_rs2_bits": "When rs2≠x0, bits SXLEN-1:ASIDMAX of the value held in rs2 are reserved for future standard use. Until their use is defined by a standard extension, they should be zeroed by software and ignored by current implementations. Furthermore, if ASIDLEN&lt;ASIDMAX, the implementation shall ignore bits ASIDMAX-1:ASIDLEN of the value held in rs2.",
    "norm:sfence-vma_ordering_semantics": "An implicit read of the memory-management data structures may return any translation for an address that was valid at any time since the most recent SFENCE.VMA that subsumes that address. The ordering implied by SFENCE.VMA does not place implicit reads and writes to the memory-management data structures into the global memory order in a way that interacts cleanly with the standard RVWMO ordering rules. In particular, even though an SFENCE.VMA orders prior explicit accesses before subsequent implicit accesses, and those implicit accesses are ordered before their associated explicit accesses, SFENCE.VMA does not necessarily place prior explicit accesses before subsequent explicit accesses in the global memory order. These implicit loads also need not otherwise obey normal program order semantics with respect to prior loads or stores to the same address.",
    "norm:sfence-vma_implicit_access": "Implementations must only perform implicit reads of the translation data structures pointed to by the current contents of the satp register or a subsequent valid (V=1) translation data structure entry, and must only raise exceptions for implicit accesses that are generated as a result of instruction execution, not those that are performed speculatively.",
    "norm:sfence-vma-sum-mxr_effect": "Changes to the sstatus fields SUM and MXR take effect immediately,\nwithout the need to execute an SFENCE.VMA instruction.",
    "norm:sfence-vma-mode_effect": "Changing\nsatp.MODE from Bare to other modes and vice versa also takes effect\nimmediately, without the need to execute an SFENCE.VMA instruction.",
    "norm:sfence-vma-asid_effect": "Likewise, changes to satp.ASID take effect immediately.",
    "norm:asid_hart_private": "If a hart employs an address-translation cache, that cache must appear to be private to that hart. In particular, the meaning of an ASID is local to a hart; software may choose to use the same ASID to refer to different address spaces on different harts.",
    "norm:satp-mode_roz_sfence_illegal_param": "For implementations that make satp.MODE read-only zero (always Bare), attempts to execute an SFENCE.VMA instruction might raise an illegal-instruction exception.",
    "norm:satp-ppn_sv32_sz": "22-bit physical page number (PPN)",
    "norm:fetch_page_fault_no_x": "Attempting to fetch an instruction from a page that does not have\nexecute permissions raises a fetch page-fault exception.",
    "norm:load_page_fault_no_r": "Attempting to execute a load, load-reserved, or cache-block management\ninstruction whose effective address lies\nwithin a page without read permissions raises a load page-fault exception.",
    "norm:store_page_fault_no_w": "Attempting to execute a store, store-conditional, AMO, or cache-block zero instruction\ninstruction whose effective address lies within a page without write\npermissions raises a store page-fault exception.",
    "norm:satp-ppn_sv39_sv48_sv57_sz": "44-bit PPN",
    "norm:H_mtval_nrz": "CSR mtval must not be read-only zero",
    "norm:H_vm_supported": "standard\npage-based address translation must be supported, either Sv32 for RV32,\nor a minimum of Sv39 for RV64",
    "norm:misa-h_op": "The hypervisor extension is enabled by setting bit 7 in the misa CSR",
    "norm:H_csrs_hs_not_vs": "Additional CSRs are provided to HS-mode, but not to VS-mode,\nto manage two-stage address translation and to control the behavior of a\nVS-mode guest: hstatus, hedeleg, hideleg, hvip, hip, hie,\nhgeip, hgeie, henvcfg, henvcfgh, hcounteren, htimedelta,\nhtimedeltah, htval, htinst, and hgatp.",
    "norm:H_vscsrs_sub": "When V=1, the VS CSRs substitute for the corresponding supervisor CSRs,\ntaking over all functions of the usual supervisor CSRs except as\nspecified otherwise. Instructions that normally read or modify a\nsupervisor CSR shall instead access the corresponding VS CSR.",
    "norm:H_vscsrs_acc_vs": "When V=1,\nan attempt to read or write a VS CSR directly by its own separate CSR\naddress causes a virtual-instruction exception.",
    "norm:H_vscsrs_acc_u": "Attempts from U-mode\ncause an illegal-instruction exception as usual.",
    "norm:H_vscsrs_acc_m_hs": "The VS CSRs can be\naccessed as themselves only from M-mode or HS-mode.",
    "norm:H_vscsrs_v1": "While V=1, the normal HS-level supervisor CSRs that are replaced by VS\nCSRs retain their values but do not affect the behavior of the machine\nunless specifically documented to do so.",
    "norm:H_vscsrs_v0": "when V=0, the VS\nCSRs do not ordinarily affect the behavior of the machine other than\nbeing readable and writable by CSR instructions.",
    "norm:H_scsrs_nomatch": "Some standard supervisor CSRs (senvcfg, scounteren, and scontext, possibly others) have no matching VS CSR. These supervisor CSRs continue to have their usual function and accessibility even when V=1, except with VS-mode and VU-mode substituting for HS-mode and U-mode. Hypervisor software is expected to manually swap the contents of these registers as needed.",
    "norm:hsxlen_param": "we use the term HSXLEN to refer to the effective XLEN\nwhen executing in HS-mode",
    "norm:vsxlen_param": "VSXLEN to refer to the effective XLEN\nwhen executing in VS-mode.",
    "norm:hstatus_sz_acc_op": "The hstatus register is an HSXLEN-bit read/write register formatted as shown in  when HSXLEN=32 and  when HSXLEN=64. The hstatus register provides facilities analogous to the mstatus register for tracking and controlling the exception behavior of a VS-mode guest.",
    "norm:hstatus-vsxl_op": "The VSXL field controls the effective XLEN for VS-mode (known as\nVSXLEN), which may differ from the XLEN for HS-mode (HSXLEN).",
    "norm:hstatus-vsxl_32": "When\nHSXLEN=32, the VSXL field does not exist, and VSXLEN=32.",
    "norm:hstatus-vsxl_64": "When HSXLEN=64,\nVSXL is a WARL field that is encoded the same as the MXL field of misa,\nshown in &lt;&lt;norm:misa_mxl_enc&gt;&gt;.",
    "norm:vsxl_ro_param": "In particular, an\nimplementation may make VSXL be a read-only field whose value always\nensures that VSXLEN=HSXLEN.",
    "norm:hstatus-vsxl_change": "If HSXLEN is changed from 32 to a wider width, and if field VSXL is not restricted to a single value, it gets the value corresponding to the widest supported width not wider than the new HSXLEN.",
    "norm:hstatus-vtsr_op": "When VTSR=1, an attempt in VS-mode to execute SRET raises a\nvirtual-instruction exception.",
    "norm:hstatus-vtw_op": "When VTW=1 (and assuming mstatus.TW=0),\nan attempt in VS-mode to execute WFI raises a virtual-instruction\nexception if the WFI does not complete within an\nimplementation-specific, bounded time limit.",
    "norm:vtw_virtinstr_param": "An implementation may have\nWFI always raise a virtual-instruction exception in VS-mode when VTW=1\n(and mstatus.TW=0), even if there are pending globally-disabled\ninterrupts when the instruction is executed.",
    "norm:hstatus-vtvm_op": "When VTVM=1, an attempt in\nVS-mode to execute SFENCE.VMA or SINVAL.VMA or to access CSR satp\nraises a virtual-instruction exception.",
    "norm:hstatus-vgein_op": "The VGEIN (Virtual Guest External Interrupt Number) field selects a guest external interrupt source for VS-level external interrupts. VGEIN is a WLRL field that must be able to hold values between zero and the maximum guest external interrupt number (known as GEILEN), inclusive. When VGEIN=0, no guest external interrupt source is selected for VS-level external interrupts. GEILEN may be zero, in which case VGEIN may be read-only zero. Guest external interrupts are explained in , and the use of VGEIN is covered further in .",
    "norm:hstatus-hu_op": "Field HU (Hypervisor in U-mode) controls whether the virtual-machine load/store instructions, HLV, HLVX, and HSV, can be used also in U-mode. When HU=1, these instructions can be executed in U-mode the same as in HS-mode. When HU=0, all hypervisor instructions cause an illegal-instruction exception in U-mode.",
    "norm:hstatus-spv_op": "The SPV bit (Supervisor Previous Virtualization mode) is written by the\nimplementation whenever a trap is taken into HS-mode. Just as the SPP\nbit in sstatus is set to the (nominal) privilege mode at the time of\nthe trap, the SPV bit in hstatus is set to the value of the\nvirtualization mode V at the time of the trap.",
    "norm:hstatus-spv_sret": "When an SRET instruction\nis executed when V=0, V is set to SPV.",
    "norm:hstatus-spvp_op": "When V=1 and a trap is taken into HS-mode, bit SPVP (Supervisor Previous Virtual Privilege) is set to the nominal privilege mode at the time of the trap, the same as sstatus.SPP. But if V=0 before a trap, SPVP is left unchanged on trap entry. SPVP controls the effective privilege of explicit memory accesses made by the virtual-machine load/store instructions, HLV, HLVX, and HSV.",
    "norm:hstatus-gva_op": "Field GVA (Guest Virtual Address) is written by the implementation whenever a trap is taken into HS-mode. For any trap (breakpoint, address misaligned, access fault, page fault, or guest-page fault) that writes a guest virtual address to stval, GVA is set to 1. For any other trap into HS-mode, GVA is set to 0.",
    "norm:hstatus-vsbe_op": "The VSBE bit is a WARL field that controls the endianness of explicit memory accesses made from VS-mode. If VSBE=0, explicit load and store memory accesses made from VS-mode are little-endian, and if VSBE=1, they are big-endian. VSBE also controls the endianness of all implicit accesses to VS-level memory management data structures, such as page tables. An implementation may make VSBE a read-only field that always specifies the same endianness as HS-mode.",
    "norm:hedeleg_sz_acc": "Register hedeleg is a 64-bit read/write register, formatted as shown in\n&lt;&lt;hedelegreg&gt;&gt;.",
    "norm:hideleg_sz_acc": "Register hideleg is an HSXLEN-bit read/write register, formatted as shown in\n&lt;&lt;hidelegreg&gt;&gt;.",
    "norm:hedeleg_op": "A synchronous trap that has been delegated to HS-mode (using medeleg)\nis further delegated to VS-mode if V=1 before the trap and the\ncorresponding hedeleg bit is set.",
    "norm:hdeleg_acc": "Each bit of hedeleg shall be\neither writable or read-only zero. Many bits of hedeleg are required\nspecifically to be writable or zero, as enumerated in\n&lt;&lt;hedeleg-bits&gt;&gt;. Bit 0, corresponding to\ninstruction address-misaligned exceptions, must be writable if\nIALIGN=32.",
    "norm:hedelegh_sz_acc_op": "When XLEN=32, hedelegh is a 32-bit read/write register that aliases bits 63:32 of hedeleg. Register hedelegh does not exist when XLEN=64.",
    "norm:hideleg_op": "An interrupt that has been delegated to HS-mode (using mideleg) is\nfurther delegated to VS-mode if the corresponding hideleg bit is set.",
    "norm:hideleg_acc": "Among bits 15:0 of hideleg, bits 10, 6, and 2 (corresponding to the\nstandard VS-level interrupts) are writable, and bits 12, 9, 5, and 1\n(corresponding to the standard S-level interrupts) are read-only zeros.",
    "norm:hideleg_trans": "When a virtual supervisor external interrupt (code 10) is delegated to VS-mode, it is automatically translated by the machine into a supervisor external interrupt (code 9) for VS-mode, including the value written to vscause on an interrupt trap. Likewise, a virtual supervisor timer interrupt (6) is translated into a supervisor timer interrupt (5) for VS-mode, and a virtual supervisor software interrupt (2) is translated into a supervisor software interrupt (1) for VS-mode. Similar translations may or may not be done for platform interrupt causes (codes 16 and above).",
    "norm:hvip_sz_op": "Register hvip is an HSXLEN-bit read/write register that a hypervisor can write to indicate virtual interrupts intended for VS-mode. Bits of hvip that are not writable are read-only zeros.",
    "norm:hvip_acc": "The standard portion (bits 15:0) of hvip is formatted as shown in . Bits VSEIP, VSTIP, and VSSIP of hvip are writable. Setting VSEIP=1 in hvip asserts a VS-level external interrupt; setting VSTIP asserts a VS-level timer interrupt; and setting VSSIP asserts a VS-level software interrupt.",
    "norm:hip_hie_sz_acc": "Registers hip and hie are HSXLEN-bit read/write registers that\nsupplement HS-level’s sip and sie respectively.",
    "norm:hip_op": "The hip register\nindicates pending VS-level and hypervisor-specific interrupts",
    "norm:hie_op": "hie contains enable bits for the same interrupts",
    "norm:sie_hip_hie_mutex": "For each writable bit in sie, the corresponding bit shall be read-only zero in both hip and hie. Hence, the nonzero bits in sie and hie are always mutually exclusive, and likewise for sip and hip.",
    "norm:hideleg_hs": "An interrupt i will trap to HS-mode whenever all of the following are true: (a) either the current operating mode is HS-mode and the SIE bit in the sstatus register is set, or the current operating mode has less privilege than HS-mode; (b) bit i is set in both sip and sie, or in both hip and hie; and (c) bit i is not set in hideleg.",
    "norm:hip_acc": "If bit i of sie is read-only zero, the same bit in register hip may be writable or may be read-only. When bit i in hip is writable, a pending interrupt i can be cleared by writing 0 to this bit. If interrupt i can become pending in hip but bit i in hip is read-only, then either the interrupt can be cleared by clearing bit i of hvip, or the implementation must provide some other mechanism for clearing the pending interrupt (which may involve a call to the execution environment).",
    "norm:hie_acc": "A bit in hie shall be writable if the corresponding interrupt can ever become pending in hip. Bits of hie that are not writable shall be read-only zero.",
    "norm:hip_sgeip_sgeie_acc_op": "Bits hip.SGEIP and hie.SGEIE are the interrupt-pending and interrupt-enable bits for guest external interrupts at supervisor level (HS-level). SGEIP is read-only in hip, and is 1 if and only if the bitwise logical-AND of CSRs hgeip and hgeie is nonzero in any bit. (See .)",
    "norm:hip_vseip_vseie_op": "Bits hip.VSEIP and hie.VSEIE are the interrupt-pending and interrupt-enable bits for VS-level external interrupts. VSEIP is read-only in hip, and is the logical-OR of these interrupt sources:",
    "norm:hip_vstip_vstie_acc_op": "Bits hip.VSTIP and hie.VSTIE are the interrupt-pending and interrupt-enable bits for VS-level timer interrupts. VSTIP is read-only in hip, and is the logical-OR of hvip.VSTIP and, when the Sstc extension is implemented, the timer interrupt signal resulting from vstimecmp. The hip.VSTIP bit, in response to timer interrupts generated by vstimecmp, is set by writing vstimecmp with a value that is less than or equal to the sum of time and htimedelta, truncated to 64 bits; it is cleared by writing vstimecmp with a greater value. The hip.VSTIP bit remains defined while V=0 as well as V=1.",
    "norm:hip_vssip_vssie_op": "Bits hip.VSSIP and hie.VSSIE are the interrupt-pending and interrupt-enable bits for VS-level software interrupts. VSSIP in hip is an alias (writable) of the same bit in hvip.",
    "norm:hsint_priority": "Multiple simultaneous interrupts destined for HS-mode are handled in the following decreasing priority order: SEI, SSI, STI, SGEI, VSEI, VSSI, VSTI, LCOFI.",
    "norm:hgeip_sz_acc_op": "The hgeip register is an HSXLEN-bit read-only register, formatted as\nshown in &lt;&lt;hgeipreg&gt;&gt;, that indicates pending guest\nexternal interrupts for this hart.",
    "norm:hgeie_sz_acc_op": "The hgeie register is an HSXLEN-bit\nread/write register, formatted as shown in\n&lt;&lt;hgeiereg&gt;&gt;, that contains enable bits for the\nguest external interrupts at this hart.",
    "norm:hgeip_hgeie_fields": "Guest external interrupt number\ni corresponds with bit i in both hgeip and hgeie.",
    "norm:geilen_param": "The number of bits implemented in hgeip and hgeie for guest external interrupts is UNSPECIFIED and may be zero. This number is known as GEILEN. The least-significant bits are implemented first, apart from bit 0. Hence, if GEILEN is nonzero, bits GEILEN:1 shall be writable in hgeie, and all other bit positions shall be read-only zeros in both hgeip and hgeie.",
    "norm:hgeie_op": "Register hgeie selects the subset of guest external interrupts that cause a supervisor-level (HS-level) guest external interrupt. The enable bits in hgeie do not affect the VS-level external interrupt signal selected from hgeip by hstatus.VGEIN.",
    "norm:henvcfg_sz_acc_op": "The henvcfg CSR is a 64-bit read/write register, formatted as shown in , that controls certain characteristics of the execution environment when virtualization mode V=1.",
    "norm:henvcfg-fiom_op": "If bit FIOM (Fence of I/O implies Memory) is set to one in henvcfg, FENCE instructions executed when V=1 are modified so the requirement to order accesses to device I/O implies also the requirement to order main memory accesses.  details the modified interpretation of FENCE instruction bits PI, PO, SI, and SO when FIOM=1 and V=1.",
    "norm:henvcfg-fiom_order": "Similarly, when FIOM=1 and V=1, if an atomic instruction that accesses a region ordered as device I/O has its aq and/or rl bit set, then that instruction is ordered as though it accesses both device I/O and memory.",
    "norm:henvcfg-pbmte_op": "The PBMTE bit controls whether the Svpbmt extension is available for use in VS-stage address translation. When PBMTE=1, Svpbmt is available for VS-stage address translation. When PBMTE=0, the implementation behaves as though Svpbmt were not implemented for VS-stage address translation. If Svpbmt is not implemented, PBMTE is read-only zero.",
    "norm:henvcfg-adue_op": "If the Svadu extension is implemented, the ADUE bit controls whether hardware updating of PTE A/D bits is enabled for VS-stage address translation. When ADUE=1, hardware updating of PTE A/D bits is enabled during VS-stage address translation, and the implementation behaves as though the Svade extension were not implemented for VS-mode address translation. When ADUE=0, the implementation behaves as though Svade were implemented for VS-stage address translation. If Svadu is not implemented, ADUE is read-only zero.",
    "norm:henvcfg-stce": "The Sstc extension adds the STCE (STimecmp Enable) bit to henvcfg CSR. When the Sstc extension is not implemented, STCE is read-only zero. The STCE bit enables vstimecmp for VS-mode when set to one. When STCE bit is henvcfg is zero, an attempt to access stimecmp (really vstimecmp) when V=1 raises a virtual-instruction exception, and VSTIP in hip reverts to its defined behavior as if this extension is not implemented.",
    "norm:henvcfg-cbze": "The Zicboz extension adds the CBZE (Cache Block Zero instruction enable) field to henvcfg. The CBZE field applies to execution of the cache block zero instruction (CBO.ZERO) in privilege modes VS and VU, and only when the instruction is HS-qualified. If the instruction is not HS-qualified, it raises an illegal-instruction exception. If the instruction is HS-qualified and the CBZE field is set to 1, the instruction is enabled for execution; otherwise, if the CBZE field is set to 0, it raises a virtual-instruction exception. When the Zicboz extension is not implemented, CBZE is read-only zero.",
    "norm:henvcfg-cbcfe": "The Zicbom extension adds the CBCFE (Cache Block Clean and Flush instruction Enable) field to henvcfg. When V=1, if the CBO.CLEAN and CBO.FLUSH instructions are not HS-qualified, they raise an illegal-instruction exception. If the instructions are HS-qualified and the CBCFE field is set to 1, the instructions are enabled for execution; otherwise, if the CBCFE field is set to 0, they raise a virtual-instruction exception. When the Zicbom extension is not implemented, CBCFE is read-only zero.",
    "norm:henvcfg-cbie": "The Zicbom extension adds the CBIE (Cache Block Invalidate instruction Enable) WARL field to henvcfg. The CBIE field controls execution of the cache block invalidate instruction (CBO.INVAL) in privilege modes VS and VU. The encoding 10b is reserved. When the Zicbom extension is not implemented, CBIE is read-only zero.",
    "norm:cbo-inval_h-mode_veq1_op": "When V=1, if the CBO.INVAL instruction is not HS-qualified, it raises an illegal-instruction exception. If the instruction is HS-qualified and the CBIE field is set to 01b or 11b, the instruction is enabled for execution; otherwise, it raises a virtual-instruction exception.",
    "norm:cbo-inval_h-mode_op0": "If CBO.INVAL is enabled in HS-mode to perform a flush operation, then when the\ninstruction is enabled in VS- or VU-mode it performs a flush operation, even if\nCBIE is set to 11b. Otherwise, when the instruction is enabled for\nexecution, its behavior depends on the CBIE encoding, as follows:",
    "norm:cbo-inval_h-mode_op1": "",
    "norm:cbo-inval_h-mode_op2": "",
    "norm:henvcfg-pmm_op": "If the Ssnpm extension is implemented, the PMM field enables or disables pointer masking (see ) for VS-mode, according to the values in . When the Ssnpm extension is not implemented, the PMM field is read-only zero. The PMM field is read-only zero for RV32.",
    "norm:henvcfg-lpe_op": "The Zicfilp extension adds the LPE field in henvcfg. When the LPE field is set to 1, the Zicfilp extension is enabled in VS-mode. When the LPE field is 0, the Zicfilp extension is not enabled in VS-mode and the following rules apply to VS-mode:",
    "norm:henvcfg-sse_op": "The Zicfiss extension adds the SSE field in henvcfg. If the SSE field is set to 1, the Zicfiss extension is activated in VS-mode. When the SSE field is 0, the Zicfiss extension remains inactive in VS-mode, and the following rules apply when V=1:",
    "norm:henvcfg-dte_op": "The Ssdbltrp extension adds the double-trap-enable (DTE) field in henvcfg. When henvcfg.DTE is zero, the implementation behaves as though Ssdbltrp is not implemented for VS-mode and the vsstatus.SDT bit is read-only zero.",
    "norm:henvcfgh_sz_acc_op": "When XLEN=32, henvcfgh is a 32-bit read/write register that aliases bits 63:32 of henvcfg. Register henvcfgh does not exist when XLEN=64.",
    "norm:hcounteren_sz": "The counter-enable register hcounteren is a 32-bit register that controls the availability of the hardware performance monitoring counters to the guest virtual machine.",
    "norm:hcounteren_op": "When the CY, TM, IR, or HPMn bit in the hcounteren register is clear, attempts to read the cycle, time, instret, or hpmcounter n register while V=1 will cause a virtual-instruction exception if the same bit in mcounteren is 1. When one of these bits is set, access to the corresponding register is permitted when V=1, unless prevented for some other reason. In VU-mode, a counter is not readable unless the applicable bits are set in both hcounteren and scounteren.",
    "norm:hcounteren_acc": "In addition, when the TM bit in the hcounteren register is clear, attempts to access the vstimecmp register (via stimecmp) while executing in VS-mode will cause a virtual-instruction exception if the same bit in mcounteren is set. When this bit and the same bit in mcounteren are both set, access to the vstimecmp register (if implemented) is permitted in VS-mode.",
    "norm:hcounteren_warl": "hcounteren must be implemented. However, any of the bits may be read-only zero, indicating reads to the corresponding counter will cause an exception when V=1. Hence, they are effectively WARL fields.",
    "norm:htimedelta_sz_acc_op": "The htimedelta CSR is a 64-bit read/write register\nthat contains the delta\nbetween the value of the time CSR and the value returned in VS-mode or\nVU-mode. That is, reading the time CSR in VS or VU mode returns the\nsum of the contents of htimedelta and the actual value of time.",
    "norm:htimedeltah_sz_acc_op": "When XLEN=32, htimedeltah is a 32-bit read/write register that aliases bits 63:32 of htimedelta. Register htimedeltah does not exist when XLEN=64.",
    "norm:time_htimedelta_req": "If the time CSR is implemented, htimedelta (and htimedeltah for XLEN=32) must be implemented.",
    "norm:htval_sz_acc_op": "The htval register is an HSXLEN-bit read/write register formatted as shown in . When a trap is taken into HS-mode, htval is written with additional exception-specific information, alongside stval, to assist software in handling the trap.",
    "norm:htval_trapval_param": "When a guest-page-fault trap is taken into HS-mode, htval is written with either zero or the guest physical address that faulted, shifted right by 2 bits. For other traps, htval is set to zero, but a future standard or extension may redefine htval&#8217;s setting for other traps.",
    "norm:htval_val": "htval is a WARL register that must be able to hold zero and may be capable of holding only an arbitrary subset of other 2-bit-shifted guest physical addresses, if any.",
    "norm:htinst_sz_acc_op": "The htinst register is an HSXLEN-bit read/write register formatted as shown in . When a trap is taken into HS-mode, htinst is written with a value that, if nonzero, provides information about the instruction that trapped, to assist software in handling the trap. The values that may be written to htinst on a trap are documented in .",
    "norm:htinst_val": "htinst is a WARL register that need only be able to hold the values that the implementation may automatically write to it on a trap.",
    "norm:hgatp_sz_acc_op": "The hgatp register is an HSXLEN-bit read/write register, formatted as\nshown in &lt;&lt;rv32hgatp&gt;&gt; for HSXLEN=32 and\n&lt;&lt;rv64hgatp&gt;&gt; for HSXLEN=64, which controls\nG-stage address translation and protection, the second stage of\ntwo-stage translation for guest virtual addresses (see\n&lt;&lt;two-stage-translation&gt;&gt;).",
    "norm:hgatp_tvm_illegal": "When mstatus.TVM=1, attempts to read or write hgatp while\nexecuting in HS-mode will raise an illegal-instruction exception.",
    "norm:hgatp-mode_bare": "&lt;&lt;hgatp-mode&gt;&gt; shows the encodings of the MODE field when\nHSXLEN=32 and HSXLEN=64. When MODE=Bare, guest physical addresses are\nequal to supervisor physical addresses, and there is no further memory\nprotection for a guest virtual machine beyond the physical memory\nprotection scheme described in &lt;&lt;pmp&gt;&gt;. In this\ncase, software must write zero to the remaining fields in hgatp.",
    "norm:hgatp-mode_sv": "When HSXLEN=32, the only other valid setting for MODE is Sv32x4, which is a modification of the usual Sv32 paged virtual-memory scheme, extended to support 34-bit guest physical addresses. When HSXLEN=64, modes Sv39x4, Sv48x4, and Sv57x4 are defined as modifications of the Sv39, Sv48, and Sv57 paged virtual-memory schemes. All of these paged virtual-memory schemes are described in .",
    "norm:hgatp-mode_warl": "A write to hgatp with an unsupported MODE value is not ignored as it is for satp. Instead, the fields of hgatp are WARL in the normal way, when so indicated.",
    "norm:hgatp-ppn_op": "As explained in , for the paged virtual-memory schemes (Sv32x4, Sv39x4, Sv48x4, and Sv57x4), the root page table is 16 KiB and must be aligned to a 16-KiB boundary. In these modes, the lowest two bits of the physical page number (PPN) in hgatp always read as zeros. An implementation that supports only the defined paged virtual-memory schemes and/or Bare may make PPN[1:0] read-only zero.",
    "norm:hgatp-vmid_param": "The number of VMID bits is UNSPECIFIED and may be zero.",
    "norm:hgatp-vmid_lsbs": "The\nleast-significant bits of VMID are implemented first: that is, if\nVMIDLEN &gt; 0, VMID[VMIDLEN-1:0] is writable. The maximal\nvalue of VMIDLEN, termed VMIDMAX, is 7 for Sv32x4 or 14 for Sv39x4,\nSv48x4, and Sv57x4.",
    "norm:vsstatus_sz_acc_op": "The vsstatus register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register sstatus, formatted as shown in  when VSXLEN=32 and  when VSXLEN=64. When V=1, vsstatus substitutes for the usual sstatus, so instructions that normally read or modify sstatus actually access vsstatus instead.",
    "norm:vsstatus-uxl_op": "The UXL field controls the effective XLEN for VU-mode, which may differ from the XLEN for VS-mode (VSXLEN). When VSXLEN=32, the UXL field does not exist, and VU-mode XLEN=32. When VSXLEN=64, UXL is a WARL field that is encoded the same as the MXL field of misa, shown in . In particular, an implementation may make UXL be a read-only copy of field VSXL of hstatus, forcing VU-mode XLEN=VSXLEN.",
    "norm:vsstatus-uxl_change": "If VSXLEN is changed from 32 to a wider width, and if field UXL is not restricted to a single value, it gets the value corresponding to the widest supported width not wider than the new VSXLEN.",
    "norm:vsstatus-fs_op": "When V=1, both vsstatus.FS and the HS-level sstatus.FS are in effect. Attempts to execute a floating-point instruction when either field is 0 (Off) raise an illegal-instruction exception. Modifying the floating-point state when V=1 causes both fields to be set to 3 (Dirty).",
    "norm:vsstatus-vs_op": "Similarly, when V=1, both vsstatus.VS and the HS-level sstatus.VS are in effect. Attempts to execute a vector instruction when either field is 0 (Off) raise an illegal-instruction exception. Modifying the vector state when V=1 causes both fields to be set to 3 (Dirty).",
    "norm:vsstatus-sd_xs_op": "Read-only fields SD and XS summarize the extension context status as it is visible to VS-mode only. For example, the value of the HS-level sstatus.FS does not affect vsstatus.SD.",
    "norm:vsstatus-ube_param": "An implementation may make field UBE be a read-only copy of hstatus.VSBE.",
    "norm:vsstatus_v0": "When V=0, vsstatus does not directly affect the behavior of the machine, unless a virtual-machine load/store (HLV, HLVX, or HSV) or the MPRV feature in the mstatus register is used to execute a load or store as though V=1.",
    "norm:vsstatus-spelp_op": "The Zicfilp extension adds the SPELP field that holds the previous ELP, and is updated as specified in . The SPELP field is encoded as follows:",
    "norm:vsstatus-sdt_op": "The Ssdbltrp adds an S-mode-disable-trap (SDT) field extension to address double trap (See ) in VS-mode.",
    "norm:vsip_vsie_sz_acc_op": "The vsip and vsie registers are VSXLEN-bit read/write registers that are VS-mode’s versions of supervisor CSRs sip and sie, formatted as shown in  and  respectively. When V=1, vsip and vsie substitute for the usual sip and sie, so instructions that normally read or modify sip/sie actually access vsip/vsie instead. However, interrupts directed to HS-level continue to be indicated in the HS-level sip register, not in vsip, when V=1.",
    "norm:vsip_vsie-lcofi": "Extension Shlcofideleg supports delegating LCOFI interrupts to VS-mode. If the Shlcofideleg extension is implemented, hideleg bit 13 is writable; otherwise, it is read-only zero. When bit 13 of hideleg is zero, vsip.LCOFIP and vsie.LCOFIE are read-only zeros. Else, vsip.LCOFIP and vsie.LCOFIE are aliases of sip.LCOFIP and sie.LCOFIE.",
    "norm:vsip_vsie-sei": "When bit 10 of hideleg is zero, vsip.SEIP and vsie.SEIE are read-only zeros. Else, vsip.SEIP and vsie.SEIE are aliases of hip.VSEIP and hie.VSEIE.",
    "norm:vsip_vsie-sti": "When bit 6 of hideleg is zero, vsip.STIP and vsie.STIE are read-only zeros. Else, vsip.STIP and vsie.STIE are aliases of hip.VSTIP and hie.VSTIE.",
    "norm:vsip_vsie-ssi": "When bit 2 of hideleg is zero, vsip.SSIP and vsie.SSIE are read-only zeros. Else, vsip.SSIP and vsie.SSIE are aliases of hip.VSSIP and hie.VSSIE.",
    "norm:vstvec_sz_acc_op": "The vstvec register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register stvec, formatted as shown in . When V=1, vstvec substitutes for the usual stvec, so instructions that normally read or modify stvec actually access vstvec instead. When V=0, vstvec does not directly affect the behavior of the machine.",
    "norm:vsscratch_sz_acc_op": "The vsscratch register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register sscratch, formatted as shown in . When V=1, vsscratch substitutes for the usual sscratch, so instructions that normally read or modify sscratch actually access vsscratch instead. The contents of vsscratch never directly affect the behavior of the machine.",
    "norm:vspec_sz_acc_op": "The vsepc register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register sepc, formatted as shown in . When V=1, vsepc substitutes for the usual sepc, so instructions that normally read or modify sepc actually access vsepc instead. When V=0, vsepc does not directly affect the behavior of the machine.",
    "norm:vsepc_warl": "vsepc is a WARL register that must be able to hold the same set of values that sepc can hold.",
    "norm:vscause_sz_acc_op": "The vscause register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register scause, formatted as shown in . When V=1, vscause substitutes for the usual scause, so instructions that normally read or modify scause actually access vscause instead. When V=0, vscause does not directly affect the behavior of the machine.",
    "norm:vscause_warl": "vscause is a WLRL register that must be able to hold the same set of values that scause can hold.",
    "norm:vstval_sz_acc_op": "The vstval register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register stval, formatted as shown in . When V=1, vstval substitutes for the usual stval, so instructions that normally read or modify stval actually access vstval instead. When V=0, vstval does not directly affect the behavior of the machine.",
    "norm:vstval_warl": "vstval is a WARL register that must be able to hold the same set of values that stval can hold.",
    "norm:vsatp_sz_acc_op": "The vsatp register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register satp, formatted as shown in  for VSXLEN=32 and  for VSXLEN=64. When V=1, vsatp substitutes for the usual satp, so instructions that normally read or modify satp actually access vsatp instead. vsatp controls VS-stage address translation, the first stage of two-stage translation for guest virtual addresses (see ).",
    "norm:vsatp_mode_unsupported_v0": "When V=0, a write to vsatp with an unsupported MODE value is either\nignored as it is for satp, or the fields of vsatp are treated as WARL in\nthe normal way.",
    "norm:vsatp_mode_unsupported_v1": "However, when V=1, a write to satp with an unsupported\nMODE value is ignored and no write to vsatp is effected.",
    "norm:vsatp_v0": "When V=0, vsatp does not directly affect the behavior of the machine, unless a virtual-machine load/store (HLV, HLVX, or HSV) or the MPRV feature in the mstatus register is used to execute a load or store as though V=1.",
    "norm:vstimecmp_sz": "The vstimecmp CSR is a 64-bit register and has 64-bit precision on all RV32\nand RV64 systems.",
    "norm:vstimecmp_acc": "In RV32 only, accesses to the vstimecmp CSR access the low\n32 bits, while accesses to the vstimecmph CSR access the high 32 bits of\nvstimecmp.",
    "norm:hip-vstip_op": "A virtual supervisor timer interrupt becomes pending, as reflected in the\nVSTIP bit in the hip register, whenever (time + htimedelta), truncated\nto 64 bits, contains a value greater than or equal to vstimecmp, treating\nthe values as unsigned integers.",
    "norm:hip-vstip_clear": "If the result of this comparison changes, it is guaranteed to be reflected in\nVSTIP eventually, but not necessarily immediately.\nThe interrupt remains posted until vstimecmp becomes greater than (time\n+ htimedelta), typically as a result of writing vstimecmp.",
    "norm:hip-vstip_enable": "The interrupt will be taken based on the standard interrupt enable and\ndelegation rules while V=1.",
    "norm:hlsv_mode": "The hypervisor virtual-machine load and store instructions are valid\nonly in M-mode or HS-mode, or in U-mode when hstatus.HU=1.",
    "norm:hlsv_priv": "Each\ninstruction performs an explicit memory access with an effective privilege mode\nof VS or VU. The effective privilege mode of the explicit memory access is VU\nwhen hstatus.SPVP=0, and VS when hstatus.SPVP=1.",
    "norm:hlsv_trans": "As usual for VS-mode and\nVU-mode, two-stage address translation is applied, and\nthe HS-level sstatus.SUM is ignored.",
    "norm:hlsv_sstatus-mxr": "HS-level sstatus.MXR makes\nexecute-only pages readable by explicit loads for both stages of address translation\n(VS-stage and G-stage)",
    "norm:hlsv_vsstatus-mxr": "vsstatus.MXR affects only the first\ntranslation stage (VS-stage).",
    "norm:hlsv_op": "For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU, and LD, there is a corresponding virtual-machine load instruction: HLV.B, HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU, HLV.D, and HSV.D are not valid for RV32, of course.",
    "norm:hlsv_u_op": "Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU, except that execute permission takes the place of read permission during address translation. That is, the memory being read must be executable in both stages of address translation, but read permission is not required. For the supervisor physical address that results from address translation, the supervisor physical memory attributes must grant both execute and read permissions. (The supervisor physical memory attributes are the machine’s physical memory attributes as modified by physical memory protection, , for supervisor level.)",
    "norm:hlvx-wu_valid32": "HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For RV32, HLVX.WU can be considered a variant of HLV.W, as sign extension is irrelevant for 32-bit values.)",
    "norm:hlsv_virtinst": "Attempts to execute a virtual-machine load/store instruction (HLV, HLVX,\nor HSV) when V=1 cause a virtual-instruction exception.",
    "norm:hlsv_illegalinst": "Attempts to execute one of these same instructions from U-mode when hstatus.HU=0 cause an\nillegal-instruction exception.",
    "norm:hfence-vvma_hfence-gvma_op": "The hypervisor memory-management fence instructions, HFENCE.VVMA and HFENCE.GVMA, perform a function similar to SFENCE.VMA (), except applying to the VS-level memory-management data structures controlled by CSR vsatp (HFENCE.VVMA) or the guest-physical memory-management data structures controlled by CSR hgatp (HFENCE.GVMA). Instruction SFENCE.VMA applies only to the memory-management data structures controlled by the current satp (either the HS-level satp when V=0 or vsatp when V=1).",
    "norm:hfence-vvma_mode": "HFENCE.VVMA is valid only in M-mode or HS-mode. Its effect is much the same as temporarily entering VS-mode and executing SFENCE.VMA. Executing an HFENCE.VVMA guarantees that any previous stores already visible to the current hart are ordered before all implicit reads by that hart done for VS-stage address translation for instructions that",
    "norm:hfence-vvma_limits": "Implicit reads need not be ordered when hgatp.VMID is different than at the time HFENCE.VVMA executed. If operand rs1≠x0, it specifies a single guest virtual address, and if operand rs2≠x0, it specifies a single guest address-space identifier (ASID).",
    "norm:hfence-vvma_asid": "When rs2≠x0, bits XLEN-1:ASIDMAX of the value held in rs2 are reserved for future standard use. Until their use is defined by a standard extension, they should be zeroed by software and ignored by current implementations. Furthermore, if ASIDLEN &lt; ASIDMAX, the implementation shall ignore bits ASIDMAX-1:ASIDLEN of the value held in rs2.",
    "norm:hfence-vvma_tvm": "Neither mstatus.TVM nor hstatus.VTVM causes HFENCE.VVMA to trap.",
    "norm:hfence-gvma_op": "HFENCE.GVMA is valid only in HS-mode when mstatus.TVM=0, or in M-mode (irrespective of mstatus.TVM). Executing an HFENCE.GVMA instruction guarantees that any previous stores already visible to the current hart are ordered before all implicit reads by that hart done for G-stage address translation for instructions that follow the HFENCE.GVMA. If operand rs1≠x0, it specifies a single guest physical address, shifted right by 2 bits, and if operand rs2≠x0, it specifies a single virtual machine identifier (VMID).",
    "norm:hfence-gvma_vmid": "When rs2≠x0, bits XLEN-1:VMIDMAX of the value held in rs2 are reserved for future standard use. Until their use is defined by a standard extension, they should be zeroed by software and ignored by current implementations. Furthermore, if VMIDLEN &lt; VMIDMAX, the implementation shall ignore bits VMIDMAX-1:VMIDLEN of the value held in rs2.",
    "norm:hfence-gvma_mode": "If hgatp.MODE is changed for a given VMID, an HFENCE.GVMA with rs1=x0 (and rs2 set to either x0 or the VMID) must be executed to order subsequent guest translations with the MODE change—even if the old MODE or new MODE is Bare.",
    "norm:hfence-vvma_hfence-gvma_exceptions": "Attempts to execute HFENCE.VVMA or HFENCE.GVMA when V=1 cause a virtual-instruction exception, while attempts to do the same in U-mode cause an illegal-instruction exception. Attempting to execute HFENCE.GVMA in HS-mode when mstatus.TVM=1 also causes an illegal-instruction exception.",
    "norm:mstatus_mpv_op": "The MPV bit (Machine Previous Virtualization Mode) is written by the implementation whenever a trap is taken into M-mode. Just as the MPP field is set to the (nominal) privilege mode at the time of the trap, the MPV bit is set to the value of the virtualization mode V at the time of the trap. When an MRET instruction is executed, the virtualization mode V is set to MPV, unless MPP=3, in which case V remains 0.",
    "norm:mstatus_gva_op": "Field GVA (Guest Virtual Address) is written by the implementation whenever a trap is taken into M-mode. For any trap (breakpoint, address misaligned, access fault, page fault, or guest-page fault) that writes a guest virtual address to mtval, GVA is set to 1. For any other trap into M-mode, GVA is set to 0.",
    "norm:mstatus_modes": "The TSR and TVM fields of mstatus affect execution only in HS-mode, not in VS-mode. The TW field affects execution in all modes except M-mode.",
    "norm:mstatus_tvm_hs": "Setting TVM=1 prevents HS-mode from accessing hgatp or executing HFENCE.GVMA or HINVAL.GVMA, but has no effect on accesses to vsatp or instructions HFENCE.VVMA or HINVAL.VVMA.",
    "norm:mstatus_mprv_hypervisor": "The hypervisor extension changes the behavior of the Modify Privilege field, MPRV, of mstatus. When MPRV=0, translation and protection behave as normal. When MPRV=1, explicit memory accesses are translated and protected, and endianness is applied, as though the current virtualization mode were set to MPV and the current nominal privilege mode were set to MPP.  enumerates the cases.",
    "norm:mstatus_mprv_hlsv": "MPRV does not affect the virtual-machine load/store instructions, HLV, HLVX, and HSV. The explicit loads and stores of these instructions always act as though V=1 and the nominal privilege mode were hstatus.SPVP, overriding MPRV.",
    "norm:mideleg_acc_h": "When the hypervisor extension is implemented, bits 10, 6, and 2 of mideleg (corresponding to the standard VS-level interrupts) are each read-only one. Furthermore, if any guest external interrupts are implemented (GEILEN is nonzero), bit 12 of mideleg (corresponding to supervisor-level guest external interrupts) is also read-only one. VS-level interrupts and guest external interrupts are always delegated past M-mode to HS-mode.",
    "norm:mideleg_hroz": "For bits of mideleg that are zero, the corresponding bits in hideleg, hip, and hie are read-only zeros.",
    "norm:mip_mie_vs": "The hypervisor extension gives registers mip and mie additional active bits for the hypervisor-added interrupts.  and  show the standard portions (bits 15:0) of registers mip and mie when the hypervisor extension is implemented.",
    "norm:mip_mie_alias": "Bits SGEIP, VSEIP, VSTIP, and VSSIP in mip are aliases for the same bits in hypervisor CSR hip, while SGEIE, VSEIE, VSTIE, and VSSIE in mie are aliases for the same bits in hie.",
    "norm:mtval2_sz_acc_op": "The mtval2 register is an MXLEN-bit read/write register formatted as shown in . When a trap is taken into M-mode, mtval2 is written with additional exception-specific information, alongside mtval, to assist software in handling the trap.",
    "norm:mtval2_trapval_param": "When a guest-page-fault trap is taken into M-mode, mtval2 is written with either zero or the guest physical address that faulted, shifted right by 2 bits. For other traps, mtval2 is set to zero, but a future standard or extension may redefine mtval2&#8217;s setting for other traps.",
    "norm:mtval2_trapval_vstrans": "If a guest-page fault is due to an implicit memory access during first-stage (VS-stage) address translation, a guest physical address written to mtval2 is that of the implicit memory access that faulted. Additional information is provided in CSR mtinst to disambiguate such situations.",
    "norm:mtval2_trapval_other": "Otherwise, for misaligned loads and stores that cause guest-page faults, a nonzero guest physical address in mtval2 corresponds to the faulting portion of the access as indicated by the virtual address in mtval. For instruction guest-page faults on systems with variable-length instructions, a nonzero mtval2 corresponds to the faulting portion of the instruction as indicated by the virtual address in mtval.",
    "norm:mtval2_val": "mtval2 is a WARL register that must be able to hold zero and may be capable of holding only an arbitrary subset of other 2-bit-shifted guest physical addresses, if any.",
    "norm:mtval2_Ssdbltrap": "The Ssdbltrap extension (See ) requires the implementation of the mtval2 CSR.",
    "norm:mtinst_sz_acc_op": "The mtinst register is an MXLEN-bit read/write register formatted as shown in . When a trap is taken into M-mode, mtinst is written with a value that, if nonzero, provides information about the instruction that trapped, to assist software in handling the trap. The values that may be written to mtinst on a trap are documented in .",
    "norm:mtinst_val": "mtinst is a WARL register that need only be able to hold the values that the implementation may automatically write to it on a trap.",
    "norm:H_vm_twostage": "Whenever the current virtualization mode V is 1, two-stage address translation and protection is in effect. For any virtual memory access, the original virtual address is converted in the first stage by VS-level address translation, as controlled by the vsatp register, into a guest physical address. The guest physical address is then converted in the second stage by guest physical address translation, as controlled by the hgatp register, into a supervisor physical address. The two stages are known also as VS-stage and G-stage translation. Although there is no option to disable two-stage address translation when V=1, either stage of translation can be effectively disabled by zeroing the corresponding vsatp or hgatp register.",
    "norm:vsstatus-mxr_vm": "The vsstatus field MXR, which makes execute-only pages readable by explicit loads, only\noverrides VS-stage page protection. Setting MXR at VS-level does not\noverride guest-physical page protections.",
    "norm:sstatus-mxr_vm": "Setting MXR at HS-level,\nhowever, overrides both VS-stage and G-stage execute-only permissions.",
    "norm:H_vm_gstagetrans": "When V=1, memory accesses that would normally bypass address translation are subject to G-stage address translation alone. This includes memory accesses made in support of VS-stage address translation, such as reads and writes of VS-level page tables.",
    "norm:H_pmp": "Machine-level physical memory protection applies to supervisor physical addresses and is in effect regardless of virtualization mode.",
    "norm:hgatp-mode_bare_trans": "When the address translation scheme selected by the MODE field of hgatp is Bare, guest physical addresses are equal to supervisor physical addresses without modification, and no memory protection applies in the trivial translation of guest physical addresses to supervisor physical addresses.",
    "norm:hgatp-mode_x4": "When hgatp.MODE specifies a translation scheme of Sv32x4, Sv39x4, Sv48x4, or Sv57x4, G-stage address translation is a variation on the usual page-based virtual address translation scheme of Sv32, Sv39, Sv48, or Sv57, respectively. In each case, the size of the incoming address is widened by 2 bits (to 34, 41, 50, or 59 bits). To accommodate the 2 extra bits, the root page table (only) is expanded by a factor of four to be 16 KiB instead of the usual 4 KiB. Matching its larger size, the root page table also must be aligned to a 16 KiB boundary instead of the usual 4 KiB page boundary. Except as noted, all other aspects of Sv32, Sv39, Sv48, or Sv57 are adopted unchanged for G-stage translation. Non-root page tables and all page table entries (PTEs) have the same formats as documented in , , , and .",
    "norm:hgatp-mode_sv32x4": "For Sv32x4, an incoming guest physical address is partitioned into a virtual page number (VPN) and page offset as shown in . This partitioning is identical to that for an Sv32 virtual address as depicted in , except with 2 more bits at the high end in VPN[1]. (Note that the fields of a partitioned guest physical address also correspond one-for-one with the structure that Sv32 assigns to a physical address, depicted in .)",
    "norm:hgatp-mode_sv39x4": "For Sv39x4, an incoming guest physical address is partitioned as shown in . This partitioning is identical to that for an Sv39 virtual address as depicted in , except with 2 more bits at the high end in VPN[2]. Address bits 63:41 must all be zeros, or else a guest-page-fault exception occurs.",
    "norm:hgatp-mode_sv48x4": "For Sv48x4, an incoming guest physical address is partitioned as shown in . This partitioning is identical to that for an Sv48 virtual address as depicted in , except with 2 more bits at the high end in VPN[3]. Address bits 63:50 must all be zeros, or else a guest-page-fault exception occurs.",
    "norm:hgatp-mode_sv57x4": "For Sv57x4, an incoming guest physical address is partitioned as shown in . This partitioning is identical to that for an Sv57 virtual address as depicted in , except with 2 more bits at the high end in VPN[4]. Address bits 63:59 must all be zeros, or else a guest-page-fault exception occurs.",
    "norm:H_vm_gpatrans": "The conversion of an Sv32x4, Sv39x4, Sv48x4, or Sv57x4 guest physical address is accomplished with the same algorithm used for Sv32, Sv39, Sv48, or Sv57, as presented in , except that:",
    "norm:H_vm_gpapriv": "For G-stage address translation, all memory accesses (including those made to access data structures for VS-stage address translation) are considered to be user-level accesses, as though executed in U-mode. Access type permissions—readable, writable, or executable—are checked during G-stage translation the same as for VS-stage translation. For a memory access made to support VS-stage address translation (such as to read/write a VS-level page table), permissions and the need to set A and/or D bits at the G-stage level are checked as though for an implicit load or store, not for the original access type. However, any exception is always reported for the original access type (instruction, load, or store/AMO).",
    "norm:H_vm_gpa_g": "The G bit in all G-stage PTEs is currently not used. Until its use is defined by a standard extension, it should be cleared by software for forward compatibility, and must be ignored by hardware.",
    "norm:H_guest_page_fault": "Guest-page-fault traps may be delegated from M-mode to HS-mode under the control of CSR medeleg, but cannot be delegated to other privilege modes. On a guest-page fault, CSR mtval or stval is written with the faulting guest virtual address as usual, and mtval2 or htval is written either with zero or with the faulting guest physical address, shifted right by 2 bits. CSR mtinst or htinst may also be written with information about the faulting instruction or other reason for the access, as explained in .",
    "norm:H_straddle": "When an instruction fetch or a misaligned memory access straddles a page boundary, two different address translations are involved. When a guest-page fault occurs in such a circumstance, the faulting virtual address written to mtval/stval is the same as would be required for a regular page fault. Thus, the faulting virtual address may be a page-boundary address that is higher than the instruction&#8217;s original virtual address, if the byte at that page boundary is among the accessed bytes.",
    "norm:mtval2_htval_virtaddr": "When a guest-page fault is not due to an implicit memory access for VS-stage address translation, a nonzero guest physical address written to mtval2/htval shall correspond to the exact virtual address written to mtval/stval.",
    "norm:sfence-vma_v0": "The behavior of the SFENCE.VMA instruction is affected by the current virtualization mode V. When V=0, the virtual-address argument is an HS-level virtual address, and the ASID argument is an HS-level ASID. The instruction orders stores only to HS-level address-translation structures with subsequent HS-level address translations.",
    "norm:sfence-vma_v1": "When V=1, the virtual-address argument to SFENCE.VMA is a guest virtual address within the current virtual machine, and the ASID argument is a VS-level ASID within the current virtual machine. The current virtual machine is identified by the VMID field of CSR hgatp, and the effective ASID can be considered to be the combination of this VMID with the VS-level ASID. The SFENCE.VMA instruction orders stores only to the VS-level address-translation structures with subsequent VS-stage address translations for the same virtual machine, i.e., only when hgatp.VMID is the same as when the SFENCE.VMA executed.",
    "norm:H_cause": "The hypervisor extension augments the trap cause encoding.  lists the possible M-mode and HS-mode trap cause codes when the hypervisor extension is implemented. Codes are added for VS-level interrupts (interrupts 2, 6, 10), for supervisor-level guest external interrupts (interrupt 12), for virtual-instruction exceptions (exception 22), and for guest-page faults (exceptions 20, 21, 23). Furthermore, environment calls from VS-mode are assigned cause 10, whereas those from HS-mode or S-mode use cause 9 as usual.",
    "norm:H_cause_ecall": "HS-mode and VS-mode ECALLs use different cause values so they can be delegated separately.",
    "norm:H_cause_virtual_instruction": "When V=1, a virtual-instruction exception (code 22) is normally raised instead of an illegal-instruction exception if the attempted instruction is HS-qualified but is prevented from executing when V=1 either due to insufficient privilege or because the instruction is expressly disabled by a supervisor or hypervisor CSR such as scounteren or hcounteren. An instruction is HS-qualified if it would be valid to execute in HS-mode (for some values of the instruction&#8217;s register operands), assuming fields TSR and TVM of CSR mstatus are both zero.",
    "norm:H_cause_virtual_instruction_high": "A special rule applies for CSR instructions that access 32-bit high-half CSRs such as cycleh and htimedeltah. When V=1 and XLEN=32, an invalid attempt to access a high-half CSR raises a virtual-instruction exception instead of an illegal-instruction exception if the same CSR instruction for the corresponding low-half CSR (e.g.cycle or htimedelta) is HS-qualified.",
    "norm:H_illegal_high_half": "When XLEN&gt;32, an attempt to access a high-half CSR always raises an illegal-instruction exception.",
    "norm:H_virtinst_vs_nonhighctr_h0_m1": "in VS-mode, attempts to access a non-high-half counter CSR when the\ncorresponding bit in hcounteren is 0 and the same bit in mcounteren\nis 1;",
    "norm:H_virtinst_vs32_highctr_h0_m1": "in VS-mode, if XLEN=32, attempts to access a high-half counter CSR\nwhen the corresponding bit in hcounteren is 0 and the same bit in\nmcounteren is 1;",
    "norm:H_virtinst_vu_nonhighctr_h0_s0_m1": "in VU-mode, attempts to access a non-high-half counter CSR when the\ncorresponding bit in either hcounteren or scounteren is 0 and the\nsame bit in mcounteren is 1;",
    "norm:H_virtinst_vu32_highctr_h0_s0_m1": "in VU-mode, if XLEN=32, attempts to access a high-half counter CSR\nwhen the corresponding bit in either hcounteren or scounteren is 0\nand the same bit in mcounteren is 1;",
    "norm:H_virtinst_vu_vs_hinst": "in VS-mode or VU-mode, attempts to execute a hypervisor instruction\n(HLV, HLVX, HSV, or HFENCE);",
    "norm:H_virtinst_vu_vs_nonhigh_allowedhs_tvm0": "in VS-mode or VU-mode, attempts to access an implemented non-high-half\nhypervisor CSR or VS CSR when the same access (read/write) would be\nallowed in HS-mode, assuming mstatus.TVM=0;",
    "norm:H_virtinst_vu_vs32_high_allowedhs_tvm0": "in VS-mode or VU-mode, if XLEN=32, attempts to access an implemented\nhigh-half hypervisor CSR or high-half VS CSR when the same access\n(read/write) to the CSR\"s low-half partner would be allowed in HS-mode,\nassuming mstatus.TVM=0;",
    "norm:H_virtinst_vu_wfi_tw0": "in VU-mode, attempts to execute WFI when mstatus.TW=0",
    "norm:H_virtinst_vu_sret_sfence": "or to execute\na supervisor instruction (SRET or SFENCE);",
    "norm:H_virtinst_vu_nonhigh_supervisor_allowedhs_tvm0": "in VU-mode, attempts to access an implemented non-high-half supervisor\nCSR when the same access (read/write) would be allowed in HS-mode,\nassuming mstatus.TVM=0;",
    "norm:H_virtinst_vu32_high_supervisor_allowedhs_tvm0": "in VU-mode, if XLEN=32, attempts to access an implemented high-half\nsupervisor CSR when the same access to the CSR's low-half partner would\nbe allowed in HS-mode, assuming mstatus.TVM=0;",
    "norm:H_virtinst_wfi_vtw1_tw0": "in VS-mode, attempts to execute WFI when hstatus.VTW=1 and\nmstatus.TW=0, unless the instruction completes within an\nimplementation-specific, bounded time;",
    "norm:H_virtinst_vs_sret_vtsr1": "in VS-mode, attempts to execute SRET when hstatus.VTSR=1",
    "norm:H_virtinst_vs_sfence_sinval_satp_vtvm1": "in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA\ninstruction or to access satp, when hstatus.VTVM=1.",
    "norm:H_virtinst_xtval": "On a virtual-instruction trap, mtval or stval is written the same as for an illegal-instruction trap.",
    "norm:H_illegalinst_xstatus_fs_vs": "Fields FS and VS in registers sstatus and vsstatus deviate from the usual HS-qualified rule. If an instruction is prevented from executing because FS or VS is zero in either sstatus or vsstatus, the exception raised is always an illegal-instruction exception, never a virtual-instruction exception.",
    "norm:H_exception_priority": "If an instruction may raise multiple synchronous exceptions, the decreasing priority order of  indicates which exception is taken and reported in mcause or scause.",
    "norm:H_trap_deleg": "When a trap occurs in HS-mode or U-mode, it goes to M-mode, unless delegated by medeleg or mideleg, in which case it goes to HS-mode. When a trap occurs in VS-mode or VU-mode, it goes to M-mode, unless delegated by medeleg or mideleg, in which case it goes to HS-mode, unless further delegated by hedeleg or hideleg, in which case it goes to VS-mode.",
    "norm:H_trap_m_csrwrites": "When a trap is taken into M-mode, virtualization mode V gets set to 0, and fields MPV and MPP in mstatus (or mstatush) are set according to . A trap into M-mode also writes fields GVA, MPIE, and MIE in mstatus/mstatush and writes CSRs mepc, mcause, mtval, mtval2, and mtinst.",
    "norm:H_trap_hs_csrwrites": "When a trap is taken into HS-mode, virtualization mode V is set to 0, and hstatus.SPV and sstatus.SPP are set according to . If V was 1 before the trap, field SPVP in hstatus is set the same as sstatus.SPP; otherwise, SPVP is left unchanged. A trap into HS-mode also writes field GVA in hstatus, fields SPIE and SIE in sstatus, and CSRs sepc, scause, stval, htval, and htinst.",
    "norm:H_trap_vs_csrwrites": "When a trap is taken into VS-mode, vsstatus.SPP is set according to . Register hstatus and the HS-level sstatus are not modified, and the virtualization mode V remains 1. A trap into VS-mode also writes fields SPIE and SIE in vsstatus and writes CSRs vsepc, vscause, and vstval.",
    "norm:H_trap_xtinst": "On any trap into M-mode or HS-mode, one of these values is written automatically into the appropriate trap instruction CSR, mtinst or htinst:",
    "norm:H_trap_xtinst_interrupt": "On an interrupt, the value written to the trap instruction register is\nalways zero.",
    "norm:H_trap_xtinst_exception_lead-in": "On a synchronous exception, if a nonzero value is written,\none of the following shall be true about the value:",
    "norm:H_trap_xtinst_exception_list": "Bit 0 is 1, and replacing bit 1 with 1 makes the value into a valid encoding of a standard instruction.\n\nIn this case, the instruction that trapped is the same kind as indicated by the register value, and the register value is the transformation of the trapping instruction, as defined later. For example, if bits 1:0 are binary 11 and the register value is the encoding of a standard LW (load word) instruction, then the trapping instruction is LW, and the register value is the transformation of the trapping LW instruction.\nBit 0 is 1, and replacing bit 1 with 1 makes the value into an instruction encoding that is explicitly designated for a custom instruction (not an unused reserved encoding).\n\nThis is a custom value. The instruction that trapped is a non-standard instruction. The interpretation of a custom value is not otherwise specified by this standard.\nThe value is one of the special pseudoinstructions defined later, all of which have bits 1:0 equal to 00.",
    "norm:H_trap_xtinst_val": "shows the values that may be automatically written to the trap instruction register for each standard exception cause. For exceptions that prevent the fetching of an instruction, only zero or a pseudoinstruction value may be written. A custom value may be automatically written only if the instruction that traps is non-standard. A future standard or extension may permit other values to be written, chosen from the set of allowed values established earlier.",
    "norm:H_trap_xtinst_guestpage": "For guest-page faults, the trap instruction register is written with a special pseudoinstruction value if: (a) the fault is caused by an implicit memory access for VS-stage address translation, and (b) a nonzero value (the faulting guest physical address) is written to mtval2 or htval. If both conditions are met, the value written to mtinst or htinst must be taken from ; zero is not allowed.",
    "norm:H_trap_xtinst_guestpage_rw": "A write pseudoinstruction (0x00002020 or 0x00003020) is used for the case that the machine is attempting automatically to update bits A and/or D in VS-level page tables. All other implicit memory accesses for VS-stage address translation will be reads. If a machine never automatically updates bits A or D in VS-level page tables (leaving this to software), the write case will never arise. The fact that such a page table update must actually be atomic, not just a simple write, is ignored for the pseudoinstruction.",
    "norm:mret_h": "The MRET instruction is used to return from a trap taken into M-mode. MRET first determines what the new privilege mode will be according to the values of MPP and MPV in mstatus or mstatush, as encoded in . MRET then in mstatus/mstatush sets MPV=0, MPP=0, MIE=MPIE, and MPIE=1. Lastly, MRET sets the privilege mode as previously determined, and sets pc=mepc.",
    "norm:sret_h": "The SRET instruction is used to return from a trap taken into HS-mode or VS-mode. Its behavior depends on the current virtualization mode.",
    "norm:mret_v0": "When executed in M-mode or HS-mode (i.e., V=0), SRET first determines what the new privilege mode will be according to the values in hstatus.SPV and sstatus.SPP, as encoded in . SRET then sets hstatus.SPV=0, and in sstatus sets SPP=0, SIE=SPIE, and SPIE=1. Lastly, SRET sets the privilege mode as previously determined, and sets pc=sepc.",
    "norm:mret_v1": "When executed in VS-mode (i.e., V=1), SRET sets the privilege mode according to , in vsstatus sets SPP=0, SIE=SPIE, and SPIE=1, and lastly sets pc=vsepc.",
    "norm:mret_dt": "If the Ssdbltrp extension is implemented, when SRET is executed in HS-mode, if the new privilege mode is VU, the SRET instruction sets vsstatus.SDT to 0. When executed in VS-mode, vsstatus.SDT is set to 0.",
    "norm:zicflip_forward_traps": "A trap may need to be delivered to the same or to a higher privilege mode upon\ncompletion of JALR/C.JALR/C.JR, but before the instruction at the target\nof indirect call/jump was decoded",
    "norm:zicflip_forward_trap_async_interrupt": "Asynchronous interrupts.",
    "norm:zicflip_forward_trap_async_exception": "Synchronous exceptions with priority higher than that of a software-check\nexception with xtval set to \"landing pad fault (code=2)\" (See\n&lt;&lt;norm:exc_priority&gt;&gt; of Privileged Specification).",
    "norm:zicflip_exception_priority": "The software-check exception caused by Zicfilp has higher priority than an illegal-instruction exception but lower priority than instruction access-fault.",
    "norm:lpad_sw_exception": "The software-check exception due to the instruction not being an LPAD instruction when ELP is LP_EXPECTED or a software-check exception caused by the LPAD instruction itself leads to a trap being delivered to the same or to a higher privilege mode.",
    "norm:mstatus-mpelp_op": "To store the previous ELP state on trap delivery to M-mode, an MPELP\nbit is provided in the mstatus CSR.",
    "norm:mstatus-spelp_op": "To store the previous ELP state on trap\ndelivery to S/HS-mode, an SPELP bit is provided in the mstatus CSR.",
    "norm:sstatus-spelp_op": "The\nSPELP bit in mstatus can be accessed through the sstatus CSR.",
    "norm:vsstatus-spelp_op2": "To store\nthe previous ELP state on traps to VS-mode, a SPELP bit is defined in the\nvsstatus (VS-modes version of sstatus).",
    "norm:dcsr-pelp_op": "To store the previous ELP state on\ntransition to Debug Mode, a pelp bit is defined in the dcsr register.",
    "norm:zicflip_pelp_trap": "When a trap is taken into privilege mode x, the xPELP is set to ELP and ELP is set to NO_LP_EXPECTED.",
    "norm:zicflip_pelp_trap_return": "An MRET or SRET instruction is used to return from a trap in M-mode or S-mode, respectively.  When executing an xRET instruction, if the new privilege mode is y, then ELP is set to the value of xPELP if yLPE (see ) is 1; otherwise, it is set to NO_LP_EXPECTED; xPELP is set to NO_LP_EXPECTED.",
    "norm:zicflip_pelp_debug_mode": "Upon entry into Debug Mode, the pelp bit in dcsr is updated with the ELP at the privilege level the hart was previously in, and the ELP is set to NO_LP_EXPECTED. When a hart resumes from Debug Mode, if the new privilege mode is y, then ELP is set to the value of pelp if yLPE (see ) is 1; otherwise, it is set to NO_LP_EXPECTED.",
    "norm:zicfiss_ssp_csr": "Attempts to access the ssp CSR may result in either an illegal-instruction exception or a virtual-instruction  exception, contingent upon the state of the x`envcfg.SSE` fields. The conditions are specified as follows:",
    "norm:zicfiss_m_menvcfg-sse": "If the privilege mode is less than M and menvcfg.SSE is 0, an\nillegal-instruction exception is raised.",
    "norm:zicfiss_u_senvcfg-sse": "Otherwise, if in U-mode and senvcfg.SSE is 0, an illegal-instruction\nexception is raised.",
    "norm:zicfiss_vs_henvcfg-sse": "Otherwise, if in VS-mode and henvcfg.SSE is 0, a virtual-instruction\nexception is raised.",
    "norm:zicfiss_vu_henvcfg_senvcfg-sse": "Otherwise, if in VU-mode and either henvcfg.SSE or senvcfg.SSE is 0,\na virtual-instruction  exception is raised.",
    "norm:zicfiss_sse_access": "Otherwise, the access is allowed.",
    "norm:zicfiss_smode-xsse": "When S-mode is not implemented, then xSSE is 0 at both M and U privilege modes.",
    "norm:ss_page_enc": "The\nencoding R=0, W=1, and X=0, is defined to represent an SS page.",
    "norm:ssmp_menvcfg-sse": "When\nmenvcfg.SSE=0, this encoding remains reserved.",
    "norm:ssmp_henvcfg-sse": "Similarly, when V=1 and\nhenvcfg.SSE=0, this encoding remains reserved at VS and VU levels.",
    "norm:satp-mode_bare": "If satp.MODE (or vsatp.MODE when V=1) is set to Bare and the effective\nprivilege mode is less than M, shadow stack instructions raise a store/AMO access-fault exception.",
    "norm:ssmp_ssamoswap": "When the effective privilege mode is M, memory access\nby an SSAMOSWAP.W/D instruction results in a store/AMO access-fault exception.",
    "norm:ssmp_ss_page_access_fault": "Memory mapped as an SS page cannot be written to by instructions other than\nSSAMOSWAP.W/D, SSPUSH, and C.SSPUSH. Attempts will raise a store/AMO\naccess-fault exception.",
    "norm:ssmp_ss_cache_block_access_fault": "Access to a SS page using cache-block operation\n(CBO.*) instructions is not permitted. Such accesses will raise a store/AMO\naccess-fault exception.",
    "norm:ssmp_ss_implicit_access_fault": "Implicit accesses, including instruction fetches to an\nSS page, are not permitted. Such accesses will raise an access-fault exception\nappropriate to the access type.",
    "norm:ssmp_ss_load": "However, the shadow stack is readable by all\ninstructions that only load from memory.",
    "norm:ss_fault_exception_code": "If a shadow stack (SS) instruction raises an access-fault, page-fault, or\nguest-page-fault exception that is supposed to indicate the original instruction\ntype (load or store/AMO), then the reported exception cause is respectively a\nstore/AMO access fault (code 7), a store/AMO page fault (code 15), or a\nstore/AMO guest-page fault (code 23).",
    "norm:ssmp_ss_page_illegeal_access": "Should a shadow stack instruction access a page that is\nnot designated as a shadow stack page and is not marked as read-only\n(pte.xwr=001), a store/AMO access-fault exception will be invoked.",
    "norm:ssmp_ss_read_only_page": "Conversely,\nif the page being accessed by a shadow stack instruction is a read-only page, a\nstore/AMO page-fault exception will be triggered.",
    "norm:ssp_xlen_aligned": "If the virtual address in ssp is not XLEN aligned, then the SSPUSH/ C.SSPUSH/SSPOPCHK/C.SSPOPCHK instructions cause a store/AMO access-fault exception.",
    "norm:ssmp_ss_idempotent_memory": "If the memory referenced by\nSSPUSH/C.SSPUSH/SSPOPCHK/C.SSPOPCHK/SSAMOSWAP.W/D instructions is not\nidempotent, then the instructions cause a store/AMO access-fault exception.",
    "norm:active_g_stage_pte": "When G-stage page tables are active, the shadow stack instructions that access memory\nrequire the G-stage page table to have read-write permission for the accessed\nmemory; else a store/AMO guest-page-fault exception is raised.",
    "norm:HS-mode_invoke_error": "It enables HS-mode to invoke a critical error\nhandler in a virtual machine on a double trap in VS-mode.",
    "norm:M-mode_invoke_error": "It also allows M-mode\nto invoke a critical error handler in the OS/Hypervisor on a double trap in\nS/HS-mode.",
    "norm:menvcfg_DTE": "The Ssdbltrp extension adds the menvcfg.DTE (See &lt;&lt;sec:menvcfg&gt;&gt;)",
    "norm:sstatus_SDT": "and the\nsstatus.SDT fields (See &lt;&lt;sstatus&gt;&gt;).",
    "norm:henvcfg_DTE": "If the hypervisor extension is\nadditionally implemented, then the extension adds the henvcfg.DTE (See\n&lt;&lt;sec:henvcfg&gt;&gt;)",
    "norm:vsstatus_SDT": "and the vsstatus.SDT fields (See &lt;&lt;vsstatus&gt;&gt;)."
  },
  "sections": {
    "title": "",
    "id": "",
    "children": [
      {
        "title": "Preface",
        "id": "_preface",
        "children": [],
        "tags": []
      },
      {
        "title": "Introduction",
        "id": "_introduction",
        "children": [
          {
            "title": "RISC-V Privileged Software Stack Terminology",
            "id": "_risc_v_privileged_software_stack_terminology",
            "children": [],
            "tags": []
          },
          {
            "title": "Privilege Levels",
            "id": "_privilege_levels",
            "children": [],
            "tags": [
              "norm:always-priv-level",
              "norm:priv-levels-txt",
              "norm:priv-levels-tbl",
              "norm:non-priv-exc",
              "norm:m-level-high-priv-only-mandatory",
              "norm:priv-combs-txt",
              "norm:priv-combs-tbl",
              "norm:m-mode-mandatory"
            ]
          },
          {
            "title": "Debug Mode",
            "id": "_debug_mode",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Control and Status Registers (CSRs)",
        "id": "priv-csrs",
        "children": [
          {
            "title": "CSR Address Mapping Conventions",
            "id": "_csr_address_mapping_conventions",
            "children": [],
            "tags": [
              "norm:Zicsr_rw",
              "norm:Zicsr_access",
              "norm:Zicsr_illegal_mode",
              "norm:Zicsr_illegal_acc",
              "norm:Zicwr_write_ro",
              "norm:Zicsr_debug-illegal"
            ]
          },
          {
            "title": "CSR Listing",
            "id": "_csr_listing",
            "children": [],
            "tags": []
          },
          {
            "title": "CSR Field Specifications",
            "id": "_csr_field_specifications",
            "children": [
              {
                "title": "Reserved Writes Preserve Values, Reads Ignore Values (WPRI)",
                "id": "_reserved_writes_preserve_values_reads_ignore_values_wpri",
                "children": [],
                "tags": [
                  "norm:Zicsr_wpri_roz"
                ]
              },
              {
                "title": "Write/Read Only Legal Values (WLRL)",
                "id": "_writeread_only_legal_values_wlrl",
                "children": [],
                "tags": [
                  "norm:Zicsr_wlrl",
                  "norm:Zicsr_wlrl_exception_param"
                ]
              },
              {
                "title": "Write Any Values, Reads Legal Values (WARL)",
                "id": "_write_any_values_reads_legal_values_warl",
                "children": [],
                "tags": [
                  "norm:Zicsr_warl"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "CSR Field Modulation",
            "id": "_csr_field_modulation",
            "children": [],
            "tags": []
          },
          {
            "title": "Implicit Reads of CSRs",
            "id": "_implicit_reads_of_csrs",
            "children": [],
            "tags": []
          },
          {
            "title": "CSR Width Modulation",
            "id": "csrwidthmodulation",
            "children": [],
            "tags": []
          },
          {
            "title": "Explicit Accesses to CSRs Wider than XLEN",
            "id": "_explicit_accesses_to_csrs_wider_than_xlen",
            "children": [],
            "tags": []
          }
        ],
        "tags": [
          "norm:Zicsr_higher_priv"
        ]
      },
      {
        "title": "Machine-Level ISA, Version 1.13",
        "id": "machine",
        "children": [
          {
            "title": "Machine-Level CSRs",
            "id": "_machine_level_csrs",
            "children": [
              {
                "title": "Machine ISA (misa) Register",
                "id": "misa",
                "children": [],
                "tags": [
                  "norm:misa_acc",
                  "norm:misa_always_rd",
                  "norm:misa_csr_implemented",
                  "norm:misa_enc_img",
                  "norm:misa_mxl_op_isa",
                  "norm:misa_mxl_acc",
                  "norm:misa_mxl_op_nz",
                  "norm:xlen_le_mxlen",
                  "norm:misa_mxl_enc",
                  "norm:misa_sz",
                  "norm:misa_extensions_enc_txt",
                  "norm:misa_i_op",
                  "norm:misa_e_op",
                  "norm:misa_extensions_warl_op",
                  "norm:misa_extensions_rst",
                  "norm:misa_extensions_disabling",
                  "norm:misa_extensions_impl_def",
                  "norm:misa_extensions_disabling_def",
                  "norm:misa_extensions_rsv_ret_0",
                  "norm:misa_extensions_enc_tbl",
                  "norm:misa_x_op",
                  "norm:misa_b_op",
                  "norm:misa_m_op",
                  "norm:Zmmul_misa_m",
                  "norm:misa_s_op",
                  "norm:misa_u_op",
                  "norm:misa_e_acc",
                  "norm:misa_e_not_i",
                  "norm:misa_extensions_dependencies",
                  "norm:misa_inc_ialign"
                ]
              },
              {
                "title": "Machine Vendor ID (mvendorid) Register",
                "id": "_machine_vendor_id_mvendorid_register",
                "children": [],
                "tags": [
                  "norm:mvendorid_sz_acc_op",
                  "norm:mvendorid_always_rd",
                  "norm:mvendorid_enc"
                ]
              },
              {
                "title": "Machine Architecture ID (marchid) Register",
                "id": "_machine_architecture_id_marchid_register",
                "children": [],
                "tags": [
                  "norm:marchid_sz_acc_op",
                  "norm:marchid_always_rd"
                ]
              },
              {
                "title": "Machine Implementation ID (mimpid) Register",
                "id": "_machine_implementation_id_mimpid_register",
                "children": [],
                "tags": [
                  "norm:mimpid_op",
                  "norm:mimpid_always_rd"
                ]
              },
              {
                "title": "Hart ID (mhartid) Register",
                "id": "_hart_id_mhartid_register",
                "children": [],
                "tags": [
                  "norm:mhartid_sz_acc_op",
                  "norm:mhartid_always_rd",
                  "norm:mhartid_one_is_zero",
                  "norm:mhartid_unique"
                ]
              },
              {
                "title": "Machine Status (mstatus and mstatush) Registers",
                "id": "_machine_status_mstatus_and_mstatush_registers",
                "children": [
                  {
                    "title": "Privilege and Global Interrupt-Enable Stack in mstatus register",
                    "id": "privstack",
                    "children": [],
                    "tags": [
                      "norm:mstatus_mie_sie_op1",
                      "norm:mstatus_mie_sie_op2",
                      "norm:mstatus_xie_intr_en_dis",
                      "norm:mstatus_sie_spie_rdonly0",
                      "norm:mstatus_xpie_xpp_op",
                      "norm:mstatus_xpp_enc",
                      "norm:mstatus_mpp_sz",
                      "norm:mstatus_spp_sz",
                      "norm:mstatus_xpie_xie_xpp_trap_op",
                      "norm:mstatus_xret_op",
                      "norm:mstatus_xpp_warl",
                      "norm:mstatus_xpp_rdonly0"
                    ]
                  },
                  {
                    "title": "Double Trap Control in mstatus Register",
                    "id": "machine-double-trap",
                    "children": [],
                    "tags": [
                      "norm:mstatus_mdt_sz_warl",
                      "norm:mstatus_mdt_rst",
                      "norm:mstatus_mie_clr_by_mdt",
                      "norm:mstatus_mie_clr_by_mdt_rv64",
                      "norm:mstatus_mie_set_mdt_0",
                      "norm:mstatus_mie_set_mdt_0_rv64",
                      "norm:trap_exp",
                      "norm:trap_unexp_mdt_1",
                      "norm:trap_unexp_rnmi",
                      "norm:mstatus_mdt_not_set_rnmi",
                      "norm:trap_unexp_mnstatus_nmie_0",
                      "norm:trap_unexp_hndl_lead-in",
                      "norm:trap_unexp_hndl_rnmi",
                      "norm:trap_unexp_hndl_no_rnmi",
                      "norm:critical-error",
                      "norm:mstatus_mdt_clr_mret_sret",
                      "norm:sstatus_sdt_clr_mret_sret",
                      "norm:vsstatus_sdt_clr_mret_sret",
                      "norm:mstatus_mdt_clr_mnret",
                      "norm:sstatus_sdt_clr_mnret",
                      "norm:vsstatus_sdt_clr_mnret"
                    ]
                  },
                  {
                    "title": "Base ISA Control in mstatus Register",
                    "id": "xlen-control",
                    "children": [],
                    "tags": [
                      "norm:mstatus_sxl_uxl_warl_op",
                      "norm:mstatus_sxl_uxl_enc",
                      "norm:sxlen_uxlen",
                      "norm:mstatus_sxl_uxl_sxlen_uxlen_mxlen32",
                      "norm:mstatus_sxl_acc_mxlen64",
                      "norm:mstatus_sxl_rdonly_mxlen64",
                      "norm:mstatus_uxl_acc_mxlen64",
                      "norm:mstatus_uxl_rdonly_mxlen64",
                      "norm:mstatus_uxl_legal_vals_smode",
                      "norm:xlen_reduction_op",
                      "norm:xlen_reduction_hint_op1",
                      "norm:xlen_reduction_hint_op2"
                    ]
                  },
                  {
                    "title": "Memory Privilege in mstatus Register",
                    "id": "_memory_privilege_in_mstatus_register",
                    "children": [],
                    "tags": [
                      "norm:mstatus_mprv_ldst_op",
                      "norm:mstatus_mprv_inst_xlat_op",
                      "norm:mstatus_mprv_rdonly0_no_umode",
                      "norm:mstatus_mprv_clr_mret_sret_less_priv",
                      "norm:mstatus_mxr_op",
                      "norm:mstatus_mxr_rdonly0_no_smode",
                      "norm:mstatus_sum_op",
                      "norm:mstatus_sum_op_no-vm",
                      "norm:mstatus_sum_op_mprv_mpp",
                      "norm:mstatus_sum_rdonly0",
                      "norm:mstatus_mxr_sum_op_acc_fault"
                    ]
                  },
                  {
                    "title": "Endianness Control in mstatus and mstatush Registers",
                    "id": "_endianness_control_in_mstatus_and_mstatush_registers",
                    "children": [],
                    "tags": [
                      "norm:mstatus_mstatush_xbe_warl",
                      "norm:endianness_inst_fetch_little",
                      "norm:mstatus_mbe_op",
                      "norm:mstatus_sbe_op",
                      "norm:mstatus_ube_op",
                      "norm:mstatus_sbe_implicit",
                      "norm:mstatus_sbe_change_fence",
                      "norm:mstatus_sbe_rocopy",
                      "norm:mstatus_ube_rocopy"
                    ]
                  },
                  {
                    "title": "Virtualization Support in mstatus Register",
                    "id": "virt-control",
                    "children": [],
                    "tags": [
                      "norm:mstatus_tvm_warl_op",
                      "norm:mstatus_tw_warl",
                      "norm:mstatus_tw_op",
                      "norm:mstatus_tw_always_illegal",
                      "norm:mstatus_tw_acc",
                      "norm:mstatus_tw_umode_op",
                      "norm:mstatus_tsr_warl",
                      "norm:mstatus_tsr_op",
                      "norm:mstatus_tsr_acc"
                    ]
                  },
                  {
                    "title": "Extension Context Status in mstatus Register",
                    "id": "_extension_context_status_in_mstatus_register",
                    "children": [],
                    "tags": [
                      "norm:mstatus_fs_vs_warl",
                      "norm:mstatus_fs_op",
                      "norm:mstatus_vs_op",
                      "norm:mstatus_xs_op1",
                      "norm:mstatus_fs_vs_xs_enc",
                      "norm:mstatus_fs_acc1",
                      "norm:mstatus_fs_acc2",
                      "norm:mstatus_fs_rdonly0_s-no-f",
                      "norm:mstatus_vs_acc1",
                      "norm:mstatus_vs_acc2",
                      "norm:mstatus_vs_rdonly0_s-no-v",
                      "norm:mstatus_xs_acc",
                      "norm:mstatus_xs_equiv",
                      "norm:mstatus_xs_op2",
                      "norm:mstatus_sd_acc",
                      "norm:mstatus_sd_op",
                      "norm:mstatus_sd_rdonly0",
                      "norm:mstatus_fs_vs_xs_off_op",
                      "norm:mstatus_fs_vs_xs_initial_op",
                      "norm:mstatus_fs_vs_xs_clean_op",
                      "norm:mstatus_fs_vs_xs_dirty_op",
                      "norm:mstatus_fs_vs_xs_update_indep_priv",
                      "norm:mstatus_fs_wr",
                      "norm:mstatus_vs_wr",
                      "norm:mstatus_fs_imprecise",
                      "norm:mstatus_fs_no_dirty_track",
                      "norm:mstatus_fs_no_change_dirty",
                      "norm:mstatus_vs_imprecise",
                      "norm:mstatus_vs_no_change_dirty"
                    ]
                  },
                  {
                    "title": "Previous Expected Landing Pad (ELP) State in mstatus Register",
                    "id": "_previous_expected_landing_pad_elp_state_in_mstatus_register",
                    "children": [],
                    "tags": [
                      "norm:mstatus_spelp_mpelp_op",
                      "norm:mstatus_spelp_mpelp_enc_lead-in",
                      "norm:mstatus_spelp_mpelp_enc_list"
                    ]
                  }
                ],
                "tags": [
                  "norm:mstatus_sz_acc",
                  "norm:mstatush_sz_acc",
                  "norm:mstatush_enc"
                ]
              },
              {
                "title": "Machine Trap-Vector Base-Address (mtvec) Register",
                "id": "_machine_trap_vector_base_address_mtvec_register",
                "children": [],
                "tags": [
                  "norm:mtvec_sz_warl_acc",
                  "norm:mtvec_enc",
                  "norm:mtvec_mandatory",
                  "norm:mtvec_rdonly",
                  "norm:mtvec_base_align_4B",
                  "norm:mtvec_base_align_func_mode",
                  "norm:mtvec_mode_enc",
                  "norm:mtvec_mode_direct_op",
                  "norm:mtvec_mode_vectored_op",
                  "norm:reset_nmi_addr"
                ]
              },
              {
                "title": "Machine Trap Delegation (medeleg and mideleg) Registers",
                "id": "_machine_trap_delegation_medeleg_and_mideleg_registers",
                "children": [],
                "tags": [
                  "norm:trap_def_M-mode",
                  "norm:medeleg_mideleg_op1",
                  "norm:medeleg_sz_acc",
                  "norm:mideleg_sz_acc",
                  "norm:medeleg_mideleg_mandatory_S-mode",
                  "norm:medeleg_mideleg_op2",
                  "norm:medeleg_mideleg_omit_wo_S-mode",
                  "norm:trap_del_S-mode",
                  "norm:trap_del_S-mode_op",
                  "norm:trap_del_S-mode_no_M-mode",
                  "norm:medeleg_mideleg_warl",
                  "norm:medeleg_no_rd1",
                  "norm:mideleg_no_rd1",
                  "norm:mideleg_rd1_lower_level",
                  "norm:trap_never_trans_lower",
                  "norm:trap_horiz",
                  "norm:trap_del_intr_priv_lvl",
                  "norm:medeleg_enc_img",
                  "norm:medeleg_enc_txt",
                  "norm:medelegh_sz_acc_enc_xlen32",
                  "norm:medelegh_omit_xlen64",
                  "norm:mideleg_enc_img",
                  "norm:mideleg_enc_txt",
                  "norm:medeleg_when_rd0",
                  "norm:medeleg_16_no_rd0"
                ]
              },
              {
                "title": "Machine Interrupt (mip and mie) Registers",
                "id": "_machine_interrupt_mip_and_mie_registers",
                "children": [],
                "tags": [
                  "norm:mip_sz_acc",
                  "norm:mie_sz_acc",
                  "norm:mip_mie_enc_txt",
                  "norm:mip_enc_img",
                  "norm:mie_enc_img",
                  "norm:intr_mip_mie_op",
                  "norm:intr_mip_mie_bounded_time",
                  "norm:intr_mip_mie_xret_csrwr",
                  "norm:intr_M-mode_highest_pri",
                  "norm:mip_bits_wr_or_rdonly",
                  "norm:mip_bits_wr_op",
                  "norm:mip_bits_rdonly_op",
                  "norm:mie_bits_wr",
                  "norm:mie_bits_rdonly0",
                  "norm:mip_mie_std_enc_txt",
                  "norm:mip_std_enc_img",
                  "norm:mie_std_enc_img",
                  "norm:mip_meip_mie_meie_op",
                  "norm:mip_meip_rdonly",
                  "norm:mip_mtip_mie_mtie_op",
                  "norm:mip_mtip_rdonly",
                  "norm:mip_msip_mie_msie_op",
                  "norm:mip_msip_rdonly",
                  "norm:msip_sz_acc",
                  "norm:msip_enc",
                  "norm:msip_update_max_time",
                  "norm:mip_msip_mie_msie_maybe_rdonly0",
                  "norm:mip_sxip_mie_sxie_rdonly0",
                  "norm:mip_seip_mie_seie_op",
                  "norm:mip_seip_acc",
                  "norm:intr_sei_op",
                  "norm:mip_seip_rdcsr",
                  "norm:mip_seip_wrcsr",
                  "norm:mip_stip_mie_stie_op",
                  "norm:mip_stip_no-stimecmp_acc",
                  "norm:mip_stip_no-stimecmp_op2",
                  "norm:mip_stip_stimecmp_acc",
                  "norm:mip_stip_stimecmp_op2",
                  "norm:mip_stip_stimecmp_clr",
                  "norm:mip_ssip_mie_ssie_op",
                  "norm:mip_ssip_acc",
                  "norm:mip_ssip_intr_ctrl",
                  "norm:mip_lcofip_mie_lcofie_op",
                  "norm:mip_lcofip_acc",
                  "norm:mip_lcofip_op2",
                  "norm:mip_lcofip_mie_lcofie_rdonly0",
                  "norm:intr_M-mode_pri"
                ]
              },
              {
                "title": "Hardware Performance Monitor",
                "id": "_hardware_performance_monitor",
                "children": [],
                "tags": [
                  "norm:mcycle_op",
                  "norm:minstret_op",
                  "norm:mcycle_minstret_sz",
                  "norm:mcycle_minstret_rst",
                  "norm:mcycle_minstret_wr",
                  "norm:mcycle_shared",
                  "norm:mhpmcounter_num",
                  "norm:mhpmevent_sz_warl_op",
                  "norm:mhpmevent_enc",
                  "norm:mhpmcounter_mandatory",
                  "norm:mhpmcounter_mhpmevent_rdonly0",
                  "norm:mhpmcounter_warl",
                  "norm:mhpmcounter_sz",
                  "norm:mcycleh_minstreth_mhpmh_op",
                  "norm:mhpmeventh_presence"
                ]
              },
              {
                "title": "Machine Counter-Enable (mcounteren) Register",
                "id": "mcounteren",
                "children": [],
                "tags": [
                  "norm:mcounteren_sz",
                  "norm:mcounteren_op",
                  "norm:mcounteren_enc_img",
                  "norm:mcounteren_inc_inaccessible",
                  "norm:mcounteren_clr_ill_inst_exc",
                  "norm:mcounteren_set_nxt_priv",
                  "norm:mcounteren_tm_clr",
                  "norm:mcounteren_tm_set",
                  "norm:cycle_instret_hpmcounter_op_rdonly",
                  "norm:time_op_rdonly",
                  "norm:cycleh_instreth_hpmcounternh_op_rdonly",
                  "norm:timeh_op_rdonly",
                  "norm:mcounteren_flds_mandatory_warl",
                  "norm:mcounteren_flds_rdonly0",
                  "norm:mcounteren_presence"
                ]
              },
              {
                "title": "Machine Counter-Inhibit (mcountinhibit) Register",
                "id": "_machine_counter_inhibit_mcountinhibit_register",
                "children": [],
                "tags": [
                  "norm:mcounterinhibit_enc_img",
                  "norm:mcounterinhibit_sz_warl_op1",
                  "norm:mcounterinhibit_only_inc",
                  "norm:mcounterinhibit_op2",
                  "norm:mcounterinhibit_cy_shared",
                  "norm:mcounterinhibit_not_impl"
                ]
              },
              {
                "title": "Machine Scratch (mscratch) Register",
                "id": "_machine_scratch_mscratch_register",
                "children": [],
                "tags": [
                  "norm:mscratch_sz_acc",
                  "norm:mscratch_enc_img"
                ]
              },
              {
                "title": "Machine Exception Program Counter (mepc) Register",
                "id": "_machine_exception_program_counter_mepc_register",
                "children": [],
                "tags": [
                  "norm:mepc_sz_acc",
                  "norm:mepc_align",
                  "norm:mepc_bit1_dyn_ialign_op",
                  "norm:mepc_warl",
                  "norm:mepc_inv_addr_conv",
                  "norm:mepc_op",
                  "norm:mepc_enc_img"
                ]
              },
              {
                "title": "Machine Cause (mcause) Register",
                "id": "mcause",
                "children": [],
                "tags": [
                  "norm:mcause_sz_acc",
                  "norm:mcause_op",
                  "norm:mcause_intr_op",
                  "norm:mcause_exccode_op",
                  "norm:mcause_exccode_wlrl",
                  "norm:mcause_enc_img",
                  "norm:mcause_exccode_ld_ldrsv",
                  "norm:mcause_exccode_st_sc_amo",
                  "norm:mcause_exccode_pri1",
                  "norm:mcause_exccode_enc_img",
                  "norm:exc_priority",
                  "norm:mcause_exccode_pri2"
                ]
              },
              {
                "title": "Machine Trap Value (mtval) Register",
                "id": "_machine_trap_value_mtval_register",
                "children": [],
                "tags": []
              },
              {
                "title": "Machine Configuration Pointer (mconfigptr) Register",
                "id": "_machine_configuration_pointer_mconfigptr_register",
                "children": [],
                "tags": []
              },
              {
                "title": "Machine Environment Configuration (menvcfg) Register",
                "id": "sec:menvcfg",
                "children": [],
                "tags": [
                  "norm:menvcfg-stce",
                  "norm:menvcfg-cbze",
                  "norm:menvcfg-cbcfe",
                  "norm:menvcfg-cbie",
                  "norm:cbo-inval_m-mode_op0",
                  "norm:cbo-inval_m-mode_op1",
                  "norm:cbo-inval_m-mode_op2"
                ]
              },
              {
                "title": "Machine Security Configuration (mseccfg) Register",
                "id": "sec:mseccfg",
                "children": [],
                "tags": []
              }
            ],
            "tags": [
              "norm:M_access_all_lower_priv_CSRs"
            ]
          },
          {
            "title": "Machine-Level Memory-Mapped Registers",
            "id": "_machine_level_memory_mapped_registers",
            "children": [
              {
                "title": "Machine Timer (mtime and mtimecmp) Registers",
                "id": "_machine_timer_mtime_and_mtimecmp_registers",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Machine-Mode Privileged Instructions",
            "id": "_machine_mode_privileged_instructions",
            "children": [
              {
                "title": "Environment Call and Breakpoint",
                "id": "_environment_call_and_breakpoint",
                "children": [],
                "tags": []
              },
              {
                "title": "Trap-Return Instructions",
                "id": "otherpriv",
                "children": [],
                "tags": []
              },
              {
                "title": "Wait for Interrupt",
                "id": "wfi",
                "children": [],
                "tags": []
              },
              {
                "title": "Custom SYSTEM Instructions",
                "id": "_custom_system_instructions",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Reset",
            "id": "reset",
            "children": [],
            "tags": []
          },
          {
            "title": "Non-Maskable Interrupts",
            "id": "nmi",
            "children": [],
            "tags": []
          },
          {
            "title": "Physical Memory Attributes",
            "id": "pma",
            "children": [
              {
                "title": "Main Memory versus I/O Regions",
                "id": "_main_memory_versus_io_regions",
                "children": [],
                "tags": []
              },
              {
                "title": "Supported Access Type PMAs",
                "id": "_supported_access_type_pmas",
                "children": [],
                "tags": []
              },
              {
                "title": "Atomicity PMAs",
                "id": "_atomicity_pmas",
                "children": [
                  {
                    "title": "AMO PMA",
                    "id": "_amo_pma",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Reservability PMA",
                    "id": "_reservability_pma",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              },
              {
                "title": "Misaligned Atomicity Granule PMA",
                "id": "_misaligned_atomicity_granule_pma",
                "children": [],
                "tags": []
              },
              {
                "title": "Memory-Ordering PMAs",
                "id": "_memory_ordering_pmas",
                "children": [],
                "tags": []
              },
              {
                "title": "Coherence and Cacheability PMAs",
                "id": "_coherence_and_cacheability_pmas",
                "children": [],
                "tags": []
              },
              {
                "title": "Idempotency PMAs",
                "id": "_idempotency_pmas",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Physical Memory Protection",
            "id": "pmp",
            "children": [
              {
                "title": "Physical Memory Protection CSRs",
                "id": "_physical_memory_protection_csrs",
                "children": [
                  {
                    "title": "Address Matching",
                    "id": "_address_matching",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Locking and Privilege Mode",
                    "id": "pmp-locking",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "Priority and Matching Logic",
                    "id": "_priority_and_matching_logic",
                    "children": [],
                    "tags": []
                  }
                ],
                "tags": []
              },
              {
                "title": "Physical Memory Protection and Paging",
                "id": "pmp-vmem",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          }
        ],
        "tags": [
          "norm:M_highest_priv_mode",
          "norm:M_mode_at_reset"
        ]
      },
      {
        "title": "\"Smstateen/Ssstateen\" Extensions, Version 1.0",
        "id": "smstateen",
        "children": [
          {
            "title": "State Enable Extensions",
            "id": "_state_enable_extensions",
            "children": [],
            "tags": []
          },
          {
            "title": "State Enable 0 Registers",
            "id": "_state_enable_0_registers",
            "children": [],
            "tags": []
          },
          {
            "title": "Usage",
            "id": "_usage",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smcsrind/Sscsrind\" Indirect CSR Access, Version 1.0",
        "id": "indirect-csr",
        "children": [
          {
            "title": "Introduction",
            "id": "_introduction_2",
            "children": [],
            "tags": []
          },
          {
            "title": "Machine-level CSRs",
            "id": "body",
            "children": [],
            "tags": []
          },
          {
            "title": "Supervisor-level CSRs",
            "id": "_supervisor_level_csrs",
            "children": [],
            "tags": []
          },
          {
            "title": "Virtual Supervisor-level CSRs",
            "id": "_virtual_supervisor_level_csrs",
            "children": [],
            "tags": []
          },
          {
            "title": "Access control by the state-enable CSRs",
            "id": "_access_control_by_the_state_enable_csrs",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smepmp\" Extension for PMP Enhancements for memory access and execution prevention in Machine mode, Version 1.0",
        "id": "smepmp",
        "children": [
          {
            "title": "Threat model",
            "id": "smepmp_threat",
            "children": [],
            "tags": []
          },
          {
            "title": "Smepmp Physical Memory Protection Rules",
            "id": "_smepmp_physical_memory_protection_rules",
            "children": [],
            "tags": []
          },
          {
            "title": "Smepmp software discovery",
            "id": "_smepmp_software_discovery",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smcntrpmf\" Cycle and Instret Privilege Mode Filtering, Version 1.0",
        "id": "smcntrpmf",
        "children": [
          {
            "title": "Introduction",
            "id": "_introduction_3",
            "children": [],
            "tags": []
          },
          {
            "title": "CSRs",
            "id": "_csrs",
            "children": [
              {
                "title": "Machine Counter Configuration (mcyclecfg, minstretcfg) Registers",
                "id": "_machine_counter_configuration_mcyclecfg_minstretcfg_registers",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Counter Behavior",
            "id": "_counter_behavior",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smrnmi\" Extension for Resumable Non-Maskable Interrupts, Version 1.0",
        "id": "rnmi",
        "children": [
          {
            "title": "RNMI Interrupt Signals",
            "id": "_rnmi_interrupt_signals",
            "children": [],
            "tags": []
          },
          {
            "title": "RNMI Handler Addresses",
            "id": "_rnmi_handler_addresses",
            "children": [],
            "tags": []
          },
          {
            "title": "RNMI CSRs",
            "id": "_rnmi_csrs",
            "children": [],
            "tags": []
          },
          {
            "title": "MNRET Instruction",
            "id": "_mnret_instruction",
            "children": [],
            "tags": []
          },
          {
            "title": "RNMI Operation",
            "id": "_rnmi_operation",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smcdeleg/Ssccfg\" Counter Delegation Extensions, Version 1.0",
        "id": "smcdeleg",
        "children": [
          {
            "title": "Counter Delegation",
            "id": "_counter_delegation",
            "children": [],
            "tags": []
          },
          {
            "title": "Supervisor Counter Inhibit (scountinhibit) Register",
            "id": "_supervisor_counter_inhibit_scountinhibit_register",
            "children": [],
            "tags": []
          },
          {
            "title": "Virtualizing scountovf",
            "id": "_virtualizing_scountovf",
            "children": [],
            "tags": []
          },
          {
            "title": "Virtualizing Local-Counter-Overflow Interrupts",
            "id": "_virtualizing_local_counter_overflow_interrupts",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smdbltrp\" Double Trap Extension, Version 1.0",
        "id": "smdbltrp",
        "children": [],
        "tags": [
          "norm:Smdbltrp_with_Smrnmi_op"
        ]
      },
      {
        "title": "\"Smctr\" Control Transfer Records Extension, Version 1.0",
        "id": "smctr",
        "children": [
          {
            "title": "CSRs",
            "id": "_csrs_2",
            "children": [
              {
                "title": "Machine Control Transfer Records Control Register (mctrctl)",
                "id": "_machine_control_transfer_records_control_register_mctrctl",
                "children": [],
                "tags": [
                  "norm:Ssctr_mctrctl-sz_acc_op",
                  "norm:mctrctl-mode_op",
                  "norm:mctrctl-rasemu_op",
                  "norm:mctrctl-mte_op",
                  "norm:mctrctl-ste_op",
                  "norm:mctrctl-bpfrz_op",
                  "norm:mctrctl-lcofifrz_op",
                  "norm:mctrctl-excinh_op",
                  "norm:mctrctl-intrinh_op",
                  "norm:mctrctl-tretinh_op",
                  "norm:mctrctl-ntbren_op",
                  "norm:mctrctl-tkbrinh_op",
                  "norm:mctrctl-indcallinh_op",
                  "norm:mctrctl-dircallinh_op",
                  "norm:mctrctl-indjmpinh_op",
                  "norm:mctrctl-dirjmpinh_op",
                  "norm:mctrctl-corswapinh_op",
                  "norm:mctrctl-retinh_op",
                  "norm:mctrctl-indljmpinh_op",
                  "norm:mctrctl-dirljmpinh_op",
                  "norm:mctrctl-custom_op",
                  "norm:mctrctl-impl"
                ]
              },
              {
                "title": "Supervisor Control Transfer Records Control Register (sctrctl)",
                "id": "_supervisor_control_transfer_records_control_register_sctrctl",
                "children": [],
                "tags": [
                  "norm:Ssctr_sctrctl_op",
                  "norm:Ssctr_sctrctl_acc"
                ]
              },
              {
                "title": "Virtual Supervisor Control Transfer Records Control Register (vsctrctl)",
                "id": "_virtual_supervisor_control_transfer_records_control_register_vsctrctl",
                "children": [],
                "tags": [
                  "norm:Ssctr_vsctrctl_sz_acc_op",
                  "norm:vsctr-s_op",
                  "norm:vsctrctl-u_op",
                  "norm:vsctrctl-ste_op",
                  "norm:vsctrctl-bpfrz_op",
                  "norm:vsctrctl-lcofifrz_op"
                ]
              },
              {
                "title": "Supervisor Control Transfer Records Depth Register (sctrdepth)",
                "id": "_supervisor_control_transfer_records_depth_register_sctrdepth",
                "children": [],
                "tags": [
                  "norm:sctrdepth",
                  "norm:sctrdepth-depth_op0",
                  "norm:sctrdepth-depth_op1",
                  "norm:sctrdepth-depth_param",
                  "norm:sctrdepth_mode"
                ]
              },
              {
                "title": "Supervisor Control Transfer Records Status Register (sctrstatus)",
                "id": "_supervisor_control_transfer_records_status_register_sctrstatus",
                "children": [],
                "tags": [
                  "norm:sctrstatus",
                  "norm:sctrstatus-wrptr",
                  "norm:sctrstatus-frozen_op",
                  "norm:Ssctr_sctrstatus_acc"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Entry Registers",
            "id": "_entry_registers",
            "children": [
              {
                "title": "Control Transfer Record Source Register (ctrsource)",
                "id": "_control_transfer_record_source_register_ctrsource",
                "children": [],
                "tags": [
                  "norm:ctrsource_op",
                  "norm:ctrsource_ctrtartget_ctrdata_Vbit",
                  "norm:Ssctr_ctrsource_sz_acc_op"
                ]
              },
              {
                "title": "Control Transfer Record Target Register (ctrtarget)",
                "id": "_control_transfer_record_target_register_ctrtarget",
                "children": [],
                "tags": [
                  "norm:ctrtarget_op",
                  "norm:ctrtarget_pc_next_br",
                  "norm:ctrtarget_misp",
                  "norm:ctrtarget_sz_acc"
                ]
              },
              {
                "title": "Control Transfer Record Metadata Register (ctrdata)",
                "id": "_control_transfer_record_metadata_register_ctrdata",
                "children": [],
                "tags": [
                  "norm:ctrdata_sz_acc",
                  "norm:ctrdata-type",
                  "norm:ctrdata-ccv",
                  "norm:ctrdata-cc",
                  "norm:ctrdata_undef"
                ]
              }
            ],
            "tags": [
              "norm:siselect_acc_op",
              "norm:vsiselect_op"
            ]
          },
          {
            "title": "Instructions",
            "id": "_instructions",
            "children": [
              {
                "title": "Supervisor CTR Clear Instruction",
                "id": "_supervisor_ctr_clear_instruction",
                "children": [],
                "tags": [
                  "norm:sctrclr_op1",
                  "norm:sctrclr_op2",
                  "norm:sctrclr_acc",
                  "norm:sctrclr_exceptions"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "State Enable Access Control",
            "id": "_state_enable_access_control",
            "children": [],
            "tags": [
              "norm:mstateen_ctr1",
              "norm:mstateen_ctr0",
              "norm:mstateen_ctr0_execpt1",
              "norm:mstateen_ctr0_execpt2",
              "norm:mstateen_ctr0_execpt3",
              "norm:mstateen_ctr0_qualified_transfer",
              "norm:hstateen_ctr",
              "norm:hstateen_vs",
              "norm:hstateen0_CTR0-V1_op"
            ]
          },
          {
            "title": "Behavior",
            "id": "_behavior",
            "children": [
              {
                "title": "Privilege Mode Transitions",
                "id": "_privilege_mode_transitions",
                "children": [
                  {
                    "title": "Virtualization Mode Transitions",
                    "id": "_virtualization_mode_transitions",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "External Traps",
                    "id": "_external_traps",
                    "children": [],
                    "tags": [
                      "norm:exttrap_def",
                      "norm:exttrap_requirements",
                      "norm:exttrap_us",
                      "norm:exttrap_um",
                      "norm:exttrap_sm",
                      "norm:exttrap_vuvs",
                      "norm:exttrap_vuhs",
                      "norm:exttrap_vum",
                      "norm:exttrap_vshs",
                      "norm:exttrap_vsm",
                      "norm:exttrap_ctrtarget0",
                      "norm:exttrap_implreq"
                    ]
                  }
                ],
                "tags": [
                  "norm:trap_enabled",
                  "norm:trap_disabled_src",
                  "norm:trap_disabled_tgt",
                  "norm:trapret_enabled",
                  "norm:trapret_to_disabled",
                  "norm:trapret_from_disabled",
                  "norm:debug_recording_inhibited",
                  "norm:trap_ee",
                  "norm:trap_ed",
                  "norm:trap_de",
                  "norm:trap_dd",
                  "norm:trapret_ee",
                  "norm:trapret_ed",
                  "norm:trapret_de",
                  "norm:trapret_dd"
                ]
              },
              {
                "title": "Transfer Type Filtering",
                "id": "_transfer_type_filtering",
                "children": [],
                "tags": [
                  "norm:ttf_default",
                  "norm:ttype0",
                  "norm:ttype1",
                  "norm:ttype2",
                  "norm:ttype3",
                  "norm:ttype4",
                  "norm:ttype5",
                  "norm:ttype8",
                  "norm:ttype9",
                  "norm:ttype10",
                  "norm:ttype11",
                  "norm:ttype12",
                  "norm:ttype13",
                  "norm:ttype14",
                  "norm:ttype15",
                  "norm:various_jump_enc"
                ]
              },
              {
                "title": "Cycle Counting",
                "id": "_cycle_counting",
                "children": [],
                "tags": [
                  "norm:ctrdata_cc_supported_param",
                  "norm:ccounter_inc",
                  "norm:ccounter_reset",
                  "norm:ccounter_impl",
                  "norm:ccsize0",
                  "norm:ccsize1",
                  "norm:ccsize2",
                  "norm:ccsize3",
                  "norm:ccsize4",
                  "norm:ccounter_sat",
                  "norm:ccounter_ccv"
                ]
              },
              {
                "title": "RAS (Return Address Stack) Emulation Mode",
                "id": "_ras_return_address_stack_emulation_mode",
                "children": [],
                "tags": [
                  "norm:ctrctl_rasemu_op"
                ]
              },
              {
                "title": "Freeze",
                "id": "_freeze",
                "children": [],
                "tags": [
                  "norm:sctrstatus-frozen_set",
                  "norm:freeze_bp",
                  "norm:freeze_vs"
                ]
              }
            ],
            "tags": [
              "norm:ctr_behavior",
              "norm:ctr_behavior_criteria0",
              "norm:ctr_behavior_criteri1",
              "norm:ctr_behavior_criteria2",
              "norm:ctr_behavior_criteria3",
              "norm:ctr_stack",
              "norm:ctr_validbit"
            ]
          },
          {
            "title": "Custom Extensions",
            "id": "_custom_extensions",
            "children": [],
            "tags": [
              "norm:custom_bits"
            ]
          }
        ],
        "tags": [
          "norm:CTR_DEPTH",
          "norm:Smctr_recording_criteria",
          "norm:Smctr_transfer_steps",
          "norm:Smctr_CTR_CSR_interface",
          "norm:Smctr_scope",
          "norm:Ssctr_transfer_steps",
          "norm:Smctr_Ssctr_depend"
        ]
      },
      {
        "title": "Supervisor-Level ISA, Version 1.13",
        "id": "supervisor",
        "children": [
          {
            "title": "Supervisor CSRs",
            "id": "_supervisor_csrs",
            "children": [
              {
                "title": "Supervisor Status (sstatus) Register",
                "id": "sstatus",
                "children": [
                  {
                    "title": "Base ISA Control in sstatus Register",
                    "id": "_base_isa_control_in_sstatus_register",
                    "children": [],
                    "tags": [
                      "norm:sstatus-uxl",
                      "norm:sstatus-uxl_sz",
                      "norm:sstatus-uxl_behavior",
                      "norm:hint_sxlen_param"
                    ]
                  },
                  {
                    "title": "Memory Privilege in sstatus Register",
                    "id": "sum",
                    "children": [],
                    "tags": [
                      "norm:sstatus-mxr",
                      "norm:sstatus-sum",
                      "norm:sstatus-sum_satp-mode"
                    ]
                  },
                  {
                    "title": "Endianness Control in sstatus Register",
                    "id": "_endianness_control_in_sstatus_register",
                    "children": [],
                    "tags": [
                      "norm:sstatus-ube",
                      "norm:sstatus-ube_implicit"
                    ]
                  },
                  {
                    "title": "Previous Expected Landing Pad (ELP) State in sstatus Register",
                    "id": "_previous_expected_landing_pad_elp_state_in_sstatus_register",
                    "children": [],
                    "tags": [
                      "norm:sstatus-spelp"
                    ]
                  },
                  {
                    "title": "Double Trap Control in sstatus Register",
                    "id": "supv-double-trap",
                    "children": [],
                    "tags": [
                      "norm:sstatus-sdt",
                      "norm:sstatus-sdt_sstatus-sie_overwrite",
                      "norm:sstatus-sdt_trap",
                      "norm:sstatus-sdt_sret"
                    ]
                  }
                ],
                "tags": [
                  "norm:sstatus",
                  "norm:sstatus-spp",
                  "norm:sstatus-sie",
                  "norm:sstatus-spie"
                ]
              },
              {
                "title": "Supervisor Trap Vector Base Address (stvec)  Register",
                "id": "_supervisor_trap_vector_base_address_stvec_register",
                "children": [],
                "tags": [
                  "norm:stvec",
                  "norm:stvec_op",
                  "norm:stvec_sz_base"
                ]
              },
              {
                "title": "Supervisor Interrupt (sip and sie) Registers",
                "id": "_supervisor_interrupt_sip_and_sie_registers",
                "children": [],
                "tags": [
                  "norm:sip_sie",
                  "norm:sie_sip_supervisor_strap",
                  "norm:sie_sip_strap_time_constraint",
                  "norm:s_interrupt_priority",
                  "norm:sip_acc",
                  "norm:sip_op",
                  "norm:sie_acc",
                  "norm:sip_sie_bits_sz",
                  "norm:sip-seip_sie-seie",
                  "norm:sip-stip_sie-stie",
                  "norm:sip-ssip_sie-ssie",
                  "norm:sip_sie_Sscofpmf",
                  "norm:sip_sie_unimpl",
                  "norm:sip_sie_priority_bit_order"
                ]
              },
              {
                "title": "Supervisor Timers and Performance Counters",
                "id": "_supervisor_timers_and_performance_counters",
                "children": [],
                "tags": [
                  "norm:supervisor_timer_scheduling"
                ]
              },
              {
                "title": "Counter-Enable (scounteren) Register",
                "id": "_counter_enable_scounteren_register",
                "children": [],
                "tags": [
                  "norm:scounteren",
                  "norm:scounteren_op",
                  "norm:scounteren_acc"
                ]
              },
              {
                "title": "Supervisor Scratch (sscratch) Register",
                "id": "_supervisor_scratch_sscratch_register",
                "children": [],
                "tags": [
                  "norm:sscratch"
                ]
              },
              {
                "title": "Supervisor Exception Program Counter (sepc) Register",
                "id": "_supervisor_exception_program_counter_sepc_register",
                "children": [],
                "tags": [
                  "norm:sepc",
                  "norm:sepc_op_mask_ialign32",
                  "norm:sepc_acc_invalid_addr",
                  "norm:sepc_op_trap_write"
                ]
              },
              {
                "title": "Supervisor Cause (scause) Register",
                "id": "scause",
                "children": [],
                "tags": [
                  "norm:scause",
                  "norm:scause-exception_code_acc",
                  "norm:scause-exception_code_sz",
                  "norm:scause-interrupt"
                ]
              },
              {
                "title": "Supervisor Trap Value (stval) Register",
                "id": "_supervisor_trap_value_stval_register",
                "children": [],
                "tags": [
                  "norm:stval",
                  "norm:stval_op_faulting_addr",
                  "norm:stval_op_breakpoint",
                  "norm:stval_op_load_store_fault",
                  "norm:stval_faulting_address_variable_instr",
                  "norm:stval_op_illegal_instr",
                  "norm:stval_op_illegal_instr_format",
                  "norm:stval_exception_info",
                  "norm:stval_op_other_traps",
                  "norm:stval_acc"
                ]
              },
              {
                "title": "Supervisor Environment Configuration (senvcfg) Register",
                "id": "sec:senvcfg",
                "children": [],
                "tags": [
                  "norm:senvcfg",
                  "norm:senvcfg-fiom",
                  "norm:senvcfg-fiom_op_atomic",
                  "norm:senvcfg-fiom_acc",
                  "norm:senvcfg-cbze",
                  "norm:senvcfg-cbcfe",
                  "norm:senvcfg-cbie",
                  "norm:cbo-inval_s-mode_op0",
                  "norm:cbo-inval_s-mode_op1",
                  "norm:cbo-inval_s-mode_op2",
                  "norm:senvcfg-pmm_Ssnpm",
                  "norm:senvcfg-lpe_Zicfilp",
                  "norm:senvcfg-sse_Zicfilp"
                ]
              },
              {
                "title": "Supervisor Address Translation and Protection (satp) Register",
                "id": "satp",
                "children": [],
                "tags": [
                  "norm:satp",
                  "norm:satp-mode",
                  "norm:satp-mode_sxlen32",
                  "norm:satp-mode_sxlen64",
                  "norm:satp-mode_op_unsupported",
                  "norm:satp-asidlen",
                  "norm:satp_op_active",
                  "norm:satp_op_sfence-vma"
                ]
              },
              {
                "title": "Supervisor Timer (stimecmp) Register",
                "id": "stimecmp",
                "children": [],
                "tags": [
                  "norm:stimecmp-stimecmph_sz_acc",
                  "norm:mip_sip-stip_op"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Supervisor Instructions",
            "id": "_supervisor_instructions",
            "children": [
              {
                "title": "Supervisor Memory-Management Fence Instruction",
                "id": "sfence.vma",
                "children": [],
                "tags": [
                  "norm:sfence-vma_ordering",
                  "norm:sfence-vma_invalidation",
                  "norm:sfence-vma_op",
                  "norm:sfence-vma_all_asid_va",
                  "norm:sfence-vma_asid_only",
                  "norm:sfence-vma_va_all_asid",
                  "norm:sfence-vma_va_asid",
                  "norm:sfence-vma_invalid_va",
                  "norm:sfence-vma_rs2_bits",
                  "norm:sfence-vma_ordering_semantics",
                  "norm:sfence-vma_implicit_access",
                  "norm:sfence-vma-sum-mxr_effect",
                  "norm:sfence-vma-mode_effect",
                  "norm:sfence-vma-asid_effect",
                  "norm:asid_hart_private",
                  "norm:satp-mode_roz_sfence_illegal_param"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Sv32: Page-Based 32-bit Virtual-Memory Systems",
            "id": "sv32",
            "children": [
              {
                "title": "Addressing and Memory Protection",
                "id": "translation",
                "children": [],
                "tags": [
                  "norm:satp-ppn_sv32_sz",
                  "norm:fetch_page_fault_no_x",
                  "norm:load_page_fault_no_r",
                  "norm:store_page_fault_no_w"
                ]
              },
              {
                "title": "Virtual Address Translation Process",
                "id": "sv32algorithm",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Sv39: Page-Based 39-bit Virtual-Memory System",
            "id": "sv39",
            "children": [
              {
                "title": "Addressing and Memory Protection",
                "id": "addressing-and-memory-protection",
                "children": [],
                "tags": [
                  "norm:satp-ppn_sv39_sv48_sv57_sz"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Sv48: Page-Based 48-bit Virtual-Memory System",
            "id": "sv48",
            "children": [
              {
                "title": "Addressing and Memory Protection",
                "id": "addressing-and-memory-protection-1",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Sv57: Page-Based 57-bit Virtual-Memory System",
            "id": "sv57",
            "children": [
              {
                "title": "Addressing and Memory Protection",
                "id": "addressing-and-memory-protection-2",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Svnapot\" Extension for NAPOT Translation Contiguity, Version 1.0",
        "id": "svnapot",
        "children": [],
        "tags": []
      },
      {
        "title": "\"Svpbmt\" Extension for Page-Based Memory Types, Version 1.0",
        "id": "svpbmt",
        "children": [],
        "tags": []
      },
      {
        "title": "\"Svinval\" Extension for Fine-Grained Address-Translation Cache Invalidation, Version 1.0",
        "id": "svinval",
        "children": [],
        "tags": []
      },
      {
        "title": "\"Svadu\" Extension for Hardware Updating of A/D Bits, Version 1.0",
        "id": "sec:svadu",
        "children": [],
        "tags": []
      },
      {
        "title": "\"Svvptc\" Extension for Obviating Memory-Management Instructions after Marking PTEs Valid, Version 1.0",
        "id": "sec:svvptc",
        "children": [],
        "tags": []
      },
      {
        "title": "\"Svrsw60t59b\" Extension for PTE Reserved-for-Software Bits 60-59, Version 1.0",
        "id": "sec:svrsw60t59b",
        "children": [],
        "tags": []
      },
      {
        "title": "\"Ssqosid\" Extension for Quality-of-Service (QoS) Identifiers, Version 1.0",
        "id": "ssqosid",
        "children": [
          {
            "title": "Supervisor Resource Management Configuration (srmcfg) register",
            "id": "_supervisor_resource_management_configuration_srmcfg_register",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Sstc\" Extension for Supervisor-mode Timer Interrupts, Version 1.0",
        "id": "Sstc",
        "children": [],
        "tags": []
      },
      {
        "title": "\"Sscofpmf\" Extension for Count Overflow and Mode-Based Filtering, Version 1.0",
        "id": "Sscofpmf",
        "children": [
          {
            "title": "Count Overflow Control",
            "id": "_count_overflow_control",
            "children": [],
            "tags": []
          },
          {
            "title": "Supervisor Count Overflow (scountovf) Register",
            "id": "_supervisor_count_overflow_scountovf_register",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"H\" Extension for Hypervisor Support, Version 1.0",
        "id": "hypervisor",
        "children": [
          {
            "title": "Privilege Modes",
            "id": "_privilege_modes",
            "children": [],
            "tags": []
          },
          {
            "title": "Hypervisor and Virtual Supervisor CSRs",
            "id": "_hypervisor_and_virtual_supervisor_csrs",
            "children": [
              {
                "title": "Hypervisor Status (hstatus) Register",
                "id": "sec:hstatus",
                "children": [],
                "tags": [
                  "norm:hstatus_sz_acc_op",
                  "norm:hstatus-vsxl_op",
                  "norm:hstatus-vsxl_32",
                  "norm:hstatus-vsxl_64",
                  "norm:vsxl_ro_param",
                  "norm:hstatus-vsxl_change",
                  "norm:hstatus-vtsr_op",
                  "norm:hstatus-vtw_op",
                  "norm:vtw_virtinstr_param",
                  "norm:hstatus-vtvm_op",
                  "norm:hstatus-vgein_op",
                  "norm:hstatus-hu_op",
                  "norm:hstatus-spv_op",
                  "norm:hstatus-spv_sret",
                  "norm:hstatus-spvp_op",
                  "norm:hstatus-gva_op",
                  "norm:hstatus-vsbe_op"
                ]
              },
              {
                "title": "Hypervisor Trap Delegation (hedeleg and hideleg) Registers",
                "id": "_hypervisor_trap_delegation_hedeleg_and_hideleg_registers",
                "children": [],
                "tags": [
                  "norm:hedeleg_sz_acc",
                  "norm:hideleg_sz_acc",
                  "norm:hedeleg_op",
                  "norm:hdeleg_acc",
                  "norm:hedelegh_sz_acc_op",
                  "norm:hideleg_op",
                  "norm:hideleg_acc",
                  "norm:hideleg_trans"
                ]
              },
              {
                "title": "Hypervisor Interrupt (hvip, hip, and hie) Registers",
                "id": "hinterruptregs",
                "children": [],
                "tags": [
                  "norm:hvip_sz_op",
                  "norm:hvip_acc",
                  "norm:hip_hie_sz_acc",
                  "norm:hip_op",
                  "norm:hie_op",
                  "norm:sie_hip_hie_mutex",
                  "norm:hideleg_hs",
                  "norm:hip_acc",
                  "norm:hie_acc",
                  "norm:hip_sgeip_sgeie_acc_op",
                  "norm:hip_vseip_vseie_op",
                  "norm:hip_vstip_vstie_acc_op",
                  "norm:hip_vssip_vssie_op",
                  "norm:hsint_priority"
                ]
              },
              {
                "title": "Hypervisor Guest External Interrupt Registers (hgeip and hgeie)",
                "id": "hgeinterruptregs",
                "children": [],
                "tags": [
                  "norm:hgeip_sz_acc_op",
                  "norm:hgeie_sz_acc_op",
                  "norm:hgeip_hgeie_fields",
                  "norm:geilen_param",
                  "norm:hgeie_op"
                ]
              },
              {
                "title": "Hypervisor Environment Configuration Register (henvcfg)",
                "id": "sec:henvcfg",
                "children": [],
                "tags": [
                  "norm:henvcfg_sz_acc_op",
                  "norm:henvcfg-fiom_op",
                  "norm:henvcfg-fiom_order",
                  "norm:henvcfg-pbmte_op",
                  "norm:henvcfg-adue_op",
                  "norm:henvcfg-stce",
                  "norm:henvcfg-cbze",
                  "norm:henvcfg-cbcfe",
                  "norm:henvcfg-cbie",
                  "norm:cbo-inval_h-mode_veq1_op",
                  "norm:cbo-inval_h-mode_op0",
                  "norm:cbo-inval_h-mode_op1",
                  "norm:cbo-inval_h-mode_op2",
                  "norm:henvcfg-pmm_op",
                  "norm:henvcfg-lpe_op",
                  "norm:henvcfg-sse_op",
                  "norm:henvcfg-dte_op",
                  "norm:henvcfgh_sz_acc_op"
                ]
              },
              {
                "title": "Hypervisor Counter-Enable (hcounteren) Register",
                "id": "_hypervisor_counter_enable_hcounteren_register",
                "children": [],
                "tags": [
                  "norm:hcounteren_sz",
                  "norm:hcounteren_op",
                  "norm:hcounteren_acc",
                  "norm:hcounteren_warl"
                ]
              },
              {
                "title": "Hypervisor Time Delta (htimedelta) Register",
                "id": "_hypervisor_time_delta_htimedelta_register",
                "children": [],
                "tags": [
                  "norm:htimedelta_sz_acc_op",
                  "norm:htimedeltah_sz_acc_op",
                  "norm:time_htimedelta_req"
                ]
              },
              {
                "title": "Hypervisor Trap Value (htval) Register",
                "id": "_hypervisor_trap_value_htval_register",
                "children": [],
                "tags": [
                  "norm:htval_sz_acc_op",
                  "norm:htval_trapval_param",
                  "norm:htval_val"
                ]
              },
              {
                "title": "Hypervisor Trap Instruction (htinst) Register",
                "id": "_hypervisor_trap_instruction_htinst_register",
                "children": [],
                "tags": [
                  "norm:htinst_sz_acc_op",
                  "norm:htinst_val"
                ]
              },
              {
                "title": "Hypervisor Guest Address Translation and Protection (hgatp) Register",
                "id": "hgatp",
                "children": [],
                "tags": [
                  "norm:hgatp_sz_acc_op",
                  "norm:hgatp_tvm_illegal",
                  "norm:hgatp-mode_bare",
                  "norm:hgatp-mode_sv",
                  "norm:hgatp-mode_warl",
                  "norm:hgatp-ppn_op",
                  "norm:hgatp-vmid_param",
                  "norm:hgatp-vmid_lsbs"
                ]
              },
              {
                "title": "Virtual Supervisor Status (vsstatus) Register",
                "id": "vsstatus",
                "children": [],
                "tags": [
                  "norm:vsstatus_sz_acc_op",
                  "norm:vsstatus-uxl_op",
                  "norm:vsstatus-uxl_change",
                  "norm:vsstatus-fs_op",
                  "norm:vsstatus-vs_op",
                  "norm:vsstatus-sd_xs_op",
                  "norm:vsstatus-ube_param",
                  "norm:vsstatus_v0",
                  "norm:vsstatus-spelp_op",
                  "norm:vsstatus-sdt_op"
                ]
              },
              {
                "title": "Virtual Supervisor Interrupt (vsip and vsie) Registers",
                "id": "_virtual_supervisor_interrupt_vsip_and_vsie_registers",
                "children": [],
                "tags": [
                  "norm:vsip_vsie_sz_acc_op",
                  "norm:vsip_vsie-lcofi",
                  "norm:vsip_vsie-sei",
                  "norm:vsip_vsie-sti",
                  "norm:vsip_vsie-ssi"
                ]
              },
              {
                "title": "Virtual Supervisor Trap Vector Base Address (vstvec) Register",
                "id": "_virtual_supervisor_trap_vector_base_address_vstvec_register",
                "children": [],
                "tags": [
                  "norm:vstvec_sz_acc_op"
                ]
              },
              {
                "title": "Virtual Supervisor Scratch (vsscratch) Register",
                "id": "_virtual_supervisor_scratch_vsscratch_register",
                "children": [],
                "tags": [
                  "norm:vsscratch_sz_acc_op"
                ]
              },
              {
                "title": "Virtual Supervisor Exception Program Counter (vsepc) Register",
                "id": "_virtual_supervisor_exception_program_counter_vsepc_register",
                "children": [],
                "tags": [
                  "norm:vspec_sz_acc_op",
                  "norm:vsepc_warl"
                ]
              },
              {
                "title": "Virtual Supervisor Cause (vscause) Register",
                "id": "_virtual_supervisor_cause_vscause_register",
                "children": [],
                "tags": [
                  "norm:vscause_sz_acc_op",
                  "norm:vscause_warl"
                ]
              },
              {
                "title": "Virtual Supervisor Trap Value (vstval) Register",
                "id": "_virtual_supervisor_trap_value_vstval_register",
                "children": [],
                "tags": [
                  "norm:vstval_sz_acc_op",
                  "norm:vstval_warl"
                ]
              },
              {
                "title": "Virtual Supervisor Address Translation and Protection (vsatp) Register",
                "id": "_virtual_supervisor_address_translation_and_protection_vsatp_register",
                "children": [],
                "tags": [
                  "norm:vsatp_sz_acc_op",
                  "norm:vsatp_mode_unsupported_v0",
                  "norm:vsatp_mode_unsupported_v1",
                  "norm:vsatp_v0"
                ]
              },
              {
                "title": "Virtual Supervisor Timer (vstimecmp) Register",
                "id": "vstimecmp",
                "children": [],
                "tags": [
                  "norm:vstimecmp_sz",
                  "norm:vstimecmp_acc",
                  "norm:hip-vstip_op",
                  "norm:hip-vstip_clear",
                  "norm:hip-vstip_enable"
                ]
              }
            ],
            "tags": [
              "norm:H_csrs_hs_not_vs",
              "norm:H_vscsrs_sub",
              "norm:H_vscsrs_acc_vs",
              "norm:H_vscsrs_acc_u",
              "norm:H_vscsrs_acc_m_hs",
              "norm:H_vscsrs_v1",
              "norm:H_vscsrs_v0",
              "norm:H_scsrs_nomatch",
              "norm:hsxlen_param",
              "norm:vsxlen_param"
            ]
          },
          {
            "title": "Hypervisor Instructions",
            "id": "_hypervisor_instructions",
            "children": [
              {
                "title": "Hypervisor Virtual-Machine Load and Store Instructions",
                "id": "_hypervisor_virtual_machine_load_and_store_instructions",
                "children": [],
                "tags": [
                  "norm:hlsv_mode",
                  "norm:hlsv_priv",
                  "norm:hlsv_trans",
                  "norm:hlsv_sstatus-mxr",
                  "norm:hlsv_vsstatus-mxr",
                  "norm:hlsv_op",
                  "norm:hlsv_u_op",
                  "norm:hlvx-wu_valid32",
                  "norm:hlsv_virtinst",
                  "norm:hlsv_illegalinst"
                ]
              },
              {
                "title": "Hypervisor Memory-Management Fence Instructions",
                "id": "hfence.vma",
                "children": [],
                "tags": [
                  "norm:hfence-vvma_hfence-gvma_op",
                  "norm:hfence-vvma_mode",
                  "norm:hfence-vvma_limits",
                  "norm:hfence-vvma_asid",
                  "norm:hfence-vvma_tvm",
                  "norm:hfence-gvma_op",
                  "norm:hfence-gvma_vmid",
                  "norm:hfence-gvma_mode",
                  "norm:hfence-vvma_hfence-gvma_exceptions"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Machine-Level CSRs",
            "id": "_machine_level_csrs_2",
            "children": [
              {
                "title": "Machine Status (mstatus and mstatush) Registers",
                "id": "_machine_status_mstatus_and_mstatush_registers_2",
                "children": [],
                "tags": [
                  "norm:mstatus_mpv_op",
                  "norm:mstatus_gva_op",
                  "norm:mstatus_modes",
                  "norm:mstatus_tvm_hs",
                  "norm:mstatus_mprv_hypervisor",
                  "norm:mstatus_mprv_hlsv"
                ]
              },
              {
                "title": "Machine Interrupt Delegation (mideleg) Register",
                "id": "_machine_interrupt_delegation_mideleg_register",
                "children": [],
                "tags": [
                  "norm:mideleg_acc_h",
                  "norm:mideleg_hroz"
                ]
              },
              {
                "title": "Machine Interrupt (mip and mie) Registers",
                "id": "_machine_interrupt_mip_and_mie_registers_2",
                "children": [],
                "tags": [
                  "norm:mip_mie_vs",
                  "norm:mip_mie_alias"
                ]
              },
              {
                "title": "Machine Second Trap Value (mtval2) Register",
                "id": "_machine_second_trap_value_mtval2_register",
                "children": [],
                "tags": [
                  "norm:mtval2_sz_acc_op",
                  "norm:mtval2_trapval_param",
                  "norm:mtval2_trapval_vstrans",
                  "norm:mtval2_trapval_other",
                  "norm:mtval2_val",
                  "norm:mtval2_Ssdbltrap"
                ]
              },
              {
                "title": "Machine Trap Instruction (mtinst) Register",
                "id": "_machine_trap_instruction_mtinst_register",
                "children": [],
                "tags": [
                  "norm:mtinst_sz_acc_op",
                  "norm:mtinst_val"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Two-Stage Address Translation",
            "id": "two-stage-translation",
            "children": [
              {
                "title": "Guest Physical Address Translation",
                "id": "guest-addr-translation",
                "children": [],
                "tags": [
                  "norm:hgatp-mode_bare_trans",
                  "norm:hgatp-mode_x4",
                  "norm:hgatp-mode_sv32x4",
                  "norm:hgatp-mode_sv39x4",
                  "norm:hgatp-mode_sv48x4",
                  "norm:hgatp-mode_sv57x4",
                  "norm:H_vm_gpatrans",
                  "norm:H_vm_gpapriv",
                  "norm:H_vm_gpa_g"
                ]
              },
              {
                "title": "Guest-Page Faults",
                "id": "_guest_page_faults",
                "children": [],
                "tags": [
                  "norm:H_guest_page_fault",
                  "norm:H_straddle",
                  "norm:mtval2_htval_virtaddr"
                ]
              },
              {
                "title": "Memory-Management Fences",
                "id": "hyp-mm-fences",
                "children": [],
                "tags": [
                  "norm:sfence-vma_v0",
                  "norm:sfence-vma_v1"
                ]
              },
              {
                "title": "Interaction with Pointer Masking",
                "id": "pm-two-stage",
                "children": [],
                "tags": []
              }
            ],
            "tags": [
              "norm:H_vm_twostage",
              "norm:vsstatus-mxr_vm",
              "norm:sstatus-mxr_vm",
              "norm:H_vm_gstagetrans",
              "norm:H_pmp"
            ]
          },
          {
            "title": "Traps",
            "id": "_traps",
            "children": [
              {
                "title": "Trap Cause Codes",
                "id": "sec:hcauses",
                "children": [],
                "tags": [
                  "norm:H_cause",
                  "norm:H_cause_ecall",
                  "norm:H_cause_virtual_instruction",
                  "norm:H_cause_virtual_instruction_high",
                  "norm:H_illegal_high_half",
                  "norm:H_virtinst_vs_nonhighctr_h0_m1",
                  "norm:H_virtinst_vs32_highctr_h0_m1",
                  "norm:H_virtinst_vu_nonhighctr_h0_s0_m1",
                  "norm:H_virtinst_vu32_highctr_h0_s0_m1",
                  "norm:H_virtinst_vu_vs_hinst",
                  "norm:H_virtinst_vu_vs_nonhigh_allowedhs_tvm0",
                  "norm:H_virtinst_vu_vs32_high_allowedhs_tvm0",
                  "norm:H_virtinst_vu_wfi_tw0",
                  "norm:H_virtinst_vu_sret_sfence",
                  "norm:H_virtinst_vu_nonhigh_supervisor_allowedhs_tvm0",
                  "norm:H_virtinst_vu32_high_supervisor_allowedhs_tvm0",
                  "norm:H_virtinst_wfi_vtw1_tw0",
                  "norm:H_virtinst_vs_sret_vtsr1",
                  "norm:H_virtinst_vs_sfence_sinval_satp_vtvm1",
                  "norm:H_virtinst_xtval",
                  "norm:H_illegalinst_xstatus_fs_vs",
                  "norm:H_exception_priority"
                ]
              },
              {
                "title": "Trap Entry",
                "id": "_trap_entry",
                "children": [],
                "tags": [
                  "norm:H_trap_deleg",
                  "norm:H_trap_m_csrwrites",
                  "norm:H_trap_hs_csrwrites",
                  "norm:H_trap_vs_csrwrites"
                ]
              },
              {
                "title": "Transformed Instruction or Pseudoinstruction for mtinst or htinst",
                "id": "tinst-vals",
                "children": [],
                "tags": [
                  "norm:H_trap_xtinst",
                  "norm:H_trap_xtinst_interrupt",
                  "norm:H_trap_xtinst_exception_lead-in",
                  "norm:H_trap_xtinst_exception_list",
                  "norm:H_trap_xtinst_val",
                  "norm:H_trap_xtinst_guestpage",
                  "norm:H_trap_xtinst_guestpage_rw"
                ]
              },
              {
                "title": "Trap Return",
                "id": "_trap_return",
                "children": [],
                "tags": [
                  "norm:mret_h",
                  "norm:sret_h",
                  "norm:mret_v0",
                  "norm:mret_v1",
                  "norm:mret_dt"
                ]
              }
            ],
            "tags": []
          }
        ],
        "tags": [
          "norm:H_mtval_nrz",
          "norm:H_vm_supported",
          "norm:misa-h_op"
        ]
      },
      {
        "title": "Control-flow Integrity (CFI)",
        "id": "priv-cfi",
        "children": [
          {
            "title": "Landing Pad (Zicfilp)",
            "id": "priv-forward",
            "children": [
              {
                "title": "Landing-Pad-Enabled (LPE) State",
                "id": "FCFIACT",
                "children": [],
                "tags": []
              },
              {
                "title": "Preserving Expected Landing Pad State on Traps",
                "id": "ZICFILP_FORWARD_TRAPS",
                "children": [],
                "tags": [
                  "norm:zicflip_forward_traps",
                  "norm:zicflip_forward_trap_async_interrupt",
                  "norm:zicflip_forward_trap_async_exception",
                  "norm:zicflip_exception_priority",
                  "norm:lpad_sw_exception",
                  "norm:mstatus-mpelp_op",
                  "norm:mstatus-spelp_op",
                  "norm:sstatus-spelp_op",
                  "norm:vsstatus-spelp_op2",
                  "norm:dcsr-pelp_op",
                  "norm:zicflip_pelp_trap",
                  "norm:zicflip_pelp_trap_return",
                  "norm:zicflip_pelp_debug_mode"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Shadow Stack (Zicfiss)",
            "id": "priv-backward",
            "children": [
              {
                "title": "Shadow Stack Pointer (ssp) CSR access control",
                "id": "_shadow_stack_pointer_ssp_csr_access_control",
                "children": [],
                "tags": [
                  "norm:zicfiss_ssp_csr",
                  "norm:zicfiss_m_menvcfg-sse",
                  "norm:zicfiss_u_senvcfg-sse",
                  "norm:zicfiss_vs_henvcfg-sse",
                  "norm:zicfiss_vu_henvcfg_senvcfg-sse",
                  "norm:zicfiss_sse_access"
                ]
              },
              {
                "title": "Shadow-Stack-Enabled (SSE) State",
                "id": "_shadow_stack_enabled_sse_state",
                "children": [],
                "tags": [
                  "norm:zicfiss_smode-xsse"
                ]
              },
              {
                "title": "Shadow Stack Memory Protection",
                "id": "SSMP",
                "children": [],
                "tags": [
                  "norm:ss_page_enc",
                  "norm:ssmp_menvcfg-sse",
                  "norm:ssmp_henvcfg-sse",
                  "norm:satp-mode_bare",
                  "norm:ssmp_ssamoswap",
                  "norm:ssmp_ss_page_access_fault",
                  "norm:ssmp_ss_cache_block_access_fault",
                  "norm:ssmp_ss_implicit_access_fault",
                  "norm:ssmp_ss_load",
                  "norm:ss_fault_exception_code",
                  "norm:ssmp_ss_page_illegeal_access",
                  "norm:ssmp_ss_read_only_page",
                  "norm:ssp_xlen_aligned",
                  "norm:ssmp_ss_idempotent_memory",
                  "norm:active_g_stage_pte"
                ]
              }
            ],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Ssdbltrp\" Double Trap Extension, Version 1.0",
        "id": "ssdbltrp",
        "children": [],
        "tags": [
          "norm:HS-mode_invoke_error",
          "norm:M-mode_invoke_error",
          "norm:menvcfg_DTE",
          "norm:sstatus_SDT",
          "norm:henvcfg_DTE",
          "norm:vsstatus_SDT"
        ]
      },
      {
        "title": "Pointer Masking Extensions, Version 1.0.0",
        "id": "Zpm",
        "children": [
          {
            "title": "Introduction",
            "id": "_introduction_4",
            "children": [],
            "tags": []
          },
          {
            "title": "Background",
            "id": "_background",
            "children": [
              {
                "title": "Definitions",
                "id": "_definitions",
                "children": [],
                "tags": []
              },
              {
                "title": "The “Ignore” Transformation",
                "id": "sec-ignore-transform",
                "children": [],
                "tags": []
              },
              {
                "title": "Example",
                "id": "_example",
                "children": [],
                "tags": []
              },
              {
                "title": "Determining the Value of PMLEN",
                "id": "_determining_the_value_of_pmlen",
                "children": [],
                "tags": []
              },
              {
                "title": "Pointer Masking and Privilege Modes",
                "id": "_pointer_masking_and_privilege_modes",
                "children": [],
                "tags": []
              },
              {
                "title": "Memory Accesses Subject to Pointer Masking",
                "id": "_memory_accesses_subject_to_pointer_masking",
                "children": [],
                "tags": []
              },
              {
                "title": "Pointer Masking Extensions",
                "id": "_pointer_masking_extensions",
                "children": [],
                "tags": []
              },
              {
                "title": "Number of Masked Bits",
                "id": "_number_of_masked_bits",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "RISC-V Privileged Instruction Set Listings",
        "id": "_risc_v_privileged_instruction_set_listings",
        "children": [],
        "tags": []
      },
      {
        "title": "History",
        "id": "_history",
        "children": [
          {
            "title": "Research Funding at UC Berkeley",
            "id": "_research_funding_at_uc_berkeley",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Historical Rationale for Extensions",
        "id": "_historical_rationale_for_extensions",
        "children": [
          {
            "title": "\"Smepmp\" Extension for PMP Enhancements for memory access and execution prevention in Machine mode",
            "id": "smepmp_rationale",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      }
    ],
    "tags": []
  }
}
