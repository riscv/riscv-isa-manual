{
  "tags": {
    "norm:always-priv-level": "At any time, a RISC-V hardware thread (hart) is running at some\nprivilege level encoded as a mode in one or more CSRs (control and\nstatus registers).",
    "norm:priv-levels-txt": "Three RISC-V privilege levels are currently defined",
    "norm:priv-levels-tbl": "Level|Encoding|Name|Abbreviation\n===\n0\n1\n2\n3|00\n01\n10\n11|User/Application\nSupervisor\nReserved\nMachine|U\nS\n&#160;\nM\n===",
    "norm:non-priv-exc": "attempts to perform operations not\npermitted by the current privilege mode will cause an exception to be\nraised.",
    "norm:m-level-high-priv-only-mandatory": "The machine level has the highest privileges and\nis the only mandatory privilege level for a RISC-V hardware platform.",
    "norm:priv-combs-txt": "Implementations might provide anywhere from 1 to 3 privilege modes",
    "norm:priv-combs-tbl": "Number of levels|Supported Modes|Intended Usage\n===\n1\n2\n3|M\nM, U\nM, S, U|Simple embedded systems\nSecure embedded systems\nSystems running Unix-like operating systems\n===",
    "norm:m-mode-mandatory": "All hardware implementations must provide M-mode",
    "norm:Zicsr_higher_priv": "although CSRs and instructions are associated with one privilege\nlevel, they are also accessible at all higher privilege levels.",
    "norm:Zicsr_rw": "The top two bits (csr[11:10]) indicate whether the register is read/write (00,01, or 10) or read-only (11).",
    "norm:Zicsr_access": "The next two bits (csr[9:8]) encode the lowest privilege level that can access the CSR, with the pattern 10 representing hypervisor CSRs.",
    "norm:Zicsr_illegal_mode": "Attempts to access a CSR without appropriate privilege level\nraise illegal-instruction exceptions or, as described in\n&lt;&lt;sec:hcauses&gt;&gt;, virtual-instruction exceptions.",
    "norm:Zicsr_illegal_acc": "Attempts to write a read-only register raise illegal-instruction exceptions.",
    "norm:Zicwr_write_ro": "A read/write register might also contain some bits that are\nread-only, in which case writes to the read-only bits are ignored.",
    "norm:Zicsr_debug-illegal": "0x7B0-0x7BF are only visible to debug mode.\nImplementations should raise illegal-instruction exceptions on\nmachine-mode access to the latter set of registers.",
    "norm:Zicsr_wpri_roz": "For forward compatibility, implementations that do not\nfurnish these fields must make them read-only zero. These fields are\nlabeled WPRI in the register descriptions.",
    "norm:Zicsr_wlrl": "Software\nshould not write anything other than legal values to such a field, and\nshould not assume a read will return a legal value unless the last write\nwas of a legal value, or the register has not been written since another\noperation (e.g., reset) set the register to a legal value. These fields\nare labeled WLRL in the register descriptions.",
    "norm:Zicsr_wlrl_exception": "Implementations are permitted but not required to raise an\nillegal-instruction exception if an instruction attempts to write a\nnon-supported value to a WLRL field.",
    "norm:Zicsr_warl": "Implementations will not raise an exception on writes of unsupported\nvalues to a WARL field.",
    "norm:M_highest_priv_mode": "machine-mode (M-mode), which is the highest privilege mode in a RISC-V\nhart.",
    "norm:M-mode_at_rst1": "M-mode is used for low-level access to a hardware platform and\nis the first mode entered at reset.",
    "norm:M_access_all_lower_priv_CSRs": "M-mode code can access all CSRs at lower privilege levels.",
    "norm:misa_acc": "The misa CSR is a WARL read-write register",
    "norm:misa_always_rd": "This register must be readable in any implementation",
    "norm:misa_csr_implemented": "a value of zero can be returned to indicate the misa register has not been implemented",
    "norm:misa_enc_img": "",
    "norm:misa_mxl_op_isa": "The MXL (Machine XLEN) field encodes the native base integer ISA width as\nshown in &lt;&lt;norm:misa_mxl_enc&gt;&gt;.",
    "norm:misa_mxl_acc": "The MXL field is read-only.",
    "norm:misa_mxl_op_nz": "If misa is nonzero, the\nMXL field indicates the effective XLEN in M-mode, a constant termed MXLEN.",
    "norm:xlen_le_mxlen": "XLEN is never greater than MXLEN, but XLEN might be smaller than MXLEN in\nless-privileged modes.",
    "norm:misa_mxl_enc": "MXL|XLEN\n===\n1\n2\n3|32\n64\nReserved\n===",
    "norm:misa_sz": "The misa CSR is MXLEN bits wide.",
    "norm:misa_extensions_enc_txt": "The Extensions field encodes the presence of the standard extensions,\nwith a single bit per letter of the alphabet (bit 0 encodes presence of\nextension \"A\" , bit 1 encodes presence of extension \"B\", through to\nbit 25 which encodes \"Z\").",
    "norm:misa_i_op": "The \"I\" bit will be set for the RV32I and RV64I base ISAs",
    "norm:misa_e_op": "the \"E\" bit will be set for RV32E and RV64E.",
    "norm:misa_extensions_warl_op": "The Extensions field is a WARL field that can contain writable bits where the\nimplementation allows the supported ISA to be modified.",
    "norm:misa_extensions_rst1": "At reset, the Extensions field shall contain the maximal set of supported extensions,\nand \"I\" shall be selected over \"E\" if both are available.",
    "norm:misa_extensions_disabling": "When a standard extension is disabled by clearing its bit in misa, the instructions and CSRs defined or modified by the extension revert to their defined or reserved behaviors as if the extension is not implemented.",
    "norm:misa_extensions_impl_def": "For a given RISC-V execution environment, an instruction, extension, or other feature of the RISC-V ISA is ordinarily judged to be implemented or not by the observable execution behavior in that environment. For example, the F extension is said to be implemented for an execution environment if and only if the instructions that the RISC-V Unprivileged ISA defines for F execute as specified.",
    "norm:misa_extensions_disabling_def": "With this definition of implemented, disabling an extension by clearing its bit in misa results in the extension being considered not implemented in M-mode. For example, setting misa.F=0 results in the F extension being not implemented for M-mode, because the F extension&#8217;s instructions will not act as the Unprivileged ISA requires but may instead raise an illegal-instruction exception.",
    "norm:misa_extensions_rsv_ret_0": "All bits that are reserved for future use must return zero when read.",
    "norm:misa_extensions_enc_tbl": "Bit|Character|Description\n===\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25|A\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\nQ\nR\nS\nT\nU\nV\nW\nX\nY\nZ|Atomic extension\nB extension\nCompressed extension\nDouble-precision floating-point extension\nRV32E/64E base ISA\nSingle-precision floating-point extension\nReserved\nHypervisor extension\nRV32I/64I base ISA\nReserved\nReserved\nReserved\nInteger Multiply/Divide extension\nTentatively reserved for User-Level Interrupts extension\nReserved\nTentatively reserved for Packed-SIMD extension\nQuad-precision floating-point extension\nReserved\nSupervisor mode implemented\nReserved\nUser mode implemented\nVector extension\nReserved\nNon-standard extensions implemented\nReserved\nReserved\n===",
    "norm:misa_x_op": "The \"X\" bit will be set if there are any non-standard extensions.",
    "norm:misa_b_op": "When the \"B\" bit is 1, the implementation supports the instructions provided by the\nZba, Zbb, and Zbs extensions.",
    "norm:misa_m_op": "When the \"M\" bit is 1, the implementation supports all multiply and\ndivision instructions defined by the M extension.",
    "norm:Zmmul_misa_m": "if the Zmmul extension is supported then\nthe multiply instructions it specifies are supported irrespective\nof the value of the \"M\" bit.",
    "norm:misa_s_op": "When the \"S\" bit is 1, the implementation supports supervisor mode.",
    "norm:misa_u_op": "When the \"U\" bit is 1, the implementation supports user mode.",
    "norm:misa_e_acc": "The \"E\" bit is read-only.",
    "norm:misa_e_not_i": "Unless misa is all read-only zero, the\n\"E\" bit always reads as the complement of the \"I\" bit.",
    "norm:misa_extensions_dependencies": "If an ISA feature x depends on an ISA feature y, then attempting to\nenable feature x but disable feature y results in both features\nbeing disabled.",
    "norm:misa_inc_ialign": "Writing misa may increase IALIGN, e.g., by disabling the \"C\"\nextension. If an instruction that would write misa increases IALIGN,\nand the subsequent instruction's address is not IALIGN-bit aligned, the\nwrite to misa is suppressed, leaving misa unchanged.",
    "norm:mvendorid_sz_acc_op": "The mvendorid CSR is a 32-bit read-only register providing the JEDEC\nmanufacturer ID of the provider of the core.",
    "norm:mvendorid_always_rd": "This register must be readable in any implementation, but a value of 0 can be returned to\nindicate the field is not implemented or that this is a non-commercial implementation.",
    "norm:mvendorid_enc": "JEDEC manufacturer IDs are ordinarily encoded as a sequence of one-byte\ncontinuation codes 0x7f, terminated by a one-byte ID not equal to\n0x7f, with an odd parity bit in the most-significant bit of each byte.\nmvendorid encodes the number of one-byte continuation codes in the\nBank field, and encodes the final byte in the Offset field, discarding\nthe parity bit.",
    "norm:marchid_sz_acc_op": "The marchid CSR is an MXLEN-bit read-only register encoding the base\nmicroarchitecture of the hart.",
    "norm:marchid_always_rd": "This register must be readable in any\nimplementation, but a value of 0 can be returned to indicate the field is not implemented.",
    "norm:mimpid_op": "The mimpid CSR provides a unique encoding of the version of the\nprocessor implementation.",
    "norm:mimpid_always_rd": "This register must be readable in any\nimplementation, but a value of 0 can be returned to indicate that the field is not implemented.",
    "norm:mhartid_sz_acc_op": "The mhartid CSR is an MXLEN-bit read-only register containing the\ninteger ID of the hardware thread running the code.",
    "norm:mhartid_always_rd": "This register must be readable in any implementation.",
    "norm:mhartid_one_is_zero": "one hart must have a hart ID of zero.",
    "norm:mhartid_unique": "Hart IDs must be unique within the execution environment.",
    "norm:mstatus_sz_acc": "The mstatus register is an MXLEN-bit read/write register formatted as\nshown in &lt;&lt;mstatusreg-rv32&gt;&gt; for RV32 and &lt;&lt;mstatusreg&gt;&gt; for RV64.",
    "norm:mstatush_sz_acc": "For RV32 only, mstatush is a 32-bit read/write register formatted as shown in &lt;&lt;mstatushreg&gt;&gt;.",
    "norm:mstatush_enc": "Bits 30:4 of mstatush generally contain the same fields found in bits 62:36 of mstatus for RV64. Fields SD, SXL, and UXL do not exist in mstatush.",
    "norm:mstatus_mie_sie_op1": "Global interrupt-enable bits, MIE and SIE, are provided for M-mode and\nS-mode respectively.",
    "norm:mstatus_mie_sie_op2": "When a hart is executing in privilege mode x, interrupts are globally\nenabled when xIE=1 and globally disabled when xIE=0.",
    "norm:mstatus_xie_intr_en_dis": "Interrupts for lower-privilege modes, w&lt;x,\nare always globally disabled regardless of the setting of any global wIE bit for the\nlower-privilege mode.  Interrupts for higher-privilege modes, y&gt;x,\nare always globally enabled regardless of the\nsetting of the global yIE bit for the higher-privilege mode.",
    "norm:mstatus_sie_spie_rdonly0": "If supervisor mode is not implemented, then SIE and SPIE are read-only 0.",
    "norm:mstatus_xpie_xpp_op": "each privilege mode x that can respond to\ninterrupts has a two-level stack of interrupt-enable bits and privilege modes.\nxPIE holds the value of the interrupt-enable bit active prior\nto the trap, and xPP holds the previous privilege mode.",
    "norm:mstatus_xpp_enc": "The xPP fields can only hold privilege modes up to x",
    "norm:mstatus_mpp_sz": "MPP is two bits wide",
    "norm:mstatus_spp_sz": "SPP is one bit wide.",
    "norm:mstatus_xpie_xie_xpp_trap_op": "When a trap is taken from privilege mode y\ninto privilege mode x, xPIE is set to the value of xIE; xIE is\nset to 0; and xPP is set to y.",
    "norm:mstatus_xret_op": "When executing an xRET instruction, supposing\nxPP holds the value y, xIE is set to xPIE; the privilege mode is\nchanged to y; xPIE is set to 1; and xPP is set to the\nleast-privileged supported mode (U if U-mode is implemented, else M). If\ny{ne}M, xRET also sets MPRV=0.",
    "norm:mstatus_xpp_warl": "xPP fields are WARL fields that can hold only privilege mode x and any implemented privilege mode lower than x.",
    "norm:mstatus_xpp_rdonly0": "If privilege mode x is not implemented, then xPP must be read-only 0.",
    "norm:mstatus_mdt_sz_warl": "The M-mode-disable-trap (MDT) bit is a WARL field introduced by the Smdbltrp extension.",
    "norm:mstatus_mdt_rst": "Upon reset, the MDT field is set to 1.",
    "norm:mstatus_mie_clr_by_mdt": "When the MDT bit is set to 1 by an explicit CSR write,\nthe MIE (Machine Interrupt Enable) bit is cleared to 0.",
    "norm:mstatus_mie_clr_by_mdt_rv64": "For RV64, this clearing occurs regardless of the value written, if any, to the MIE bit by the same write.",
    "norm:mstatus_mie_set_mdt_0": "The MIE bit can only be set to 1 by an\nexplicit CSR write if the MDT bit is already 0",
    "norm:mstatus_mie_set_mdt_0_rv64": "or, for RV64, is being set to 0 by the same write",
    "norm:trap_exp": "When a trap is to be taken into M-mode, if the MDT bit is currently 0, it is then set to 1, and the trap is delivered as expected.",
    "norm:trap_unexp_mdt_1": "However, if MDT is already set to 1, then this is an unexpected trap.",
    "norm:trap_unexp_rnmi": "When the Smrnmi extension\nis implemented, a trap caused by an RNMI is not considered an unexpected trap\nirrespective of the state of the MDT bit.",
    "norm:mstatus_mdt_not_set_rnmi": "A trap caused by an RNMI does not set the MDT bit.",
    "norm:trap_unexp_mnstatus_nmie_0": "a trap that occurs when executing in M-mode with\nmnstatus.NMIE set to 0 is an unexpected trap.",
    "norm:trap_unexp_hndl_lead-in": "In the event of a unexpected trap, the handling is as follows:",
    "norm:trap_unexp_hndl_rnmi": "When the Smrnmi extension is implemented and mnstatus.NMIE is 1, the hart\ntraps to the RNMI handler. To deliver this trap, the mnepc and mncause\nregisters are written with the values that the unexpected trap would have\nwritten to the mepc and mcause registers respectively. The privilege\nmode information fields in the mnstatus register are written to indicate\nM-mode and its NMIE field is set to 0.",
    "norm:trap_unexp_hndl_no_rnmi": "When the Smrnmi extension is not implemented, or if the Smrnmi extension is\nimplemented and mnstatus.NMIE is 0, the hart enters a critical-error state\nwithout updating any architectural state, including the pc. This state\ninvolves ceasing execution, disabling all interrupts (including NMIs), and\nasserting a critical-error signal to the platform.",
    "norm:critical_error": "The actions performed by the platform when a hart asserts a critical-error signal\nare platform-specific. The range of possible actions include restarting\nthe affected hart or restarting the entire platform, among others.",
    "norm:mstatus_mdt_clr_mret_sret": "The MRET and SRET instructions, when executed in M-mode, set the MDT bit to 0.",
    "norm:sstatus_sdt_clr_mret_sret": "If the new privilege mode is U, VS, or VU, then sstatus.SDT is also set to 0.",
    "norm:vsstatus_sdt_clr_mret_sret": "Additionally, if it is VU, then vsstatus.SDT is also set to 0.",
    "norm:mstatus_mdt_clr_mnret": "The MNRET instruction, provided by the Smrnmi extension, sets the MDT bit to 0 if the new privilege mode is not M.",
    "norm:sstatus_sdt_clr_mnret": "If it is U, VS, or VU, then sstatus.SDT is also set to 0.",
    "norm:vsstatus_sdt_clr_mnret": "Additionally, if it is VU, then vsstatus.SDT is also set to 0.",
    "norm:mstatus_sxl_uxl_warl_op": "For RV64 harts, the SXL and UXL fields are WARL fields that control the\nvalue of XLEN for S-mode and U-mode, respectively.",
    "norm:mstatus_sxl_uxl_enc": "The encoding of these fields is the same as the MXL field of misa, shown in &lt;&lt;norm:misa_mxl_enc&gt;&gt;.",
    "norm:sxlen_uxlen": "The effective XLEN in S-mode and U-mode are termed SXLEN and UXLEN, respectively.",
    "norm:mstatus_sxl_uxl_sxlen_uxlen_mxlen32": "When MXLEN=32, the SXL and UXL fields do not exist, and SXLEN=32 and UXLEN=32.",
    "norm:mstatus_sxl_acc_mxlen64": "When MXLEN=64, if S-mode is not supported, then SXL is read-only zero.\nOtherwise, it is a WARL field that encodes the current value of SXLEN.",
    "norm:mstatus_sxl_rdonly_mxlen64": "an implementation may make SXL be a read-only field whose\nvalue always ensures that SXLEN=MXLEN.",
    "norm:mstatus_uxl_acc_mxlen64": "When MXLEN=64, if U-mode is not supported, then UXL is read-only zero.\nOtherwise, it is a WARL field that encodes the current value of UXLEN.",
    "norm:mstatus_uxl_rdonly_mxlen64": "an implementation may make UXL be a read-only field whose\nvalue always ensures that UXLEN=MXLEN or UXLEN=SXLEN.",
    "norm:mstatus_uxl_legal_vals_smode": "If S-mode is implemented, the set of legal values that the UXL field may assume excludes those that would cause UXLEN to be greater than SXLEN.",
    "norm:xlen_reduction_op": "Whenever XLEN in any mode is set to a value less than the widest supported XLEN, all operations must ignore source operand register bits above the configured XLEN, and must sign-extend results to fill the entire widest supported XLEN in the destination register. Similarly, pc bits above XLEN are ignored, and when the pc is written, it is sign-extended to fill the widest supported XLEN.",
    "norm:xlen_reduction_hint_op1": "Some HINT instructions are encoded as integer computational instructions that overwrite their destination register with its current value, e.g., c.addi x8, 0. When such a HINT is executed with XLEN &lt; MXLEN and bits MXLEN..XLEN of the destination register not all equal to bit XLEN-1, it is implementation-defined whether bits MXLEN..XLEN of the destination register are unchanged or are overwritten with copies of bit XLEN-1.",
    "norm:xlen_reduction_hint_op2": "This definition allows implementations to elide register write-back for\nsome HINTs, while allowing them to execute other HINTs in the same manner as\nother integer computational instructions.\nThe implementation choice is observable only by privilege modes with an XLEN\nsetting greater than the current XLEN; it is invisible to the current\nprivilege mode.",
    "norm:mstatus_mprv_ldst_op": "When MPRV=0, explicit memory accesses\nbehave as normal, using the translation and\nprotection mechanisms of the current privilege mode. When MPRV=1, load\nand store memory addresses are translated and protected, and endianness\nis applied, as though the current privilege mode were set to MPP.",
    "norm:mstatus_mprv_inst_xlat_op": "Instruction address-translation and protection are unaffected by the\nsetting of MPRV.",
    "norm:mstatus_mprv_rdonly0_no_umode": "MPRV is read-only 0 if U-mode is not supported.",
    "norm:mstatus_mprv_clr_mret_sret_less_priv": "An MRET or SRET instruction that changes the privilege mode to a mode\nless privileged than M also sets MPRV=0.",
    "norm:mstatus_mxr_op": "When MXR=0, only loads from pages marked readable (R=1 in &lt;&lt;sv32pte&gt;&gt;) will succeed.\nWhen MXR=1, loads from pages marked either readable or executable (R=1 or\nX=1) will succeed.  MXR has no effect when page-based virtual memory is not in effect.",
    "norm:mstatus_mxr_rdonly0_no_smode": "MXR is read-only 0 if S-mode is not supported.",
    "norm:mstatus_sum_op": "When SUM=0, S-mode memory accesses to pages that are accessible by U-mode\n(U=1 in &lt;&lt;sv32pte&gt;&gt;) will fault. When SUM=1, these accesses are permitted.",
    "norm:mstatus_sum_op_no-vm": "SUM has no effect when page-based virtual memory is not in effect.",
    "norm:mstatus_sum_op_mprv_mpp": "while SUM is ordinarily ignored when not\nexecuting in S-mode, it is in effect when MPRV=1 and MPP=S.",
    "norm:mstatus_sum_rdonly0": "SUM is read-only 0 if S-mode is not supported or if satp.MODE is read-only 0.",
    "norm:mstatus_mxr_sum_op_acc_fault": "The MXR and SUM mechanisms only affect the interpretation of permissions encoded in page-table entries. In particular, they have no impact on whether access-fault exceptions are raised due to PMAs or PMP.",
    "norm:mstatus_mstatush_xbe_warl": "The MBE, SBE, and UBE bits in mstatus and mstatush are WARL fields",
    "norm:endianness_inst_fetch_little": "Instruction fetches are always little-endian.",
    "norm:mstatus_mbe_op": "MBE controls whether non-instruction-fetch memory accesses made from M-mode (assuming mstatus.MPRV=0) are little-endian (MBE=0) or big-endian (MBE=1).",
    "norm:mstatus_sbe_op": "If S-mode is not supported, SBE is read-only 0. Otherwise, SBE controls whether explicit load and store memory accesses made from S-mode are little-endian (SBE=0) or big-endian (SBE=1).",
    "norm:mstatus_ube_op": "If U-mode is not supported, UBE is read-only 0. Otherwise, UBE controls whether explicit load and store memory accesses made from U-mode are little-endian (UBE=0) or big-endian (UBE=1).",
    "norm:mstatus_sbe_implicit": "For implicit accesses to supervisor-level memory management data\nstructures, such as page tables, endianness is always controlled by SBE.",
    "norm:mstatus_sbe_change_fence": "Since changing SBE alters the implementation’s interpretation of these\ndata structures, if any such data structures remain in use across a\nchange to SBE, M-mode software must follow such a change to SBE by\nexecuting an SFENCE.VMA instruction with rs1=x0 and rs2=x0.",
    "norm:mstatus_sbe_rocopy": "If S-mode is supported, an implementation may make SBE be a read-only\ncopy of MBE.",
    "norm:mstatus_ube_rocopy": "If U-mode is supported, an implementation may make UBE be a\nread-only copy of either MBE or SBE.",
    "norm:mstatus_tvm_warl_op": "The TVM (Trap Virtual Memory) bit is a WARL field that supports intercepting supervisor virtual-memory management operations. When TVM=1, attempts to read or write the satp CSR or execute an SFENCE.VMA or SINVAL.VMA instruction while executing in S-mode will raise an illegal-instruction exception. When TVM=0, these operations are permitted in S-mode. TVM is read-only 0 when S-mode is not supported.",
    "norm:mstatus_tw_warl": "The TW (Timeout Wait) bit is a WARL field that supports intercepting the WFI\ninstruction (see &lt;&lt;wfi&gt;&gt;).",
    "norm:mstatus_tw_op": "When TW=0, the WFI\ninstruction may execute in modes less privileged than M when not prevented for\nsome other reason. When TW=1, then if WFI is executed in any\nless-privileged mode, and it does not complete within an\nimplementation-specific, bounded time limit, the WFI instruction causes\nan illegal-instruction exception.",
    "norm:mstatus_tw_always_illegal": "An implementation may have WFI always\nraise an illegal-instruction exception in modes less privileged than M when\nTW=1, even if there are pending globally-disabled interrupts when the\ninstruction is executed.",
    "norm:mstatus_tw_acc": "TW is read-only 0 when there are no modes less privileged than M.",
    "norm:mstatus_tw_umode_op": "When S-mode is implemented, then executing WFI in U-mode causes an\nillegal-instruction exception, regardless of the value of the TW bit, unless the\ninstruction completes within an implementation-specific, bounded time limit.",
    "norm:mstatus_tsr_warl": "The TSR (Trap SRET) bit is a WARL field that supports intercepting the\nsupervisor exception return instruction, SRET.",
    "norm:mstatus_tsr_op": "When TSR=1, attempts to\nexecute SRET while executing in S-mode will raise an illegal-instruction\nexception. When TSR=0, this operation is permitted in S-mode.",
    "norm:mstatus_tsr_acc": "TSR is read-only 0 when S-mode is not supported.",
    "norm:mstatus_fs_vs_warl": "The FS[1:0] and VS[1:0] WARL fields",
    "norm:mstatus_fs_op": "The FS field encodes the status of the\nfloating-point unit state, including the floating-point registers\nf0–f31 and the CSRs fcsr, frm, and fflags.",
    "norm:mstatus_vs_op": "The VS field encodes the status of the\nvector extension state, including the vector\nregisters v0–v31 and the CSRs vcsr, vxrm, vxsat, vstart,\nvl, vtype, and vlenb.",
    "norm:mstatus_xs_op1": "The XS field encodes the status of\nadditional user-mode extensions and associated state.",
    "norm:mstatus_fs_vs_xs_enc": "Status|FS and VS Meaning|XS Meaning\n===\n0\n1\n2\n3|Off\nInitial\nClean\nDirty|All off\nNone dirty or clean, some on\nNone dirty, some clean\nSome dirty\n===",
    "norm:mstatus_fs_acc1": "If the F extension is implemented, the FS field shall not be read-only zero.",
    "norm:mstatus_fs_acc2": "If neither the F extension nor S-mode is implemented, then FS is read-only zero.",
    "norm:mstatus_fs_rdonly0_s_no_f": "If S-mode is implemented but the F extension is not, FS\nmay optionally be read-only zero.",
    "norm:mstatus_vs_acc1": "If the v registers are implemented, the VS field shall not be read-only zero.",
    "norm:mstatus_vs_acc2": "If neither the v registers nor S-mode is implemented, then VS is\nread-only zero.",
    "norm:mstatus_vs_rdonly0_s_no_v": "If S-mode is implemented but the v registers are not,\nVS may optionally be read-only zero.",
    "norm:mstatus_xs_acc": "In harts without additional user extensions requiring new state, the\nXS field is read-only zero.",
    "norm:mstatus_xs_equiv": "Every additional extension with state\nprovides a CSR field that encodes the equivalent of the XS states.",
    "norm:mstatus_xs_op2": "The XS field represents a summary of all extensions' status as shown in\n&lt;&lt;norm:mstatus_fs_vs_xs_enc&gt;&gt;.",
    "norm:mstatus_sd_acc": "The SD bit is a read-only bit",
    "norm:mstatus_sd_op": "summarizes whether either the FS, VS,\nor XS fields signal the presence of some dirty state that will require\nsaving extended user context to memory.",
    "norm:mstatus_sd_rdonly0": "If FS, XS, and VS are all read-only zero, then SD is also always zero.",
    "norm:mstatus_fs_vs_xs_off_op": "When an extension's status is set to Off, any instruction that attempts\nto read or write the corresponding state will cause an\nillegal-instruction exception.",
    "norm:mstatus_fs_vs_xs_initial_op": "When the status is Initial, the corresponding\nstate should have an initial constant value.",
    "norm:mstatus_fs_vs_xs_clean_op": "When the status is Clean,\nthe corresponding state is potentially different from the initial value,\nbut matches the last value stored on a context swap.",
    "norm:mstatus_fs_vs_xs_dirty_op": "When the status is Dirty,\nthe corresponding state has potentially been modified since the last context save.",
    "norm:mstatus_fs_vs_xs_update_indep_priv": "The status fields will\nalso be updated during execution of instructions, regardless of privilege mode.",
    "norm:mstatus_fs_wr": "Changing the setting of FS has no effect on the contents of the\nfloating-point register state. In particular, setting FS=Off does not\ndestroy the state, nor does setting FS=Initial clear the contents.",
    "norm:mstatus_vs_wr": "the setting of VS has no effect on the contents of the vector\nregister state.",
    "norm:mstatus_fs_imprecise": "Implementations may choose to track the dirtiness of the floating-point\nregister state imprecisely by reporting the state to be dirty even when\nit has not been modified.\nOn some implementations, some instructions\nthat do not mutate the floating-point state may cause the state to\ntransition from Initial or Clean to Dirty.",
    "norm:mstatus_fs_no_dirty_track": "dirtiness might not be tracked at all, in which case the valid FS states\nare Off and Dirty, and an attempt to set FS to Initial or Clean causes\nit to be set to Dirty.",
    "norm:mstatus_fs_no_change_dirty": "If an instruction explicitly or implicitly writes a floating-point\nregister or the fcsr but does not alter its contents, and FS=Initial\nor FS=Clean, it is implementation-defined whether FS transitions to\nDirty.",
    "norm:mstatus_vs_imprecise": "Implementations may choose to track the dirtiness of the vector register\nstate in an analogous imprecise fashion, including possibly setting VS\nto Dirty when software attempts to set VS=Initial or VS=Clean.",
    "norm:mstatus_vs_no_change_dirty": "When VS=Initial or VS=Clean, it is implementation-defined whether an\ninstruction that writes a vector register or vector CSR but does not\nalter its contents causes VS to transition to Dirty.",
    "norm:mstatus_spelp_mpelp_op": "The Zicfilp extension adds the SPELP and MPELP fields that hold the previous\nELP, and are updated as specified in &lt;&lt;ZICFILP_FORWARD_TRAPS&gt;&gt;.",
    "norm:mstatus_spelp_mpelp_enc_lead-in": "The x`PELP` fields are encoded as follows:",
    "norm:mstatus_spelp_mpelp_enc_list": "0 - NO_LP_EXPECTED - no landing pad instruction expected.\n1 - LP_EXPECTED - a landing pad instruction is expected.",
    "norm:mtvec_sz_warl_acc": "The mtvec register is an MXLEN-bit WARL read/write register that holds\ntrap vector configuration, consisting of a vector base address (BASE)\nand a vector mode (MODE).",
    "norm:mtvec_enc": "",
    "norm:mtvec_mandatory": "The mtvec register must always be implemented",
    "norm:mtvec_rdonly": "can contain a read-only value.",
    "norm:mtvec_base_align_4B": "The value in the BASE field must\nalways be aligned on a 4-byte boundary",
    "norm:mtvec_base_align_func_mode": "the MODE setting may impose\nadditional alignment constraints on the value in the BASE field.",
    "norm:mtvec_mode_enc": "Value|Name|Description\n===\n0\n1\n≥2|Direct\nVectored\n---|All traps set pc to BASE.\nAsynchronous interrupts set pc to BASE+4×cause.\nReserved\n===",
    "norm:mtvec_mode_direct_op": "When MODE=Direct, all traps into\nmachine mode cause the pc to be set to the address in the BASE field.",
    "norm:mtvec_mode_vectored_op": "When MODE=Vectored, all synchronous exceptions into machine mode cause\nthe pc to be set to the address in the BASE field, whereas interrupts\ncause the pc to be set to the address in the BASE field plus four\ntimes the interrupt cause number.",
    "norm:rst_and_nmi_addr": "Reset and NMI vector locations are given in a platform specification.",
    "norm:trap_def_M-mode": "By default, all traps at any privilege level are handled in machine\nmode",
    "norm:medeleg_mideleg_op1": "implementations can provide individual read/write bits within medeleg\nand mideleg to indicate that certain exceptions and interrupts should\nbe processed directly by a lower privilege level.",
    "norm:medeleg_sz_acc": "The machine exception delegation register (medeleg) is a 64-bit read/write register.",
    "norm:mideleg_sz_acc": "The machine interrupt delegation (mideleg) register is an MXLEN-bit\nread/write register.",
    "norm:medeleg_mideleg_mandatory_S-mode": "In harts with S-mode, the medeleg and mideleg registers must\nexist",
    "norm:medeleg_mideleg_op2": "setting a bit in medeleg or mideleg will delegate the\ncorresponding trap, when occurring in S-mode or U-mode, to the S-mode\ntrap handler.",
    "norm:medeleg_mideleg_omit_wo_S-mode": "In harts without S-mode, the medeleg and mideleg registers should not exist.",
    "norm:trap_del_S-mode": "When a trap is delegated to S-mode",
    "norm:trap_del_S-mode_op": "the scause register is written\nwith the trap cause; the sepc register is written with the virtual\naddress of the instruction that took the trap; the stval register is\nwritten with an exception-specific datum; the SPP field of mstatus is\nwritten with the active privilege mode at the time of the trap; the SPIE\nfield of mstatus is written with the value of the SIE field at the\ntime of the trap; and the SIE field of mstatus is cleared.",
    "norm:trap_del_S-mode_no_M-mode": "The mcause, mepc, and mtval registers and the MPP and MPIE fields of\nmstatus are not written.",
    "norm:medeleg_mideleg_warl": "An implementation can choose to subset the delegatable traps, with the\nsupported delegatable bits found by writing one to every bit location,\nthen reading back the value in medeleg or mideleg to see which bit\npositions hold a one.",
    "norm:medeleg_no_rd1": "An implementation shall not have any bits of medeleg be read-only one",
    "norm:mideleg_no_rd1": "an implementation shall not fix as read-only one\nany bits of mideleg corresponding to machine-level interrupts",
    "norm:mideleg_rd1_lower_level": "may do so for lower-level interrupts",
    "norm:trap_never_trans_lower": "Traps never transition from a more-privileged mode to a less-privileged mode.\nFor example, if M-mode has delegated illegal-instruction\nexceptions to S-mode, and M-mode software later executes an illegal\ninstruction, the trap is taken in M-mode, rather than being delegated to S-mode.",
    "norm:trap_horiz": "traps may be taken horizontally. Using the same\nexample, if M-mode has delegated illegal-instruction exceptions to\nS-mode, and S-mode software later executes an illegal instruction, the\ntrap is taken in S-mode.",
    "norm:trap_del_intr_priv_lvl": "Delegated interrupts result in the interrupt being masked at the\ndelegator privilege level. For example, if the supervisor timer\ninterrupt (STI) is delegated to S-mode by setting mideleg[5], STIs\nwill not be taken when executing in M-mode. By contrast, if mideleg[5]\nis clear, STIs can be taken in any mode and regardless of current mode\nwill transfer control to M-mode.",
    "norm:medeleg_enc_img": "",
    "norm:medeleg_enc_txt": "medeleg has a bit position allocated for every synchronous exception\nshown in &lt;&lt;norm:mcause_exccode_enc_img&gt;&gt;, with the index of the\nbit position equal to the value returned in the mcause register",
    "norm:medelegh_sz_acc_enc_xlen32": "When XLEN=32, medelegh is a 32-bit read/write register\nthat aliases bits 63:32 of medeleg.",
    "norm:medelegh_omit_xlen64": "The medelegh register does not exist when XLEN=64.",
    "norm:mideleg_enc_img": "",
    "norm:mideleg_enc_txt": "mideleg holds trap delegation bits for individual interrupts, with the\nlayout of bits matching those in the mip register",
    "norm:medeleg_when_rd0": "For exceptions that cannot occur in less privileged modes, the\ncorresponding medeleg bits should be read-only zero. In particular,\nmedeleg[11] is read-only zero.",
    "norm:medeleg_16_no_rd0": "The medeleg[16] is read-only zero as double trap is not delegatable.",
    "norm:mip_sz_acc": "The mip register is an MXLEN-bit read/write register containing\ninformation on pending interrupts",
    "norm:mie_sz_acc": "mie is the corresponding\nMXLEN-bit read/write register containing interrupt enable bits.",
    "norm:mip_mie_enc_txt": "Interrupt cause number i (as reported in CSR mcause,\n&lt;&lt;mcause&gt;&gt;) corresponds with bit i in both mip and mie.\nBits 15:0 are allocated to standard interrupt causes only, while\nbits 16 and above are designated for platform use.",
    "norm:mip_enc_img": "",
    "norm:mie_enc_img": "",
    "norm:intr_mip_mie_op": "An interrupt i will trap to M-mode (causing the privilege mode to\nchange to M-mode) if all of the following are true: (a) either the\ncurrent privilege mode is M and the MIE bit in the mstatus register is\nset, or the current privilege mode has less privilege than M-mode;\n(b) bit i is set in both mip and mie; and (c) if register\nmideleg exists, bit i is not set in mideleg.",
    "norm:intr_mip_mie_bounded_time": "These conditions for an interrupt trap to occur must be evaluated in a\nbounded amount of time from when an interrupt becomes, or ceases to be,\npending in mip,",
    "norm:intr_mip_mie_xret_csrwr": "be evaluated immediately following the\nexecution of an xRET instruction or an explicit write to a CSR on\nwhich these interrupt trap conditions expressly depend (including mip,\nmie, mstatus, and mideleg).",
    "norm:intr_M-mode_highest_pri": "Interrupts to M-mode take priority over any interrupts to lower privilege modes.",
    "norm:mip_bits_wr_or_rdonly": "Each individual bit in register mip may be writable or may be read-only.",
    "norm:mip_bits_wr_op": "When bit i in mip is writable, a pending interrupt i\ncan be cleared by writing 0 to this bit.",
    "norm:mip_bits_rdonly_op": "If interrupt i can become pending but bit i in mip is read-only, the implementation must\nprovide some other mechanism for clearing the pending interrupt.",
    "norm:mie_bits_wr": "A bit in mie must be writable if the corresponding interrupt can ever become pending.",
    "norm:mie_bits_rdonly0": "Bits of mie that are not writable must be read-only zero.",
    "norm:mip_mie_std_enc_txt": "The standard portions (bits 15:0) of the mip and mie registers are\nformatted as shown in &lt;&lt;norm:mip_std_enc_img&gt;&gt; and &lt;&lt;norm:mie_std_enc_img&gt;&gt; respectively.",
    "norm:mip_std_enc_img": "",
    "norm:mie_std_enc_img": "",
    "norm:mip_meip_mie_meie_op": "Bits mip.MEIP and mie.MEIE are the interrupt-pending and\ninterrupt-enable bits for machine-level external interrupts.",
    "norm:mip_meip_rdonly": "MEIP is read-only in mip, and is set and cleared by a platform-specific\ninterrupt controller.",
    "norm:mip_mtip_mie_mtie_op": "Bits mip.MTIP and mie.MTIE are the interrupt-pending and\ninterrupt-enable bits for machine timer interrupts.",
    "norm:mip_mtip_rdonly": "MTIP is read-only in the mip register, and is cleared by writing to\nthe memory-mapped machine-mode timer compare register.",
    "norm:mip_msip_mie_msie_op": "Bits mip.MSIP and mie.MSIE are the interrupt-pending and\ninterrupt-enable bits for machine-level software interrupts.",
    "norm:mip_msip_rdonly": "MSIP is read-only in mip, and is written by accesses to memory-mapped control\nregisters, which are used to provide machine-level interprocessor interrupts.",
    "norm:msip_sz_acc": "A hart's memory-mapped msip register is a 32-bit read/write register",
    "norm:msip_enc": "bits 31--1 read as zero and bit 0 contains the MSIP bit.",
    "norm:msip_update_max_time": "When the memory-mapped msip register changes, it is guaranteed to be\nreflected in mip.MSIP eventually, but not necessarily immediately.",
    "norm:mip_msip_mie_msie_maybe_rdonly0": "If a system has only one hart, or\nif a platform standard supports the delivery of machine-level\ninterprocessor interrupts through external interrupts (MEI) instead,\nthen mip.MSIP and mie.MSIE may both be read-only zeros.",
    "norm:mip_sxip_mie_sxie_rdonly0": "If supervisor mode is not implemented, bits SEIP, STIP, and SSIP of\nmip and SEIE, STIE, and SSIE of mie are read-only zeros.",
    "norm:mip_seip_mie_seie_op": "If supervisor mode is implemented, bits mip.SEIP and mie.SEIE are\nthe interrupt-pending and interrupt-enable bits for supervisor-level external interrupts.",
    "norm:mip_seip_acc": "SEIP is writable in mip",
    "norm:intr_sei_op": "Supervisor-level external interrupts are made pending based on the logical-OR of the\nsoftware-writable SEIP bit and the signal from the external interrupt controller.",
    "norm:mip_seip_rdcsr": "When mip is read with a CSR instruction, the value of the\nSEIP bit returned in the rd destination register is the logical-OR of\nthe software-writable bit and the interrupt signal from the interrupt\ncontroller",
    "norm:mip_seip_wrcsr": "the signal from the interrupt controller is not used to\ncalculate the value written to SEIP. Only the software-writable SEIP bit\nparticipates in the read-modify-write sequence of a CSRRS or CSRRC instruction.",
    "norm:mip_stip_mie_stie_op": "If supervisor mode is implemented, its mip.STIP and mie.STIE are\nthe interrupt-pending and interrupt-enable bits for supervisor-level timer interrupts.",
    "norm:mip_stip_no-stimecmp_acc": "If the stimecmp register is not implemented, STIP is writable in\nmip",
    "norm:mip_stip_no-stimecmp_op2": "may be written by M-mode software to deliver timer interrupts to\nS-mode.",
    "norm:mip_stip_stimecmp_acc": "If the stimecmp (supervisor-mode timer compare) register is\nimplemented, STIP is read-only in mip",
    "norm:mip_stip_stimecmp_op2": "reflects the supervisor-level timer\ninterrupt signal resulting from stimecmp.",
    "norm:mip_stip_stimecmp_clr": "This timer interrupt signal is\ncleared by writing stimecmp with a value greater than the current time value.",
    "norm:mip_ssip_mie_ssie_op": "If supervisor mode is implemented, bits mip.SSIP and mie.SSIE are\nthe interrupt-pending and interrupt-enable bits for supervisor-level software interrupts.",
    "norm:mip_ssip_acc": "SSIP is writable in mip",
    "norm:mip_ssip_intr_ctrl": "may also be set to 1\nby a platform-specific interrupt controller.",
    "norm:mip_lcofip_mie_lcofie_op": "If the Sscofpmf extension is implemented, bits mip.LCOFIP and mie.LCOFIE\nare the interrupt-pending and interrupt-enable bits for local-counter-overflow interrupts.",
    "norm:mip_lcofip_acc": "LCOFIP is read-write in mip",
    "norm:mip_lcofip_op2": "reflects the occurrence of a local\ncounter-overflow overflow interrupt request resulting from any of the mhpmeventn.OF bits being set.",
    "norm:mip_lcofip_mie_lcofie_rdonly0": "If the Sscofpmf extension is not implemented, mip.LCOFIP and mie.LCOFIE are\nread-only zeros.",
    "norm:intr_M-mode_pri": "Multiple simultaneous interrupts destined for M-mode are handled in the\nfollowing decreasing priority order: MEI, MSI, MTI, SEI, SSI, STI, LCOFI.",
    "norm:m_mode_perf_monitoring": "M-mode includes a basic hardware performance-monitoring facility.",
    "norm:mcycle_op": "The mcycle CSR counts the number of clock cycles executed by the processor\ncore on which the hart is running.",
    "norm:minstret_op": "The minstret CSR counts the number of instructions the hart has retired.",
    "norm:mcycle_minstret_sz": "The mcycle and minstret registers have 64-bit precision on all RV32 and RV64 harts.",
    "norm:mcycle_minstret_rst": "The counter registers have an arbitrary value after the hart is reset,\nand can be written with a given value.",
    "norm:mcycle_minstret_wr": "Any CSR write takes effect after the writing instruction has otherwise completed.",
    "norm:mcycle_shared": "The mcycle CSR may be\nshared between harts on the same core, in which case writes to mcycle\nwill be visible to those harts.",
    "norm:mhpmcounter_num": "The hardware performance monitor includes 29 additional 64-bit event\ncounters, mhpmcounter3-mhpmcounter31.",
    "norm:mhpmevent_sz_warl_op": "The event selector CSRs,\nmhpmevent3-mhpmevent31, are 64-bit WARL registers that control which\nevent causes the corresponding counter to increment.",
    "norm:mhpmevent_enc": "The meaning of these events is defined by the platform,\nbut event 0 is defined to mean \"no event.\"",
    "norm:mhpmcounter_mandatory": "All counters should be implemented",
    "norm:mhpmcounter_mhpmevent_rdonly0": "a legal implementation is to make both the counter and its corresponding event selector be read-only 0.",
    "norm:mhpmcounter_warl": "The mhpmcounters are WARL registers",
    "norm:mhpmcounter_sz": "support up to 64 bits of precision on RV32 and RV64.",
    "norm:mcycleh_minstreth_mhpmh_op": "reads of the mcycleh, minstreth, mhpmcounternh, and mhpmeventnh\nCSRs return bits 63-32 of the corresponding register, and writes change only bits 63-32.",
    "norm:mhpmeventh_presence": "The mhpmeventnh CSRs are provided only if the Sscofpmf extension is implemented.",
    "norm:mcounteren_sz": "The counter-enable mcounteren register is a 32-bit register",
    "norm:mcounteren_op": "controls the availability of the hardware performance-monitoring\ncounters to the next-lower privileged mode.",
    "norm:mcounteren_enc_img": "",
    "norm:mcounteren_inc_inaccessible": "The settings in this register only control accessibility. The act of\nreading or writing this register does not affect the underlying\ncounters, which continue to increment even when not accessible.",
    "norm:mcounteren_clr_ill_inst_exc": "When the CY, TM, IR, or HPMn bit in the mcounteren register is\nclear, attempts to read the cycle, time, instret, or\nhpmcountern register while executing in S-mode or U-mode will cause an\nillegal-instruction exception.",
    "norm:mcounteren_set_nxt_priv": "When one of these bits is set, access to\nthe corresponding register is permitted in the next implemented\nprivilege mode (S-mode if implemented, otherwise U-mode).",
    "norm:mcounteren_tm_clr": "when the TM bit in the mcounteren register is clear, attempts to\naccess the stimecmp or vstimecmp register while executing in a mode less\nprivileged than M will cause an illegal-instruction exception.",
    "norm:mcounteren_tm_set": "When this bit is set, access to the stimecmp or vstimecmp register is permitted in S-mode\nif implemented, and access to the vstimecmp register (via stimecmp) is\npermitted in VS-mode if implemented and not otherwise prevented by the TM bit in\nhcounteren.",
    "norm:cycle_instret_hpmcounter_op_rdonly": "The cycle, instret, and hpmcountern CSRs are read-only shadows of mcycle, minstret, and mhpmcounter n, respectively.",
    "norm:time_op_rdonly": "The time CSR is a read-only shadow of the memory-mapped mtime register.",
    "norm:cycleh_instreth_hpmcounternh_op_rdonly": "when XLEN=32, the cycleh, instreth and hpmcounternh CSRs\nare read-only shadows of mcycleh, minstreth and mhpmcounternh, respectively.",
    "norm:timeh_op_rdonly": "When XLEN=32, the timeh CSR is a read-only shadow of the\nupper 32 bits of the memory-mapped mtime register",
    "norm:time_csr_architectural_availability": "Implementations can convert reads of the time and timeh CSRs into\nloads to the memory-mapped mtime register, or emulate this\nfunctionality on behalf of less-privileged modes in M-mode software.",
    "norm:mcounteren_flds_mandatory_warl": "In harts with U-mode, the mcounteren must be\nimplemented, but all fields are WARL",
    "norm:mcounteren_flds_rdonly0": "may be read-only zero, indicating reads to the\ncorresponding counter will cause an illegal-instruction exception when\nexecuting in a less-privileged mode.",
    "norm:mcounteren_presence": "In harts without U-mode, the mcounteren register should not exist.",
    "norm:mcountinhibit_enc_img": "",
    "norm:mcountinhibit_sz_warl_op1": "The counter-inhibit register mcountinhibit is a 32-bit\nWARL register that controls which of the hardware performance-monitoring counters increment.",
    "norm:mcountinhibit_only_inc": "The settings in this register only control whether the\ncounters increment; their accessibility is not affected by the setting\nof this register.",
    "norm:mcountinhibit_op2": "When the CY, IR, or HPMn bit in the mcountinhibit register is clear,\nthe mcycle, minstret, or mhpmcountern register increments as usual.\nWhen the CY, IR, or HPMn bit is set, the corresponding counter does\nnot increment.",
    "norm:mcountinhibit_cy_shared": "The mcycle CSR may be shared between harts on the same core,\nin which case the mcountinhibit.CY field is also shared between those harts,\nand so writes to mcountinhibit.CY will be visible to those harts.",
    "norm:mcountinhibit_not_impl": "If the mcountinhibit register is not implemented, the implementation\nbehaves as though the register were set to zero.",
    "norm:mscratch_sz_acc": "The mscratch register is an MXLEN-bit read/write register dedicated\nfor use by machine mode.",
    "norm:mscratch_enc_img": "",
    "norm:mepc_sz_acc": "mepc is an MXLEN-bit read/write register",
    "norm:mepc_align": "The low bit of mepc (mepc[0]) is always zero. On implementations that support only IALIGN=32, the two low bits (mepc[1:0]) are always zero.",
    "norm:mepc_bit1_dyn_ialign_op": "If an implementation allows IALIGN to be either 16 or 32 (by changing\nCSR misa, for example), then, whenever IALIGN=32, bit mepc[1] is\nmasked on reads so that it appears to be 0. This masking occurs also for\nthe implicit read by the MRET instruction. Though masked, mepc[1]\nremains writable when IALIGN=32.",
    "norm:mepc_warl": "mepc is a WARL register",
    "norm:mepc_inv_addr_conv": "Prior to writing mepc, implementations may convert an\ninvalid address into some other invalid address that mepc is capable of holding.",
    "norm:mepc_op": "When a trap is taken into M-mode, mepc is written with the virtual\naddress of the instruction that was interrupted or that encountered the\nexception. Otherwise, mepc is never written by the implementation,\nthough it may be explicitly written by software.",
    "norm:mepc_enc_img": "",
    "norm:mcause_sz_acc": "The mcause register is an MXLEN-bit read-write register",
    "norm:mcause_op": "When a trap is taken into\nM-mode, mcause is written with a code indicating the event that\ncaused the trap. Otherwise, mcause is never written by the\nimplementation, though it may be explicitly written by software.",
    "norm:mcause_intr_op": "The Interrupt bit in the mcause register is set if the trap was\ncaused by an interrupt.",
    "norm:mcause_exccode_op": "The Exception Code field contains a code identifying\nthe last exception or interrupt.",
    "norm:mcause_exccode_wlrl": "The Exception Code is a WLRL field, so is only guaranteed to hold supported exception codes.",
    "norm:mcause_enc_img": "",
    "norm:mcause_exccode_ld_ldrsv": "Note that load and load-reserved instructions generate load exceptions",
    "norm:mcause_exccode_st_sc_amo": "store, store-conditional, and AMO instructions generate\nstore/AMO exceptions.",
    "norm:mcause_exccode_pri1": "If an instruction may raise multiple synchronous exceptions, the\ndecreasing priority order of &lt;&lt;norm:exc_priority&gt;&gt; indicates which\nexception is taken and reported in mcause.",
    "norm:mcause_exccode_enc_img": "Interrupt|Exception Code|Description\n===\n1\n1\n1\n1|0\n1\n2\n3|Reserved\nSupervisor software interrupt\nReserved\nMachine software interrupt¶1\n1\n1\n1|4\n5\n6\n7|Reserved\nSupervisor timer interrupt\nReserved\nMachine timer interrupt¶1\n1\n1\n1|8\n9\n10\n11|Reserved\nSupervisor external interrupt\nReserved\nMachine external interrupt¶1\n1\n1\n1|12\n13\n14-15\n≥16|Reserved\nCounter-overflow interrupt\nReserved\nDesignated for platform use¶0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0|0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20-23\n24-31\n32-47\n48-63\n≥64|Instruction address misaligned\nInstruction access fault\nIllegal instruction\nBreakpoint\nLoad address misaligned\nLoad access fault\nStore/AMO address misaligned\nStore/AMO access fault\nEnvironment call from U-mode\nEnvironment call from S-mode\nReserved\nEnvironment call from M-mode\nInstruction page fault\nLoad page fault\nReserved\nStore/AMO page fault\nDouble trap\nReserved\nSoftware check\nHardware error\nReserved\nDesignated for custom use\nReserved\nDesignated for custom use\nReserved\n===",
    "norm:exc_priority": "Priority|Exc.Code|Description\n===\nHighest|3|Instruction address breakpoint¶|12, 1|During instruction address translation:\nFirst encountered page fault or access fault¶|1|With physical address for instruction:\nInstruction access fault¶|2\n0\n8,9,11\n3\n3|Illegal instruction\nInstruction address misaligned\nEnvironment call\nEnvironment break\nLoad/store/AMO address breakpoint¶|4,6|Optionally:\nLoad/store/AMO address misaligned¶|13, 15, 5, 7|During address translation for an explicit memory access:\nFirst encountered page fault or access fault¶|5,7|With physical address for an explicit memory access:\nLoad/store/AMO access fault¶Lowest|4,6|If not higher priority:\nLoad/store/AMO address misaligned\n===",
    "norm:mcause_exccode_pri2": "Load/store/AMO address-misaligned exceptions may have either higher or\nlower priority than load/store/AMO page-fault and access-fault exceptions.",
    "norm:mtval_sz_acc": "The mtval register is an MXLEN-bit read-write register formatted as\nshown in &lt;&lt;norm:mtval_enc_img&gt;&gt;",
    "norm:mtval_op": "When a trap is taken into M-mode,\nmtval is either set to zero or written with exception-specific\ninformation to assist software in handling the trap. Otherwise, mtval\nis never written by the implementation, though it may be explicitly\nwritten by software.",
    "norm:mtval_per_exc_behavior": "The hardware platform will specify which exceptions\nmust set mtval informatively, which may unconditionally set it to\nzero, and which may exhibit either behavior, depending on the underlying event\nthat caused the exception.",
    "norm:mtval_rdonly0": "If the hardware platform specifies that no exceptions set mtval\nto a nonzero value, then mtval is read-only zero.",
    "norm:mtval_vaddr_wr1": "If mtval is written with a nonzero value when a breakpoint,\naddress-misaligned, access-fault, page-fault, or hardware-error exception\noccurs on an instruction fetch, load, or store, then mtval will contain the\nfaulting virtual address.",
    "norm:mtval_vaddr_not_paddr": "When page-based virtual memory is enabled, mtval is written with the\nfaulting virtual address, even for physical-memory access-fault exceptions.",
    "norm:mtval_enc_img": "",
    "norm:mtval_vaddr_wr2": "If mtval is written with a nonzero value when a misaligned load or\nstore causes an access-fault, page-fault, or hardware-error exception, then mtval will\ncontain the virtual address of the portion of the access that caused the fault.",
    "norm:mtval_varlen_wr": "If mtval is written with a nonzero value when an instruction\naccess-fault, page-fault, or hardware-error exception occurs on a hart with\nvariable-length instructions, then mtval will contain the virtual\naddress of the portion of the instruction that caused the fault",
    "norm:mepc_varlen_wr": "mepc will point to the beginning of the instruction.",
    "norm:mtval_instr_bits_lead-in": "The mtval register can optionally also be used to return the faulting\ninstruction bits on an illegal-instruction exception",
    "norm:mtval_instr_bits_list": "the actual faulting instruction\nthe first ILEN bits of the faulting instruction\nthe first MXLEN bits of the faulting instruction",
    "norm:mtval_ill_instr_exc_in_low_bits": "The value loaded into mtval on an illegal-instruction exception is\nright-justified and all unused upper bits are cleared to zero.",
    "norm:mtval_swchk_lead-in": "On a trap caused by a software-check exception, the mtval register holds\nthe cause for the exception. The following encodings are defined:",
    "norm:mtval_swchk_list": "0 - No information provided.\n2 - Landing Pad Fault. Defined by the Zicfilp extension ().\n3 - Shadow Stack Fault. Defined by the Zicfiss extension ().",
    "norm:mtval_other_traps_zero": "For other traps, mtval is set to zero",
    "norm:mtval_warl": "If mtval is not read-only zero, it is a WARL register",
    "norm:mtval_vaddr_and_0_sz": "must be able to hold all valid virtual addresses and the value zero.",
    "norm:mtval_inv_addr_conv": "Prior to writing mtval, implementations may convert an invalid address\ninto some other invalid address that mtval is capable of holding.",
    "norm:mtval_instr_bits_sz": "If the feature to return the faulting instruction bits is implemented,\nmtval must also be able to hold all values less than 2^N^, where\nN is the smaller of MXLEN and ILEN.",
    "norm:mconfigptr_sz_acc": "The mconfigptr register is an MXLEN-bit read-only CSR formatted as shown in &lt;&lt;norm:mconfigptr_enc_img&gt;&gt;",
    "norm:mconfigptr_op": "holds the physical address of a configuration data structure.",
    "norm:mconfigptr_enc_img": "",
    "norm:mconfigptr_align": "The pointer alignment in bits must be no smaller than MXLEN: i.e., if MXLEN is\n8{times}n, then mconfigptr[log~2n~-1:0] must be zero.",
    "norm:mconfigptr_mandatory": "The mconfigptr register must be implemented",
    "norm:mconfigptr_zero": "it may be zero to indicate the\nconfiguration data structure does not exist or that an alternative\nmechanism must be used to locate it.",
    "norm:menvcfg_sz_acc": "The menvcfg CSR is a 64-bit read/write register, formatted\nas shown in &lt;&lt;norm:menvcfg_enc_img&gt;&gt;",
    "norm:menvcfg_op": "controls certain characteristics of the execution environment\nfor modes less privileged than M.",
    "norm:menvcfg_enc_img": "",
    "norm:menvcfg_fiom_fence_op": "If bit FIOM (Fence of I/O implies Memory) is set to one in menvcfg,\nFENCE instructions executed in modes less privileged than M are modified\nso the requirement to order accesses to device I/O implies also the\nrequirement to order main memory accesses. &lt;&lt;norm:menvcfg_fiom_fence_presuc_op&gt;&gt;\ndetails the modified interpretation of FENCE instruction bits PI, PO,\nSI, and SO for modes less privileged than M when FIOM=1.",
    "norm:menvcfg_fiom_atomic_op": "for modes less privileged than M when FIOM=1, if an atomic\ninstruction that accesses a region ordered as device I/O has its aq\nand/or rl bit set, then that instruction is ordered as though it\naccesses both device I/O and memory.",
    "norm:menvcfg_fiom_rdonly0_ok": "If S-mode is not supported, or if satp.MODE is read-only zero (always\nBare), the implementation may make FIOM read-only zero.",
    "norm:menvcfg_fiom_fence_presuc_op": "Instruction bit|Meaning when set\n===\nPI\nPO|Predecessor device input and memory reads (PR implied)\nPredecessor device output and memory writes (PW implied)¶SI\nSO|Successor device input and memory reads (SR implied)\nSuccessor device output and memory writes (SW implied)\n===",
    "norm:menvcfg_pbmte_op": "The PBMTE bit controls whether the Svpbmt extension is available for use\nin S-mode and G-stage address translation (i.e., for page tables pointed\nto by satp or hgatp). When PBMTE=1, Svpbmt is available for S-mode\nand G-stage address translation. When PBMTE=0, the implementation\nbehaves as though Svpbmt were not implemented.",
    "norm:menvcfg_pbmte_rdonly0": "If Svpbmt is not implemented, PBMTE is read-only zero.",
    "norm:menvcfg_pbmte_henvcfg_pbmte_rdonly0": "for implementations with the hypervisor extension,\nhenvcfg.PBMTE is read-only zero if menvcfg.PBMTE is zero.",
    "norm:menvcfg_pbmte_fence": "After changing menvcfg.PBMTE, executing an SFENCE.VMA instruction with\nrs1=x0 and rs2=x0 suffices to synchronize address-translation caches\nwith respect to the altered interpretation of page-table entries' PBMT fields.",
    "norm:menvcfg_adue_op": "If the Svadu extension is implemented, the ADUE bit controls whether hardware\nupdating of PTE A/D bits is enabled for S-mode and G-stage address translations.\nWhen ADUE=1, hardware updating of PTE A/D bits is enabled during S-mode\naddress translation, and the implementation behaves as though the Svade\nextension were not implemented for S-mode address translation.\nWhen the hypervisor extension is implemented, if ADUE=1, hardware updating of\nPTE A/D bits is enabled during G-stage address translation, and the\nimplementation behaves as though the Svade extension were not implemented for\nG-stage address translation.\nWhen ADUE=0, the implementation behaves as though Svade were implemented for\nS-mode and G-stage address translation.",
    "norm:menvcfg_adue_rdonly0": "If Svadu is not implemented, ADUE is read-only zero.",
    "norm:menvcfg_adue_henvcfg_adue_rdonly0": "for implementations with the hypervisor extension,\nhenvcfg.ADUE is read-only zero if menvcfg.ADUE is zero.",
    "norm:menvcfg_adue_fence": "After changing menvcfg.ADUE, executing an SFENCE.VMA instruction with\nrs1=x0 and rs2=x0 suffices to synchronize address-translation caches\nwith respect to the altered interpretation of page-table entries' A/D bits.",
    "norm:menvcfg_cde_op": "If the Smcdeleg extension is implemented, the CDE (Counter Delegation Enable) bit\ncontrols whether Zicntr and Zihpm counters can be delegated to S-mode. When CDE=1, the Smcdeleg extension is\nenabled, see &lt;&lt;smcdeleg&gt;&gt;. When CDE=0, the Smcdeleg and Ssccfg extensions appear to be not implemented.",
    "norm:menvcfg_cde_rdonly0": "If Smcdeleg is not implemented, CDE is read-only zero.",
    "norm:menvcfg_stce_op1": "The Sstc extension adds the STCE (STimecmp Enable) bit to menvcfg CSR.",
    "norm:menvcfg_stce_rdonly0": "When the Sstc extension is not implemented, STCE is read-only zero.",
    "norm:menvcfg_stce_op2": "The STCE bit enables stimecmp for S-mode when set to one.\nWhen this extension is implemented and STCE in menvcfg is zero, an attempt to access stimecmp\nin a mode other than M-mode raises an illegal-instruction exception, STCE in\nhenvcfg is read-only zero, and STIP in mip and sip reverts to its\ndefined behavior as if this extension is not implemented. Further, if the H\nextension is implemented, then hip.VSTIP also reverts its defined behavior as\nif this extension is not implemented.",
    "norm:menvcfg_cbze_op": "The Zicboz extension adds the CBZE (Cache Block Zero instruction enable) field\nto menvcfg. When the CBZE field is set to 1, it enables execution of the\ncache block zero instruction, CBO.ZERO, in modes less privileged than M.\nOtherwise, the instruction raises an illegal-instruction exception in modes less\nprivileged than M.",
    "norm:menvcfg_cbze_rdonly0": "When the Zicboz extension is not implemented, CBZE is read-only zero.",
    "norm:menvcfg_cbcfe_op": "The Zicbom extension adds the CBCFE (Cache Block Clean and Flush instruction\nEnable) field to menvcfg. When the CBCFE field is set to 1, it enables\nexecution of the cache block clean instruction (CBO.CLEAN) and the cache block\nflush instruction (CBO.FLUSH) in modes less privileged than M. Otherwise, these\ninstructions raise an illegal-instruction exception in modes less privileged than M.",
    "norm:menvcfg_cbcfe_rdonly0": "When the Zicbom extension is not implemented, CBCFE is read-only zero.",
    "norm:menvcfg_cbie_warl_op": "The Zicbom extension adds the CBIE (Cache Block Invalidate instruction Enable)\nWARL field to menvcfg to control execution of the cache block invalidate\ninstruction (CBO.INVAL) in modes less privileged than M. When CBIE is set to\n00b, the instruction raises an illegal-instruction exception in modes less\nprivileged than M.",
    "norm:menvcfg_cbie_rdonly0": "When the Zicbom extension is not implemented, CBIE is read-only zero.",
    "norm:menvcfg_cbie_cbo-inval_op_lead-in": "When CBIE is set to 01b\nor 11b, and when enabled for execution in modes less privileged than M, it\nbehaves as follows:",
    "norm:menvcfg_cbie_cbo-inval_op_list": "01b&#8201;&#8212;&#8201;The instruction is executed and performs a flush operation, even if configured by a mode less privileged than M to perform an invalidate operation.\n11b&#8201;&#8212;&#8201;The instruction is executed and performs an invalidate operation, unless configured by a mode less privileged than M to perform a flush operation.",
    "norm:menvcfg_pmm_op": "If the Smnpm extension is implemented, the PMM field enables or disables\npointer masking (see &lt;&lt;Zpm&gt;&gt;) for the next-lower privilege mode (S-/HS-mode if\nS-mode is implemented, or U-mode otherwise), according to the values in\n&lt;&lt;norm:menvcfg_pmm_enc&gt;&gt;.",
    "norm:menvcfg_pmm_rdonly0": "If Smnpm is not implemented, PMM is read-only zero.\nThe PMM field is read-only zero for RV32.",
    "norm:menvcfg_pmm_enc": "Value|Description\n===\n00|Pointer masking is disabled (PMLEN = 0)¶01|Reserved¶10|Pointer masking is enabled with PMLEN = XLEN - 57 (PMLEN = 7 on RV64)¶11|Pointer masking is enabled with PMLEN = XLEN - 48 (PMLEN = 16 on RV64)\n===",
    "norm:menvcfg_lpe_op_lead-in": "The Zicfilp extension adds the LPE field in menvcfg. When the LPE field is\nset to 1 and S-mode is implemented, the Zicfilp extension is enabled in S-mode.\nIf LPE field is set to 1 and S-mode is not implemented, the Zicfilp extension\nis enabled in U-mode. When the LPE field is 0, the Zicfilp extension is not\nenabled in S-mode, and the following rules apply to S-mode. If the LPE field\nis 0 and S-mode is not implemented, then the same rules apply to U-mode.",
    "norm:menvcfg_lpe_op_list": "The hart does not update the ELP state; it remains as NO_LP_EXPECTED.\nThe LPAD instruction operates as a no-op.",
    "norm:menvcfg_sse_op_lead-in": "The Zicfiss extension adds the SSE field to menvcfg.\nWhen the SSE field is set to 1 the Zicfiss extension is activated in S-mode. When SSE field is 0,\nthe following rules apply to privilege modes that are less than M:",
    "norm:menvcfg_sse_op_list": "32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.\n16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.\nThe pte.xwr=010b encoding in VS/S-stage page tables becomes reserved.\nSSAMOSWAP.W/D raises an illegal-instruction exception.",
    "norm:menvcfg_sse_rdonly0": "When menvcfg.SSE is 0, the henvcfg.SSE and senvcfg.SSE fields are\nread-only zero.",
    "norm:menvcfg_dte_op": "The Ssdbltrp extension adds the double-trap-enable (DTE) field in menvcfg.\nWhen menvcfg.DTE is zero, the implementation behaves as though Ssdbltrp is not\nimplemented. When Ssdbltrp is not implemented sstatus.SDT, vsstatus.SDT, and\nhenvcfg.DTE bits are read-only zero.",
    "norm:menvcfgh_sz_acc_op": "When XLEN=32, menvcfgh is a 32-bit read/write register\nthat aliases bits 63:32 of menvcfg.\nThe menvcfgh register does not exist when XLEN=64.",
    "norm:menvcfg_menvcfgh_no_U-mode": "If U-mode is not supported, then registers menvcfg and menvcfgh do\nnot exist.",
    "norm:mseccfg_sz_acc": "mseccfg is a 64-bit read/write register, formatted as shown in &lt;&lt;norm:mseccfg_enc_img&gt;&gt;,\nthat controls security features.",
    "norm:mseccfg_presence": "It exists if any extension that adds a field to mseccfg is implemented. Otherwise, it is reserved.",
    "norm:mseccfg_enc_img": "",
    "norm:mseccfg_sseed_useed_presence": "The Zkr extension adds the SSEED and USEED fields to the mseccfg CSR to control access to the seed CSR from modes less privileged than M.",
    "norm:mseccfg_useed_U-mode_op": "When USEED is 0, access to the seed CSR in U-mode raises an\nillegal-instruction exception. When USEED is 1, read-write access to the\nseed CSR from U-mode is allowed; all other types of accesses raise an\nillegal-instruction exception.",
    "norm:mseccfg_useed_rdonly0": "If Zkr or U-mode is not implemented, USEED is read-only zero.",
    "norm:mseccfg_sseed_SorHS-mode_op": "When SSEED is 0, access to the seed CSR from S-/HS-mode raises an\nillegal-instruction exception. When SSEED is 1, read-write access to the\nseed CSR from S-/HS-mode is allowed; all other types of accesses raise an\nillegal-instruction exception.",
    "norm:mseccfg_sseed_rdonly0": "If Zkr or S-mode is not implemented, SSEED is read-only zero.",
    "norm:mseccfg_sseed_VSorVU-mode_op": "When the H extension is also implemented,\naccess to the seed CSR from an\nHS-qualified instruction leads to a virtual-instruction exception in VS and\nVU modes; all other types of accesses raise an illegal-instruction exception.",
    "norm:mseccfg_sseed_useed_op_tbl": "Mode|SSEED|USEED|Description\n===\nM|-|-|The seed CSR is always available in machine\n                              mode as normal (with a CSR read-write\n                              instruction.) Attempted read without a write\n                              raises an illegal-instruction exception\n                              regardless of mode and access control bits.¶U|-|0|Any seed CSR access raises an\n                              illegal-instruction exception.¶U|-|1|The seed CSR is accessible as normal. No\n                              exception is raised for read-write.¶S/HS|0|-|Any seed CSR access raises an\n                              illegal-instruction exception.¶S/HS|1|-|The seed CSR is accessible as normal. No\n                              exception is raised for read-write.¶VS/VU|0|-|Any seed CSR access raises an\n                              illegal-instruction exception.¶VS/VU|1|-|A read-write seed access raises a\n                              virtual-instruction exception, while other access\n                              conditions raise an illegal-instruction exception.\n===",
    "norm:mseccfg_rlb_mmwp_mml_presence": "The Smepmp extension adds the RLB, MMWP, and the MML fields in mseccfg.",
    "norm:mseccfg_rlb_op_warl": "When mseccfg.RLB (Rule Locking Bypass) a WARL field that provides a mechanism to temporarily modify Locked PMP rules. When mseccfg.RLB is 1, locked PMP rules may be removed or modified and locked PMP rules may be edited. When mseccfg.RLB is 0 and pmpcfg.L is 1 in any rule or entry (including disabled entries), then mseccfg.RLB remains 0 and any further modifications to mseccfg.RLB are ignored until a PMP reset.",
    "norm:mseccfg_mmwp_op_warl": "The mseccfg.MMWP (Machine-Mode Allowlist Policy) is a WARL field. This field changes the default PMP policy for Machine mode when accessing memory regions that don&#8217;t have a matching PMP rule. This is a sticky bit, meaning that once set it cannot be unset until a PMP reset. When set it changes the default PMP policy for M-mode when accessing memory regions that don’t have a matching PMP rule, to denied instead of ignored.",
    "norm:mseccfg_mml_warl": "The mseccfg.MML (Machine Mode Lockdown) is a WARL field.",
    "norm:mseccfg_mml_sticky": "This is a sticky bit, meaning that once set it cannot be unset\nuntil a PMP reset.",
    "norm:mseccfg_mml_set": "When mseccfg.MML is set the system's behavior changes in the following way:",
    "norm:mseccfg_mml_pmpcfg_L_op": "The meaning of pmpcfg.L changes:\nInstead of marking a rule as locked and\nenforced in all modes, it now marks a rule as M-mode-only when set and\nS/U-mode-only when unset. The formerly reserved encoding of pmpcfg.RW=01,\nand the encoding pmpcfg.LRWX=1111, now encode a Shared-Region.",
    "norm:mseccfg_mml_M_rule_op": "An M-mode-only rule is enforced on Machine mode and denied in Supervisor\nor User mode. It also remains locked so that any further modifications to\nits associated configuration or address registers are ignored until a PMP\nreset, unless mseccfg.RLB is set.",
    "norm:mseccfg_mml_SorU_rule_op": "An S/U-mode-only rule is enforced on Supervisor and User modes and\ndenied on Machine mode.",
    "norm:mseccfg_mml_shared_rule_op": "A Shared-Region rule is enforced on all modes, with restrictions depending\non the pmpcfg.L and pmpcfg.X bits:",
    "norm:mseccfg_mml_shared_L0_op": "A Shared-Region rule where pmpcfg.L is not set can be used for sharing\ndata between M-mode and S/U-mode, so is not executable. M-mode has\nread/write access to that region, and S/U-mode has read access if pmpcfg.X\nis not set, or read/write access if pmpcfg.X is set.",
    "norm:mseccfg_mml_shared_L1_op": "A Shared-Region rule where pmpcfg.L is set can be used for sharing code\nbetween M-mode and S/U-mode, so is not writable. Both M-mode and S/U-mode\nhave execute access on the region, and M-mode also has read access if\npmpcfg.X is set. The rule remains locked so that any further\nmodifications to its associated configuration or address registers are\nignored until a PMP reset, unless mseccfg.RLB is set.",
    "norm:mseccfg_mml_shared_LRWX_1111_op": "The encoding pmpcfg.LRWX=1111 can be used for sharing data between M-mode\nand S/U mode, where both modes only have read-only access to the region. The\nrule remains locked so that any further modifications to its associated\nconfiguration or address registers are ignored until a PMP reset, unless\nmseccfg.RLB is set.",
    "norm:mseccfg_mml_X_restrict": "Adding a rule with executable privileges that either is M-mode-only or a\nlocked Shared-Region is not possible and such pmpcfg writes are\nignored, leaving pmpcfg unchanged. This restriction can be temporarily\nlifted by setting mseccfg.RLB",
    "norm:mseccfg_mml_exec_code": "Executing code with Machine mode privileges is only possible from memory\nregions with a matching M-mode-only rule or a locked Shared-Region rule\nwith executable privileges. Executing code from a region without a matching\nrule or with a matching S/U-mode-only rule is denied.",
    "norm:mseccfg_pmm_presence_op": "If the Smmpm extension is implemented,\nthe PMM field enables or disables pointer masking (see &lt;&lt;Zpm&gt;&gt;) for M-mode\naccording to the values in &lt;&lt;norm:mseccfg_pmm_enc&gt;&gt;.",
    "norm:mseccfg_pmm_rdonly0": "If Smmpm is not implemented, PMM is read-only zero.\nThe PMM field is read-only zero for RV32.",
    "norm:mseccfg_pmm_enc": "Value|Description\n===\n00|Pointer masking is disabled (PMLEN = 0)¶01|Reserved¶10|Pointer masking is enabled with PMLEN = XLEN - 57 (PMLEN = 7 on RV64)¶11|Pointer masking is enabled with PMLEN = XLEN - 48 (PMLEN = 16 on RV64)\n===",
    "norm:mseccfg_mlpe_presence": "The Zicfilp extension adds the MLPE field in mseccfg.",
    "norm:mseccfg_mlpe_set_op": "When MLPE field is 1, Zicfilp extension is enabled in M-mode.",
    "norm:mseccfg_mlpe_clr_op_lead-in": "When the MLPE field is 0, the Zicfilp extension is not enabled\nin M-mode and the following rules apply to M-mode.",
    "norm:mseccfg_mlpe_clr_op_list": "The hart does not update the ELP state; it remains as NO_LP_EXPECTED.\nThe LPAD instruction operates as a no-op.",
    "norm:mseccfgh_sz_acc_op": "When XLEN=32 only, mseccfgh is a 32-bit read/write register that\naliases bits 63:32 of mseccfg.",
    "norm:mseccfgh_presence": "Register mseccfgh exists when XLEN=32 and mseccfg is implemented;\nit does not exist when XLEN=64.",
    "norm:mtime_acc": "Platforms provide a real-time counter, exposed as a memory-mapped\nmachine-mode read-write register, mtime.",
    "norm:mtime_op": "mtime must increment at constant frequency",
    "norm:mtime_tick_period": "the platform must provide a mechanism for\ndetermining the period of an mtime tick.",
    "norm:mtime_wrap": "The mtime register will wrap around if the count overflows.",
    "norm:mtime_sz": "The mtime register has a 64-bit precision on all RV32 and RV64 systems.",
    "norm:mtimecmp_sz": "Platforms provide a 64-bit memory-mapped machine-mode timer\ncompare register (mtimecmp).",
    "norm:mtime_intr_pending": "A machine timer interrupt becomes pending\nwhenever mtime contains a value greater than or equal to mtimecmp,\ntreating the values as unsigned integers.\nThe interrupt remains posted until mtimecmp becomes greater than mtime",
    "norm:mtime_intr_taken": "The interrupt will only be taken if interrupts are\nenabled and the MTIE bit is set in the mie register.",
    "norm:mtime_enc_img": "",
    "norm:mtimecmp_enc_img": "",
    "norm:mtime_intr_mtip_visibility": "If the result of the comparison between mtime and mtimecmp\nchanges, it is guaranteed to be reflected in MTIP eventually, but not necessarily immediately.",
    "norm:mtimecmp_rv32_wr": "In RV32, memory-mapped writes to mtimecmp modify only one 32-bit part\nof the register.",
    "norm:mtime_mtimecmp_rv64_wr": "For RV64, naturally aligned 64-bit memory accesses to the mtime and\nmtimecmp registers are additionally supported and are atomic.",
    "norm:time_timeh_visibility_mtime": "When mtime changes, it is guaranteed to be reflected in time\nand timeh eventually, but not necessarily immediately.",
    "norm:ecall_op2": "The ECALL instruction is used to make a request to the supporting execution environment. When executed in U-mode, S-mode, or M-mode, it generates an environment-call-from-U-mode exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception, respectively, and performs no other operation.",
    "norm:ebreak_op2": "The EBREAK instruction is used by debuggers to cause control to be transferred back to a debugging environment. Unless overridden by an external debug environment, EBREAK raises a breakpoint exception and performs no other operation.",
    "norm:ecall_ebreak_epc_value": "ECALL and EBREAK cause the receiving privilege mode’s epc register to\nbe set to the address of the ECALL or EBREAK instruction itself, not\nthe address of the following instruction.",
    "norm:ecall_ebreak_no_minstret_inc": "As ECALL and EBREAK cause\nsynchronous exceptions, they are not considered to retire, and should\nnot increment the minstret CSR.",
    "norm:xret_enc_img": "",
    "norm:mret_presence": "MRET is always provided.",
    "norm:sret_presence": "SRET must be provided if supervisor mode is supported, and\nshould raise an illegal-instruction exception otherwise.",
    "norm:sret_ill_inst_exc_rst": "SRET should also raise an illegal-instruction exception when TSR=1\nin mstatus, as described in &lt;&lt;virt-control&gt;&gt;.",
    "norm:xret_in_higher_mode": "An xRET instruction can be executed in privilege mode x or higher,\nwhere executing a lower-privilege xRET instruction will pop the relevant lower-privilege\ninterrupt enable and privilege mode stack.",
    "norm:xret_in_lower_mode": "Attempting to execute an xRET\ninstruction in a mode less privileged than x will raise an\nillegal-instruction exception.",
    "norm:xret_op": "In addition to manipulating the privilege stack as described in &lt;&lt;privstack&gt;&gt;,\nxRET sets the pc to the value stored in the xepc register.",
    "norm:xret_clr_lr_resv": "If the A extension is supported, the xRET instruction is allowed to\nclear any outstanding LR address reservation but is not required to.",
    "norm:wfi_op": "The Wait for Interrupt instruction (WFI) informs the\nimplementation that the current hart can be stalled until an interrupt\nmight need servicing. Execution of the WFI instruction can also be used\nto inform the hardware platform that suitable interrupts should\npreferentially be routed to this hart.",
    "norm:wfi_all_privileged_modes": "WFI is available in all privileged modes",
    "norm:wfi_opt_U_mode": "optionally available to U-mode.",
    "norm:wfi_ill_exc": "This instruction may raise an illegal-instruction exception when TW=1 in mstatus, as\ndescribed in &lt;&lt;virt-control&gt;&gt;.",
    "norm:wfi_enc_img": "",
    "norm:wfi_mepc_val": "If an enabled interrupt is present or later becomes present while the\nhart is stalled, the interrupt trap will be taken on the following\ninstruction, i.e., execution resumes in the trap handler and mepc = pc + 4.",
    "norm:wfi_resume_reason": "Implementations are permitted to resume execution for any reason, even if an\nenabled interrupt has not become pending.\nHence, a legal implementation is to simply implement the WFI instruction as a NOP.",
    "norm:wfi_intr_dis": "The WFI instruction can also be executed when interrupts are disabled.",
    "norm:wfi_unaffected_conditions": "The operation of WFI must be unaffected by the global interrupt bits in\nmstatus (MIE and SIE) and the delegation register mideleg (i.e.,\nthe hart must resume if a locally enabled interrupt becomes pending,\neven if it has been delegated to a less-privileged mode), but should\nhonor the individual interrupt enables (e.g, MTIE) (i.e.,\nimplementations should avoid resuming the hart if the interrupt is\npending but not individually enabled). WFI is also required to resume\nexecution for locally enabled interrupts pending at any privilege level,\nregardless of the global interrupt enable at each privilege level.",
    "norm:wfi_no_intr_pc": "If the event that causes the hart to resume execution\ndoes not cause an interrupt to be taken, execution will resume at pc + 4",
    "norm:M-mode_at_rst2": "Upon reset, a hart’s privilege mode is set to M.",
    "norm:mstatus_mie_mprv_rst": "The mstatus fields MIE and MPRV are reset to 0.",
    "norm:mstatus_mstatush_mbe_rst": "If little-endian memory accesses are supported, the mstatus/mstatush field MBE is reset to 0.",
    "norm:misa_extensions_rst2": "The misa register is reset to enable the maximal set of supported\nextensions, as described in &lt;&lt;misa&gt;&gt;.",
    "norm:ld_rsv_rst": "For implementations with the \"A\" standard extension, there is no valid\nload reservation.",
    "norm:pc_rst": "The pc is set to an implementation-defined reset vector.",
    "norm:mcause_rst1_val": "The mcause register is set to a value indicating the cause of the reset.",
    "norm:pmp_A_L_rst": "Writable PMP registers’ A and L fields are set to 0, unless\nthe platform mandates a different reset value for some PMP registers’ A\nand L fields.",
    "norm:hgatp_vsatp_mode_rst": "If the hypervisor extension is implemented, the\nhgatp.MODE and vsatp.MODE fields are reset to 0.",
    "norm:mnstatus_nmie_rst": "If the Smrnmi extension is implemented, the mnstatus.NMIE field is reset to 0.",
    "norm:warl_rst": "No WARL field contains an illegal value.",
    "norm:mseccfg_mlpe_rst": "If the Zicfilp extension is implemented, the mseccfg.MLPE field is reset to 0.",
    "norm:mseccfg_mml_mmwp_rlb_rst": "The MML, MMWP, and RLB fields of the mseccfg register\nare set to 0, unless the platform mandates a different reset value.",
    "norm:mcause_rst2_val": "The mcause values after reset have implementation-specific\ninterpretation",
    "norm:mcause_rst_zero": "the value 0 should be returned on implementations\nthat do not distinguish different reset conditions. Implementations that\ndistinguish different reset conditions should only use 0 to indicate the\nmost complete reset.",
    "norm:mseccfg_useed_sseed_rst": "The USEED and SSEED fields of the mseccfg CSR\nmust have defined reset values. The system must not allow them to be in an undefined state\nafter reset.",
    "norm:mcause_rst_alias_ok": "mcause reset values may alias mcause values\nfollowing synchronous exceptions",
    "norm:nmi_op": "cause an immediate jump to an implementation-defined NMI\nvector running in M-mode regardless of the state of a hart’s interrupt\nenable bits. The mepc register is written with the virtual address of\nthe instruction that was interrupted,",
    "norm:nmi_mcause_val1": "mcause is set to a value\nindicating the source of the NMI.",
    "norm:nmi_mcause_val2": "The values written to mcause on an NMI are implementation-defined.",
    "norm:nmi_mcause_restrictions": "The high Interrupt bit of mcause should be set to indicate\nthat this was an interrupt. An Exception Code of 0 is reserved to mean \"unknown\ncause\" and implementations that do not distinguish sources of NMIs via\nthe mcause register should return 0 in the Exception Code.",
    "norm:nmi_no_rst": "NMIs do not reset processor state",
    "norm:pma_indep_exec_context": "PMAs do not vary by execution\ncontext.",
    "norm:pma_rtcfg_mmr": "Where the attributes are run-time configurable,\nplatform-specific memory-mapped control\nregisters can be provided",
    "norm:pma_chk_paddr": "PMAs are checked for any access to physical memory, including accesses\nthat have undergone virtual to physical memory translation.",
    "norm:pma_precise_recom": "we strongly recommend that, where possible, RISC-V\nprocessors precisely trap physical memory accesses that fail PMA checks.\nPrecisely trapped PMA violations manifest as instruction, load, or store\naccess-fault exceptions, distinct from virtual-memory page-fault exceptions.",
    "norm:pma_imprecise_ok": "Precise PMA traps might not always be possible, for example,\nwhen probing a legacy bus architecture that uses access failures as part\nof the discovery mechanism. In this case, error responses from\nperipheral devices will be reported as imprecise bus-error interrupts.",
    "norm:pma_mm_vs_io_def": "The most important characterization of a given memory address range is whether it holds regular main memory or I/O devices. Regular main memory is required to have a number of properties, specified below, whereas I/O devices can have a much broader range of attributes. Memory regions that do not fit into regular main memory, for example, device scratchpad RAMs, are categorized as I/O regions.",
    "norm:pma_mm_rw": "Main memory regions always support read and write of all access widths\nrequired by the attached devices",
    "norm:pma_mm_ifetch": "can specify whether instruction fetch is supported.",
    "norm:pma_mm_mandatory_sz": "the design of a processor or device accessing main memory\nmight support other widths, but must be able to function with the types\nsupported by the main memory.",
    "norm:pma_io_rwx_per_sz": "I/O regions can specify which combinations of read, write, or execute\naccesses to which data widths are supported.",
    "norm:pma_vm_hw_tbl_acc": "For systems with page-based virtual memory, I/O and memory regions can\nspecify which combinations of hardware page-table reads and hardware\npage-table writes are supported.",
    "norm:pma_cache_mm_all_atomics": "Some platforms might mandate that all of cacheable main memory support\nall atomic operations",
    "norm:pma_amo_levels": "Within AMOs, there are four levels of support: AMONone, AMOSwap,\nAMOLogical, and AMOArithmetic. AMONone indicates that no AMO\noperations are supported. AMOSwap indicates that only amoswap\ninstructions are supported in this address range. AMOLogical indicates\nthat swap instructions plus all the logical AMOs (amoand, amoor,\namoxor) are supported. AMOArithmetic indicates that all RISC-V AMOs defined by\nthe A extension are supported.",
    "norm:pma_amo_sz_support": "For each level of support, naturally aligned AMOs of a given width\nare supported if the underlying memory region supports reads and writes of that width.",
    "norm:pma_amo_far_subset_proc": "Main memory and I/O regions may only support a subset or none of the processor-supported atomic operations.",
    "norm:pma_amo_zacas_levels1": "The Zacas extension defines three additional levels of support: AMOCASW,\nAMOCASD, and AMOCASQ.",
    "norm:pma_amo_zacas_levels2": "AMOCASW indicates that in addition to instructions indicated by AMOArithmetic\nlevel support, the AMOCAS.W instruction is supported. AMOCASD indicates that\nin addition to instructions indicated by AMOCASW level support, the AMOCAS.D\ninstruction is supported. AMOCASQ indicates that in addition to instructions\nindicated by AMOCASD level support, the AMOCAS.Q instruction is supported.",
    "norm:pma_amo_zacas_req_arith": "AMOCASW/D/Q require AMOArithmetic level support as the AMOCAS.W/D/Q\ninstructions require ability to perform an arithmetic comparison and a swap operation.",
    "norm:pma_amo_zabha_req": "The AMOs specified by the Zabha extension require the same level of support as\nthe corresponding instructions in the A standard extension or the Zacas extension.",
    "norm:pma_rsrv_levels": "For LR/SC, there are three levels of support indicating combinations\nof the reservability and eventuality properties: RsrvNone,\nRsrvNonEventual, and RsrvEventual. RsrvNone indicates that no LR/SC\noperations are supported (the location is non-reservable).\nRsrvNonEventual indicates that the operations are supported (the\nlocation is reservable), but without the eventual success guarantee\ndescribed in the unprivileged ISA specification. RsrvEventual indicates\nthat the operations are supported and provide the eventual success guarantee.",
    "norm:pma_mag_def": "The misaligned atomicity granule PMA provides constrained support for misaligned AMOs. This PMA, if present, specifies the size of a misaligned atomicity granule, a naturally aligned power-of-two number of bytes. Specific supported values for this PMA are represented by MAGNN, e.g., MAG16 indicates the misaligned atomicity granule is at least 16 bytes.",
    "norm:pma_mag_insts": "The misaligned atomicity granule PMA applies only to AMOs, loads and stores\ndefined in the base ISAs, and loads and stores of no more than XLEN bits\ndefined in the F, D, and Q extensions, and compressed encodings thereof.",
    "norm:pma_mag_op_within": "if all accessed bytes lie within the same\nmisaligned atomicity granule, the instruction will not raise an exception for\nreasons of address alignment, and the instruction will give rise to only one\nmemory operation for the purposes of RVWMO--i.e., it will execute atomically.",
    "norm:pma_mag_op_amo": "If a misaligned AMO accesses a region that does not specify a misaligned\natomicity granule PMA, or if not all accessed bytes lie within the same\nmisaligned atomicity granule, then an exception is raised.",
    "norm:pma_mag_op_ldst": "For regular loads and stores that access such a region or for which not all\naccessed bytes lie within the same atomicity granule, then either an exception\nis raised, or the access proceeds but is not guaranteed to be atomic.",
    "norm:pma_mag_exc": "Implementations may raise access-fault exceptions instead of\naddress-misaligned exceptions for some misaligned accesses, indicating the\ninstruction should not be emulated by a trap handler.",
    "norm:pma_mag_op_rsrv": "LR/SC instructions are unaffected by this PMA and so always raise an\nexception when misaligned.",
    "norm:pma_mag_op_vec": "Vector memory accesses are also unaffected, so might execute non-atomically even\nwhen contained within a misaligned atomicity granule.",
    "norm:pma_mag_op_implicit": "Implicit accesses are similarly unaffected by this PMA.",
    "norm:pma_mo_io_chan_def": "Each strongly ordered I/O region specifies a numbered ordering channel,\nwhich is a mechanism by which ordering guarantees can be provided\nbetween different I/O regions.",
    "norm:pma_mo_io_chan_0": "Channel 0 is used to indicate\npoint-to-point strong ordering only, where only accesses by the hart to\nthe single associated I/O region are strongly ordered.",
    "norm:pma_mo_io_chan_1": "Channel 1 is used to provide global strong ordering across all I/O regions. Any accesses by a hart to any I/O region associated with channel 1 can only be observed to have occurred in program order by all other harts and I/O devices, including relative to accesses made by that hart to relaxed I/O regions or strongly ordered I/O regions with different channel numbers. In other words, any access to a region in channel 1 is equivalent to executing a fence io,io instruction before and after the instruction.",
    "norm:pma_mo_io_chan_other": "Other larger channel numbers provide program ordering to accesses by that hart across any regions with the same channel number",
    "norm:pma_mo_dyn": "Systems might support dynamic configuration of ordering properties on each memory region.",
    "norm:pma_non_cacheable": "If a PMA indicates non-cacheability, then accesses to that region must\nbe satisfied by the memory itself, not by any caches.",
    "norm:uncached_ignores_cached": "For implementations with a cacheability-control mechanism, the situation\nmay arise that a program uncacheably accesses a memory location that is\ncurrently cache-resident. In this situation, the cached copy must be\nignored. This constraint is necessary to prevent more-privileged modes’\nspeculative cache refills from affecting the behavior of less-privileged\nmodes’ uncacheable accesses.",
    "norm:pma_idp_mm": "Main memory regions are assumed to be idempotent.",
    "norm:pma_idp_no_spec": "hardware should always be designed to avoid speculative or\nredundant accesses to memory regions marked as non-idempotent",
    "norm:pma_idp_misaligned_exc": "Non-idempotent regions might not support misaligned accesses. Misaligned\naccesses to such regions should raise access-fault exceptions rather\nthan address-misaligned exceptions",
    "norm:pma_idp_implicit_ok": "For non-idempotent regions, implicit reads and writes must not be\nperformed early or speculatively, with the following exceptions. When a\nnon-speculative implicit read is performed, an implementation is\npermitted to additionally read any of the bytes within a naturally\naligned power-of-2 region containing the address of the non-speculative\nimplicit read. Furthermore, when a non-speculative instruction fetch is\nperformed, an implementation is permitted to additionally read any of\nthe bytes within the next naturally aligned power-of-2 region of the\nsame size (with the address of the region taken modulo 2^XLEN^).",
    "norm:pma_idp_implicit_sz": "The size of these naturally aligned power-of-2 regions is\nimplementation-defined, but, for systems with page-based virtual memory,\nmust not exceed the smallest supported page size.",
    "norm:pmp_granularity": "The granularity of PMP access control settings are platform-specific,\nbut the standard PMP encoding supports regions as small as four bytes.",
    "norm:pmp_mmode_only_regions": "Certain regions’ privileges can be hardwired—for example, some regions\nmight only ever be visible in machine mode but in no lower-privilege\nlayers.",
    "norm:pmp_check_priv_modes": "PMP checks are applied to all accesses whose effective privilege mode is\nS or U, including instruction fetches and data accesses in S and U mode,\nand data accesses in M-mode when the MPRV bit in mstatus is set and\nthe MPP field in mstatus contains S or U.",
    "norm:pmp_check_pagetable_access": "PMP checks are also applied\nto page-table accesses for virtual-address translation, for which the\neffective privilege mode is S.",
    "norm:pmp_mmode_locking": "Optionally, PMP checks may additionally\napply to M-mode accesses, in which case the PMP registers themselves are\nlocked, so that even M-mode software cannot change them until the hart\nis reset.",
    "norm:pmp_violation_precise_trap": "PMP violations are always trapped precisely at the processor.",
    "norm:pmp_entry_structure": "PMP entries are described by an 8-bit configuration register and one\nMXLEN-bit address register. Some PMP settings additionally use the\naddress register associated with the preceding PMP entry.",
    "norm:pmp_entry_count": "Up to 64 PMP\nentries are supported. Implementations may implement zero, 16, or 64 PMP\nentries; the lowest-numbered PMP entries must be implemented first.",
    "norm:pmp_csrs_warl_access": "All\nPMP CSR fields are WARL and may be read-only zero.",
    "norm:pmp_csr_mode": "PMP CSRs are only\naccessible to M-mode.",
    "norm:pmp_cfg_rv32_layout": "For RV32, sixteen CSRs, pmpcfg0–pmpcfg15, hold\nthe configurations pmp0cfg–pmp63cfg for the 64 PMP entries, as shown\nin &lt;&lt;pmpcfg-rv32&gt;&gt;.",
    "norm:pmp_cfg_rv64_layout": "For RV64, eight\neven-numbered CSRs, pmpcfg0, pmpcfg2, …, pmpcfg14, hold the\nconfigurations for the 64 PMP entries, as shown in\n&lt;&lt;pmpcfg-rv64&gt;&gt;.",
    "norm:pmp_cfg_rv64_illegal": "For RV64, the odd-numbered\nconfiguration registers, pmpcfg1, pmpcfg3, …, pmpcfg15, are\nillegal.",
    "norm:pmp_addr_registers": "The PMP address registers are CSRs named pmpaddr0-pmpaddr63.",
    "norm:pmp_addr_encoding": "Each\nPMP address register encodes bits 33-2 of a 34-bit physical address for\nRV32, as shown in &lt;&lt;pmpaddr-rv32&gt;&gt;. For RV64,\neach PMP address register encodes bits 55-2 of a 56-bit physical\naddress, as shown in &lt;&lt;pmpaddr-rv64&gt;&gt;.",
    "norm:pmp_addr_warl": "Not all\nphysical address bits may be implemented, and so the pmpaddr registers\nare WARL.",
    "norm:pmp_cfg_permissions": "&lt;&lt;pmpcfg&gt;&gt; shows the layout of a PMP configuration\nregister. The R, W, and X bits, when set, indicate that the PMP entry\npermits read, write, and instruction execution, respectively. When one\nof these bits is clear, the corresponding access type is denied.",
    "norm:pmp_rwx_warl": "The R,\nW, and X fields form a collective WARL field for which the combinations with R=0 and W=1 are reserved.",
    "norm:pmp_exec_fault": "Attempting to fetch an instruction from a PMP region that does not have\nexecute permissions raises an instruction access-fault exception.",
    "norm:pmp_load_fault": "Attempting to execute a load, load-reserved, or cache-block management instruction which accesses\na physical address within a PMP region without read permissions raises a\nload access-fault exception.",
    "norm:pmp_store_fault": "Attempting to execute a store,\nstore-conditional, AMO, or cache-block zero instruction which accesses a physical address\nwithin a PMP region without write permissions raises a store\naccess-fault exception.",
    "norm:pmp_a_field_encoding": "The A field in a PMP entry's configuration register encodes the\naddress-matching mode of the associated PMP address register. The\nencoding of this field is shown in &lt;&lt;pmpcfg-a&gt;&gt;.",
    "norm:pmp_a_field_off": "When A=0, this PMP entry is disabled and matches no addresses.",
    "norm:pmp_a_field_napot_na4": "naturally aligned power-of-2\nregions (NAPOT), including the special case of naturally aligned\nfour-byte regions (NA4);",
    "norm:pmp_napot_encoding_low_bits": "NAPOT ranges make use of the low-order bits of the associated address\nregister to encode the size of the range, as shown in\n&lt;&lt;pmpcfg-napot&gt;&gt;.",
    "norm:pmp_a_field_tor": "If TOR is selected, the associated address register forms the top of the\naddress range, and the preceding PMP address register forms the bottom\nof the address range. If PMP entry i's A field is set to\nTOR, the entry matches any address y such that pmpaddr~i-1~{le}y&lt;pmpaddr~i~ (irrespective of the value of pmpcfg~i-1~). If PMP entry 0's A field is set to TOR, zero is used for the lower bound, and so it matches\nany address y&lt;pmpaddr~0~.",
    "norm:pmp_region_granularity_g": "Although the PMP mechanism supports regions as small as four bytes,\nplatforms may specify coarser PMP regions. In general, the PMP grain is\n2^G+2^ bytes and must be the same across all PMP regions.",
    "norm:pmp_na4_select_restriction": "When G {ge} 1, the NA4 mode is not selectable.",
    "norm:pmp_napot_addr_read_mask": "When\nG {ge} 2 and pmpcfg~i~.A[1] is set,\ni.e. the mode is NAPOT, then bits pmpaddr~i~[G-2:0]\nread as all ones.",
    "norm:pmp_tor_off_addr_read_mask": "When G {ge} 1 and\npmpcfg~i~.A[1] is clear, i.e. the mode is OFF or TOR,\nthen bits pmpaddr~i~[G-1:0] read as all zeros. Bits\npmpaddr~i~[G-1:0] do not affect the TOR address-matching logic.",
    "norm:pmp_addr_retention_on_mode_change": "Although changing pmpcfg~i~.A[1] affects the value\nread from pmpaddr~i~, it does not affect the\nunderlying value stored in that register—in particular,\npmpaddr~i~[G-1] retains its original value when\npmpcfg~i~.A is changed from NAPOT to TOR/OFF then\nback to NAPOT.",
    "norm:pmp_l_bit_function": "The L bit indicates that the PMP entry is locked, i.e., writes to the\nconfiguration register and associated address registers are ignored.",
    "norm:pmp_l_bit_write_protection": "If PMP entry\ni is locked, writes to pmpicfg and pmpaddri are ignored. Additionally, if PMP\nentry i is locked and pmpicfg.A is set\nto TOR, writes to pmpaddri-1 are ignored.",
    "norm:pmp_l_bit_m_mode_enforcement": "In addition to locking the PMP entry, the L bit indicates whether the\nR/W/X permissions are additionally enforced on M-mode accesses.\nWhen the L bit is\nset, these permissions are enforced for all privilege modes. When the L\nbit is clear, any M-mode access matching the PMP entry will succeed; the\nR/W/X permissions apply only to S and U modes.",
    "norm:pmp_misaligned_access_behavior": "On some implementations, misaligned loads, stores, and instruction\nfetches may be decomposed into multiple memory operations, some of which may\nsucceed before an access-fault exception occurs, as described in the RVWMO\nspecification. PMP checking is performed on each memory operation independently.",
    "norm:pmp_entry_priority": "PMP entries are statically prioritized. The lowest-numbered PMP entry\nthat matches any byte of a memory operation determines whether that operation\nsucceeds or fails.",
    "norm:pmp_full_match_required": "The matching PMP entry must match all bytes of a memory\noperation, or the operation fails, irrespective of the L, R, W, and X bits.",
    "norm:pmp_rwx_check": "If a PMP entry matches all bytes of a memory operation, then the L, R, W, and X\nbits determine whether the operation succeeds or fails. If the L bit is\nclear and the privilege mode of the access is M, the operation succeeds.\nOtherwise, if the L bit is set or the privilege mode of the access is S\nor U, then the operation succeeds only if the R, W, or X bit corresponding\nto the access type is set.",
    "norm:pmp_no_entry_match": "If no PMP entry matches an M-mode memory operation, the operation succeeds.\nIf no PMP entry matches an S-mode or U-mode memory operation, but at least\none PMP entry is implemented, the operation fails.",
    "norm:pmp_access_fault_exception": "Failed memory operations generate an instruction, load, or store access-fault\nexception.",
    "norm:pmp_with_paging": "When paging is enabled,\ninstructions that access virtual memory may result in multiple\nphysical-memory accesses, including implicit references to the page\ntables. The PMP checks apply to all of these accesses.",
    "norm:pmp_speculative_translations": "Implementations with virtual memory are permitted to perform address\ntranslations speculatively and earlier than required by an explicit\nmemory access, and are permitted to cache them in address translation\ncache structures—including possibly caching the identity mappings from\neffective address to physical address used in Bare translation modes and\nM-mode. The PMP settings for the resulting physical address may be\nchecked (and possibly cached) at any point between the address\ntranslation and the explicit memory access.",
    "norm:pmp_sfence_required": "when the PMP settings\nare modified, M-mode software must synchronize the PMP settings with the\nvirtual memory system and any PMP or address-translation caches. This is\naccomplished by executing an SFENCE.VMA instruction with rs1=x0 and\nrs2=x0, after the PMP CSRs are written.",
    "norm:smstateen_mmode_rv64_csrs": "For RV64 harts, this extension adds four new 64-bit CSRs at machine level: mstateen0 (Machine State Enable 0), mstateen1, mstateen2, and mstateen3.",
    "norm:smstateen_smode_rv64_csrs": "If supervisor mode is implemented, another four CSRs are defined at supervisor level: sstateen0, sstateen1, sstateen2, and sstateen3.",
    "norm:smstateen_hypervisor_rv64_csrs": "And if the hypervisor extension is implemented, another set of CSRs is added: hstateen0, hstateen1, hstateen2, and hstateen3.",
    "norm:smstateen_rv32_upper_bits_csrs": "For RV32, there are CSR addresses for accessing the upper 32 bits of corresponding machine-level and hypervisor CSRs: mstateen0h, mstateen1h, mstateen2h, mstateen3h, hstateen0h, hstateen1h, hstateen2h, and hstateen3h.",
    "norm:stateen_op": "The stateen registers at each level control access to state at all\nless-privileged levels, but not at its own level.",
    "norm:smstateen_illegal_state_access": "Just\nas with the counteren CSRs, when a stateen CSR prevents access to state by\nless-privileged levels, an attempt in one of those privilege modes to execute\nan instruction that would read or write the protected state raises an illegal-instruction\nexception, or, if executing in VS or VU mode and the circumstances\nfor a virtual-instruction  exception apply, raises a virtual-instruction\nexception instead of an illegal-instruction exception.",
    "norm:smstateen_implicit_state_update": "When a stateen CSR prevents access to state for a privilege mode, attempting to execute in that privilege mode an instruction that implicitly updates the state without reading it may or may not raise an illegal-instruction or virtual-instruction exception. Such cases must be disambiguated by being explicitly specified one way or the other.",
    "norm:sstateen_user_access_control": "Each bit of a supervisor-level sstateen CSR controls user-level access (from\nU-mode or VU-mode) to an extension's state.",
    "norm:sstateen_bit_allocation": "The intention is to allocate the\nbits of sstateen CSRs starting at the least-significant end, bit 0, through to\nbit 31, and then on to the next-higher-numbered sstateen CSR.",
    "norm:sstateen_bit_correspondence": "For every bit with a defined purpose in an sstateen CSR, the same bit is\ndefined in the matching mstateen CSR to control access below machine level to\nthe same state.",
    "norm:mstateen_bit_allocation": "The intention is to allocate bits\nfor this purpose starting at the most-significant end, bit 63, through to bit\n32, and then on to the next-higher mstateen CSR.",
    "norm:mstateen_bit_encroachment": "If the rate that bits are\nbeing allocated from the least-significant end for sstateen CSRs is\nsufficiently low, allocation from the most-significant end of mstateen CSRs may\nbe allowed to encroach on the lower 32 bits before jumping to the next-higher\nmstateen CSR.",
    "norm:sstateen_encroachment_bits_roz": "In that case, the bit positions of \"encroaching\" bits will remain\nforever read-only zeros in the matching sstateen CSRs.",
    "norm:hstateen_encoding": "With the hypervisor extension, the hstateen CSRs have identical encodings to the mstateen CSRs, except controlling accesses for a virtual machine (from VS and VU modes).",
    "norm:stateen_warl_access": "Each standard-defined bit of a stateen CSR is WARL and may be read-only zero or one, subject to the following conditions.",
    "norm:stateen_unimplemented_state_roz": "Bits in any stateen CSR that are defined to control state that a hart doesn't\nimplement are read-only zeros for that hart.",
    "norm:stateen-reserved_roz": "Likewise, all reserved bits not\nyet given a defined meaning are also read-only zeros.",
    "norm:sstateen_vsmode_access_roz": "For every\nbit in an hstateen CSR that is zero (whether read-only zero or set to zero),\nthe same bit appears as read-only zero in sstateen when accessed in VS-mode.",
    "norm:sstateen_ro1_bits": "A bit in a supervisor-level sstateen CSR cannot be read-only one unless the\nsame bit is read-only one in the matching mstateen CSR and, if it exists, in\nthe matching hstateen CSR.",
    "norm:hstateen_ro1_bits": "A bit in an hstateen CSR cannot be read-only one\nunless the same bit is read-only one in the matching mstateen CSR.",
    "norm:mstateen_zero_initialization": "On reset, all writable mstateen bits are initialized by the hardware to zeros.",
    "norm:hstateen_sstateen_zero_initialization": "If machine-level software changes these values, it is responsible for\ninitializing the corresponding writable bits of the hstateen and sstateen CSRs\nto zeros too.",
    "norm:mstateen-bit-63_op": "For each mstateen CSR, bit 63 is defined to control access to the\nmatching sstateen and hstateen CSRs.",
    "norm:hstateen-bit-63_op": "Likewise, bit 63 of each hstateen\ncorrespondingly controls access to the matching sstateen CSR.",
    "norm:mstateen-bit-63_roz": "Bit 63 of each mstateen CSR may be read-only zero only if the hypervisor\nextension is not implemented and the matching supervisor-level sstateen CSR is\nall read-only zeros.",
    "norm:hstateen-bit-63_writable": "Bit 63 of each hstateen CSR is always writable (not\nread-only).",
    "norm:stateen0-c_op": "The C bit controls access to any and all custom state.",
    "norm:stateen0-fcsr_op": "The FCSR bit controls access to fcsr for the case when floating-point\ninstructions operate on x registers instead of f registers as specified by\nthe Zfinx and related extensions (Zdinx, etc.).",
    "norm:stateen0-fcsr0_misa-f0_illegal_fpu_instr": "For convenience, when the stateen CSRs are implemented and\nmisa.F = 0, then if the FCSR bit of a controlling stateen0 CSR is zero, all\nfloating-point instructions cause an illegal-instruction exception (or virtual-instruction\nexception, if relevant), as though they all access fcsr, regardless of\nwhether they really do.",
    "norm:stateen0-jvt_op": "The JVT bit controls access to the jvt CSR provided by the Zcmt extension.",
    "norm:mstateen0-se0_op": "The SE0 bit in mstateen0 controls access to the hstateen0, hstateen0h,\nand the sstateen0 CSRs.",
    "norm:hstateen0-SE0_op": "The SE0 bit in hstateen0 controls access to the\nsstateen0 CSR.",
    "norm:mstateen0-envcfg_op": "The ENVCFG bit in mstateen0 controls access to the henvcfg, henvcfgh,\nand the senvcfg CSRs.",
    "norm:hstateen0-envcfg_op": "The ENVCFG bit in hstateen0 controls access to the\nsenvcfg CSRs.",
    "norm:mstateen0-csrind_op": "The CSRIND bit in mstateen0 controls access to the siselect, sireg*,\nvsiselect, and the vsireg* CSRs provided by the Sscsrind extensions.",
    "norm:hstateen0-csrind_op": "The CSRIND bit in hstateen0 controls access to the siselect and the\nsireg*, (really vsiselect and vsireg*) CSRs provided by the Sscsrind\nextensions.",
    "norm:mstateen0-imsic_op": "The IMSIC bit in mstateen0 controls access to the IMSIC state, including\nCSRs stopei and vstopei, provided by the Ssaia extension.",
    "norm:hstateen0-imsic_op": "The IMSIC bit in\nhstateen0 controls access to the guest IMSIC state, including CSRs stopei\n(really vstopei), provided by the Ssaia extension.",
    "norm:mstateen0-aia_op": "The AIA bit in mstateen0 controls access to all state introduced by the\nSsaia extension and not controlled by either the CSRIND or the IMSIC\nbits.",
    "norm:hstateen0-aia_op": "The AIA bit in hstateen0 controls access to all state introduced by the\nSsaia extension and not controlled by either the CSRIND or the IMSIC\nbits of hstateen0.",
    "norm:mstateen0-context_op": "The CONTEXT bit in mstateen0 controls access to the scontext and\nhcontext CSRs provided by the Sdtrig extension.",
    "norm:hstateen0-context_op": "The CONTEXT bit in\nhstateen0 controls access to the scontext CSR provided by the Sdtrig\nextension.",
    "norm:mstateen0-p1p13_op": "The P1P13 bit in mstateen0 controls access to the hedelegh introduced by Privileged Specification Version 1.13.",
    "norm:mstateen0-srmcfg_op": "The SRMCFG bit in mstateen0 controls access to the srmcfg CSR introduced by the Ssqosid  extension.",
    "norm:csr_access": "A CSR\naccessible via one method may or may not be accessible via the other\nmethod.",
    "norm:select_value_separate_address_space": "Select values are a separate address space from CSR numbers, and\nfrom tselect values in the Sdtrig extension.",
    "norm:select_value_unrelated": "If a CSR is both directly\nand indirectly accessible, the CSR's select value is unrelated to its\nCSR number.",
    "norm:csrs_alias": "Machine-level and\nSupervisor-level CSRs with the same select value may be defined by an\nextension as partial or full aliases with respect to each other.",
    "norm:miph_csr_number": "The mireg* CSR numbers are not consecutive because miph is CSR number 0x354.",
    "norm:miselect_op": "The value of miselect determines which\nregister is accessed upon read or write of each of the machine indirect alias\nCSRs (mireg*).",
    "norm:miselect_value_range": "miselect value ranges are allocated to dependent\nextensions, which specify the register state accessible via each\nmiregi register, for each miselect value.",
    "norm:miselect_WARL": "miselect is a WARL\nregister.",
    "norm:miselect_min_sz": "The miselect register implements at least enough bits to support all\nimplemented miselect values (corresponding to the implemented extensions\nthat utilize miselect/mireg* to indirectly access register state).",
    "norm:miselect-msb_op": "Values of miselect with the most-significant bit set (bit XLEN - 1 = 1) are designated only for custom use, presumably for accessing custom registers through the alias CSRs. Values of miselect with the most-significant bit clear are designated only for standard use and are reserved until allocated to a standard architecture extension. If XLEN is changed, the most-significant bit of miselect moves to the new position, retaining its value from before.",
    "norm:mireg_access_on_legal_miselect": "Attempts to access mireg* while miselect holds a number in an allocated and implemented range results in a specific behavior that, for each combination of miselect and miregi, is defined by the extension to which the miselect value is allocated.",
    "norm:mireg_access_behaviour": "Ordinarily, each `mireg`i will access register state, access read-only 0 state, or raise an illegal-instruction exception.",
    "norm:siselect_min_range": "The siselect register will support the value range 0..0xFFF at a\nminimum.",
    "norm:siselect-msb_op": "Values of siselect with the most-significant bit set (bit XLEN - 1 = 1) are designated only for custom use, presumably for accessing custom registers through the alias CSRs. Values of siselect with the most-significant bit clear are designated only for standard use and are reserved until allocated to a standard architecture extension. If XLEN is changed, the most-significant bit of siselect moves to the new position, retaining its value from before.",
    "norm:sireg_access_on_illegal_siselect": "The behavior upon accessing sireg* from M-mode or S-mode, while siselect holds a value that is not implemented at supervisor level, is UNSPECIFIED.",
    "norm:sireg_access_on_legal_siselect": "Otherwise, attempts to access sireg* from M-mode or S-mode while siselect holds a number in a standard-defined and implemented range result in specific behavior that, for each combination of siselect and siregi, is defined by the extension to which the siselect value is allocated.",
    "norm:sireg_access_behaviour": "Ordinarily, each `sireg`i will access register state, access read-only 0 state, or, unless executing in a virtual machine (covered in the next section), raise an illegal-instruction exception.",
    "norm:sscsrind_smode_csrs_sz": "Note that the widths of siselect and sireg* are always the current XLEN rather than SXLEN. Hence, for example, if MXLEN = 64 and SXLEN = 32, then these registers are 64 bits when the current privilege mode is M (running RV64 code) but 32 bits when the privilege mode is S (RV32 code).",
    "norm:vsiselect_min_range": "The vsiselect register will support the value range 0..0xFFF at a\nminimum.",
    "norm:vsiselect-msb_op": "Values of vsiselect with the most-significant bit set (bit XLEN - 1 = 1) are designated only for custom use, presumably for accessing custom registers through the alias CSRs. Values of vsiselect with the most-significant bit clear are designated only for standard use and are reserved until allocated to a standard architecture extension. If XLEN is changed, the most-significant bit of vsiselect moves to the new position, retaining its value from before.",
    "norm:sscsrind_virtual_inst_fault": "A virtual-instruction  exception is raised for attempts from VS-mode or VU-mode to directly access vsiselect or vsireg*, or attempts from VU-mode to access siselect or sireg*.",
    "norm:vsireg_access_on_legal_vsiselect": "Otherwise, while vsiselect holds a number in a standard-defined and implemented range, attempts to access vsireg* from a sufficiently privileged mode, or to access sireg* (really vsireg*) from VS-mode, result in specific behavior that, for each combination of vsiselect and vsiregi, is defined by the extension to which the vsiselect value is allocated.",
    "norm:vsireg_access_behaviour": "Ordinarily, each vsireg`i will access register state, access read-only 0 state, or raise an exception (either an illegal-instruction exception or, for select accesses from VS-mode, a virtual-instruction  exception).",
    "norm:vsmode_virtual_inst_fault": "When `vsiselect holds a value that is implemented at HS level but not at VS level, attempts to access sireg* (really vsireg*) from VS-mode will typically raise a virtual-instruction  exception.",
    "norm:sscsrind_vsmode_csrs_sz": "Like siselect and sireg*, the widths of vsiselect and vsireg* are always the current XLEN rather than VSXLEN. Hence, for example, if HSXLEN = 64 and VSXLEN = 32, then these registers are 64 bits when accessed by a hypervisor in HS-mode (running RV64 code) but 32 bits for a guest OS in VS-mode (RV32 code).",
    "norm:sscsrind_csrs_access_control": "If extension Smstateen is implemented together with Smcsrind, bit 60 of\nstate-enable register mstateen0 controls access to siselect, sireg*,\nvsiselect, and vsireg*. When mstateen0[60]=0, an attempt to access one\nof these CSRs from a privilege mode less privileged than M-mode results\nin an illegal-instruction exception.",
    "norm:hypervisor_impl_csrs_access_control": "If the hypervisor extension is implemented, the same bit is defined also in hypervisor CSR hstateen0, but controls access to only siselect and sireg* (really vsiselect and vsireg*), which is the state potentially accessible to a virtual machine executing in VS or VU-mode. When hstateen0[60]=0 and mstateen0[60]=1, all attempts from VS or VU-mode to access siselect or sireg* raise a virtual-instruction  exception, not an illegal-instruction exception, regardless of the value of vsiselect or any other mstateen bit.",
    "norm:smepmp_no_mml_limit": "Without the Smepmp extension, it is not possible for a PMP rule to be enforced only on non-Machine modes and denied on Machine mode, in order to allow access to a memory region solely by less-privileged modes.",
    "norm:smepmp_no_mml_behavior": "It is only possible to have a locked rule that will be enforced on all modes, or a rule that will be enforced on non-Machine modes and be ignored by Machine mode.",
    "norm:smepmp_machine_unlimited": "So for any physical memory region which is not protected with a Locked rule, Machine mode has unlimited access, including the ability to execute it.",
    "norm:smepmp_attack_surface": "Without being able to protect less-privileged modes from Machine mode, it is not possible to prevent the mentioned attack vector.",
    "norm:mseccfg_fields_exist": "this\nextension introduces the RLB, MMWP, and MML fields in the mseccfg CSR\nand their associated rules.",
    "norm:mml_truth_table": "The physical memory protection rules when mseccfg.MML is set to 1 are summarized in the truth table below.",
    "norm:mseccfg_locking": "Since all fields defined in mseccfg as part of this extension are locked when set (MMWP/MML) or locked when cleared (RLB), software can't poll them for determining the presence of Smepmp.",
    "norm:bootrom_discovery": "It is expected that BootROM will set mseccfg.MMWP and/or mseccfg.MML during early boot, before jumping to the firmware, so that the firmware will be able to determine the presence of Smepmp by reading mseccfg and checking the state of mseccfg.MMWP and mseccfg.MML.",
    "norm:mcyclecfg_sz": "mcyclecfg and minstretcfg are 64-bit registers",
    "norm:mcyclecfg_op": "configure privilege mode filtering for the cycle and instret counters, respectively.",
    "norm:all_xinh_zero": "When all xINH bits are zero, event counting is enabled in all modes.",
    "norm:unimplemented_mode_bits": "For each bit in 61:58, if the associated privilege mode is not implemented, the bit is read-only zero.",
    "norm:rv32_high_access": "For RV32, bits 63:32 of mcyclecfg can be accessed via the mcyclecfgh CSR, and bits 63:32 of minstretcfg can be accessed via the minstretcfgh CSR.",
    "norm:csr_supervisor_access": "The content of these registers may be accessible from Supervisor level if the Smcdeleg/Ssccfg extensions are implemented.",
    "norm:counter_inhibited_behavior": "The fundamental behavior of cycle and instret is modified in that counting does not occur while executing in an inhibited privilege mode.",
    "norm:transition_counting_defined": "Further, the following defines how transitions between a non-inhibited privilege mode and an inhibited privilege mode are counted.",
    "norm:cycle_counting": "The cycle counter will simply count CPU cycles while the CPU is in a non-inhibited privilege mode.",
    "norm:instret_non_inhibited": "instructions that retire in a non-inhibited mode increment instret, and instructions that retire in an inhibited mode do not.",
    "norm:instret_exception": "The former are not considered to retire, and hence do not increment instret.",
    "norm:instret_xret": "The latter do retire, and should increment instret only if the originating privilege mode is not inhibited.",
    "norm:Smrnmi_csrs": "The extension adds four new CSRs (mnepc, mncause,\nmnstatus, and mnscratch) to hold the interrupted state",
    "norm:mnret_exist": "one new\ninstruction, MNRET, to resume from the RNMI handler.",
    "norm:rnmi_priority": "These interrupts\nhave higher priority than any other interrupt or exception on the hart",
    "norm:rnmi_not_disabled": "cannot be disabled by software. Specifically, they are not disabled\nby clearing the mstatus.MIE register.",
    "norm:rnmi_trap_addr": "The RNMI interrupt trap handler address is implementation-defined.",
    "norm:rnmi_exc_trap_addr": "RNMI also has an associated exception trap handler address, which is\nimplementation defined.",
    "norm:mnscratch_sz": "The mnscratch CSR holds an MXLEN-bit",
    "norm:mnscratch_acc": "read-write register",
    "norm:mnscratch_op": "enables\nthe RNMI trap handler to save and restore the context that was\ninterrupted.",
    "norm:mnepc_sz": "The mnepc CSR is an MXLEN-bit",
    "norm:mnepc_acc": "read-write register",
    "norm:mnepc_op": "RNMI trap handler holds the PC of the instruction that took the\ninterrupt.",
    "norm:mnepc_bit0": "The low bit of mnepc (mnepc[0]) is always zero.",
    "norm:mnepc_ialign32": "On implementations\nthat support only IALIGN=32, the two low bits (mnepc[1:0]) are always\nzero.",
    "norm:mnepc_ialign_mask": "If an implementation allows IALIGN to be either 16 or 32 (by changing\nCSR misa, for example), then, whenever IALIGN=32, bit mnepc[1] is\nmasked on reads so that it appears to be 0.",
    "norm:mnepc_bit1_writable": "Though masked, mnepc[1]\nremains writable when IALIGN=32.",
    "norm:mnepc_warl": "mnepc is a WARL register that must be able to hold all valid virtual\naddresses.",
    "norm:mnepc_invalid_convert": "Prior to writing mnepc, implementations may convert an\ninvalid address into some other invalid address that mnepc is capable\nof holding.",
    "norm:mncause_op": "The mncause CSR holds the reason for the RNMI.",
    "norm:mncause_interrupt": "If the reason is an interrupt, bit MXLEN-1 is set to 1,",
    "norm:mncause_interrupt_code": "the RNMI\ncause is encoded in the least-significant bits.",
    "norm:mncause_interrupt_zero": "If the reason is an interrupt and RNMI causes are not supported, bit MXLEN-1 is\nset to 1, and zero is written to the least-significant bits.",
    "norm:mncause_doubletrap": "If the reason is an exception within M-mode that results in a double trap as\nspecified in the Smdbltrp extension, bit MXLEN-1 is set to 0 and the\nleast-significant bits are set to the cause code corresponding to the\nexception that precipitated the double trap.",
    "norm:mnstatus_mnpp_op": "The mnstatus CSR holds a two-bit field, MNPP, which on entry to the\nRNMI trap handler holds the privilege mode of the interrupted context,\nencoded in the same manner as mstatus.MPP.",
    "norm:mnstatus_mnpv_op": "It also holds a one-bit\nfield, MNPV, which on entry to the RNMI trap handler holds the virtualization\nmode of the interrupted context, encoded in the same manner as\nmstatus.MPV.",
    "norm:mnstatus_mnpelp_op": "If the Zicfilp extension is implemented, mnstatus also holds the MNPELP\nfield, which on entry to the RNMI trap handler holds the previous ELP state.",
    "norm:mnstatus_mnpelp_update": "When an RNMI trap is taken, MNPELP is set to ELP and ELP is set to 0.",
    "norm:mnstatus_nmie_enable": "When NMIE=1, non-maskable interrupts\nare enabled.",
    "norm:mnstatus_nmie_disable": "When NMIE=0, all interrupts are disabled.",
    "norm:mnstatus_mprv_clear": "When NMIE=0, the hart behaves as though mstatus.MPRV were clear,\nregardless of the current setting of mstatus.MPRV.",
    "norm:mnstatus_nmie_reset": "Upon reset, NMIE contains the value 0.",
    "norm:mnstatus_nmie_set_clear": "Software can set NMIE to 1, but attempts to clear NMIE have no effect.",
    "norm:mnstatus_wfi": "For the purposes of the WFI instruction, NMIE is a global interrupt\nenable, meaning that the setting of NMIE does not affect the operation\nof the WFI instruction.",
    "norm:mnstatus_reserved": "The other bits in mnstatus are reserved; software should write zeros\nand hardware implementations should return zeros.",
    "norm:mnret_mode": "MNRET is an M-mode-only instruction",
    "norm:mnret_restore": "This instruction also\nsets mnstatus.NMIE.",
    "norm:mnret_mprv": "If MNRET changes the privilege mode to a mode less privileged than M, it also sets mstatus.MPRV to 0.",
    "norm:mnret_zicfilp": "If the Zicfilp extension is implemented, then if the new privileged mode\nis y, MNRET sets ELP to the logical AND of yLPE (see &lt;&lt;FCFIACT&gt;&gt;) and mnstatus.MNPELP.",
    "norm:rnmi_entry": "When an RNMI interrupt is detected, the interrupted PC is written to the\nmnepc CSR,",
    "norm:rnmi_entry_cause": "the type of RNMI to the mncause CSR,",
    "norm:rnmi_entry_priv": "the privilege\nmode of the interrupted context to the mnstatus CSR.",
    "norm:rnmi_entry_nmie_clear": "The\nmnstatus.NMIE bit is cleared, masking all interrupts.",
    "norm:rnmi_enter_mmode": "The hart then enters machine-mode and jumps to the RNMI trap handler\naddress.",
    "norm:rnmi_resume": "The RNMI handler can resume original execution using the new MNRET\ninstruction, which restores the PC from mnepc, the privilege mode from\nmnstatus, and also sets mnstatus.NMIE, which re-enables interrupts.",
    "norm:rnmi_exception_nmie0": "If the hart encounters an exception while executing in M-mode with the mnstatus.NMIE bit clear, the actions taken are the same as if the exception had occurred while mnstatus.NMIE were set, except that the program counter is set to the RNMI exception trap handler address.",
    "norm:smcdeleg_ssccfg_tandem": "For a RISC-V hardware platform, Smcdeleg and Ssccfg must always be implemented in tandem.",
    "norm:smcdeleg_cde_en": "When the Smcdeleg/Ssccfg extensions are enabled (menvcfg.CDE=1), it further allows M-mode to delegate select counters to S-mode.",
    "norm:ssccfg_illegal_sireg_cde0": "* attempts to access any sireg* when menvcfg.CDE = 0;",
    "norm:ssccfg_illegal_sireg3_6": "* attempts to access sireg3 or sireg6;",
    "norm:ssccfg_illegal_sireg4_5_xlen64": "* attempts to access sireg4 or sireg5 when XLEN = 64;",
    "norm:ssccfg_illegal_sireg_not_delegated": "* attempts to access sireg* when siselect = 0x41, or when the counter\nselected by siselect is not delegated to S-mode (the corresponding bit\nin mcounteren = 0).",
    "norm:ssccfg_missing_extension_illegal": "If any extension upon which the underlying state depends is not implemented, an attempt from M or S mode to access the given state through sireg* raises an illegal-instruction exception.",
    "norm:ssccfg_hyp_vs_or_vu_access_vsireg_illegal": "If the hypervisor (H) extension is also implemented, then as specified by extensions Smcsrind/Sscsrind, a virtual-instruction  exception is raised for attempts from VS-mode or VU-mode to directly access vsiselect or vsireg*, or attempts from VU-mode to access siselect or sireg*. Furthermore, while vsiselect holds a value in the range 0x40-0x5F:",
    "norm:ssccfg_hyp_m_s_vsireg_illegal": "* An attempt to access any vsireg* from M or S mode raises an illegal-instruction exception.",
    "norm:ssccfg_hyp_vs_access_sireg_conditional": "* An attempt from VS-mode to access any sireg* (really vsireg*) raises an illegal-instruction exception if menvcfg.CDE = 0, or a virtual-instruction exception if menvcfg.CDE = 1.",
    "norm:ssccfg_scountinhibit_exists": "Smcdeleg/Ssccfg defines a new scountinhibit register, a masked alias of mcountinhibit.",
    "norm:ssccfg_scountinhibit_delegated_rw": "For counters delegated to S-mode, the associated mcountinhibit bits can be accessed via scountinhibit",
    "norm:ssccfg_scountinhibit_nondelegated_ro": "For counters not delegated to S-mode, the associated bits in scountinhibit are read-only zero.",
    "norm:ssccfg_illegal_scountinhibit_cde0": "When menvcfg.CDE=0, attempts to access scountinhibit raise an illegal-instruction exception.",
    "norm:ssccfg_illegal_scountinhibit_vs_vu": "When Supervisor Counter Delegation\nis enabled, attempts to access scountinhibit from VS-mode or VU-mode\nraise a virtual-instruction  exception.",
    "norm:ssccfg_virtual_scountovf_vs_vu": "For implementations that support Smcdeleg/Ssccfg, Sscofpmf, and the H extension, when menvcfg.CDE=1, attempts to read scountovf from VS-mode or VU-mode raise a virtual-instruction  exception.",
    "norm:ssccfg_lcofi_mvip_mvien": "For implementations that support Smcdeleg, Sscofpmf, and Smaia, the local-counter-overflow interrupt (LCOFI) bit (bit 13) in each of CSRs mvip and mvien is implemented and writable.",
    "norm:ssccfg_lcofi_hvip_hvien": "For implementations that support Smcdeleg/Ssccfg, Sscofpmf, Smaia/Ssaia, and the H extension, the LCOFI bit (bit 13) in each of hvip and hvien is implemented and writable.",
    "norm:Smdbltrp_with_Smrnmi_op": "When the Smrnmi extension (&lt;&lt;rnmi&gt;&gt;) is implemented, it enables\ninvocation of the RNMI handler on a double trap in M-mode to handle the\ncritical error.",
    "norm:ctr_depth": "The number of records that can be held in the buffer depends upon both the implementation (the maximum supported depth) and the CTR configuration (the software selected depth).",
    "norm:Smctr_recording_criteria": "Only qualified transfers are recorded.  Qualified transfers are those that meet the filtering criteria, which include the privilege mode and the transfer type.",
    "norm:Smctr_transfer_steps": "Recorded transfers are inserted at the write pointer, which is then incremented, while older recorded transfers may be overwritten once the buffer is full. Or the user can enable RAS (Return Address Stack) emulation mode, where only function calls are recorded, and function returns pop the last call record.  The source PC, target PC, and some optional metadata (transfer type, elapsed cycles) are stored for each recorded transfer.",
    "norm:Smctr_CTR_CSR_interface": "The CTR buffer is accessible through an indirect CSR interface, such that software can specify which logical entry in the buffer it wishes to read or write.  Logical entry 0 always corresponds to the youngest recorded transfer, followed by entry 1 as the next youngest, and so on.",
    "norm:Smctr_scope": "The machine-level extension, Smctr, encompasses all newly added Control Status Registers (CSRs), instructions, and behavior modifications for a hart across all privilege levels.",
    "norm:Ssctr_transfer_steps": "The corresponding supervisor-level extension, Ssctr, is essentially identical to Smctr, except that it excludes machine-level CSRs and behaviors not intended to be directly accessible at the supervisor level.",
    "norm:Smctr_Ssctr_depend": "Smctr and Ssctr depend on both the implementation of S-mode and the Sscsrind extension.",
    "norm:Ssctr_mctrctl-sz_acc_op": "The mctrctl register is a 64-bit read/write register that enables and configures the CTR capability.",
    "norm:mctrctl-mode_op": "Enable transfer recording in the selected privileged mode(s).",
    "norm:mctrctl-rasemu_op": "Enables RAS (Return Address Stack) Emulation Mode.",
    "norm:mctrctl-mte_op": "Enables recording of traps to M-mode when M=0.",
    "norm:mctrctl-ste_op": "Enables recording of traps to S-mode when S=0.",
    "norm:mctrctl-bpfrz_op": "Set sctrstatus.FROZEN on a breakpoint exception that traps to M-mode or S-mode.",
    "norm:mctrctl-lcofifrz_op": "Set sctrstatus.FROZEN on local-counter-overflow interrupt (LCOFI) that traps to M-mode or S-mode.",
    "norm:mctrctl-excinh_op": "Inhibit recording of exceptions.",
    "norm:mctrctl-intrinh_op": "Inhibit recording of interrupts.",
    "norm:mctrctl-tretinh_op": "Inhibit recording of trap returns.",
    "norm:mctrctl-ntbren_op": "Enable recording of not-taken branches.",
    "norm:mctrctl-tkbrinh_op": "Inhibit recording of taken branches.",
    "norm:mctrctl-indcallinh_op": "Inhibit recording of indirect calls.",
    "norm:mctrctl-dircallinh_op": "Inhibit recording of direct calls.",
    "norm:mctrctl-indjmpinh_op": "Inhibit recording of indirect jumps (without linkage).",
    "norm:mctrctl-dirjmpinh_op": "Inhibit recording of direct jumps (without linkage).",
    "norm:mctrctl-corswapinh_op": "Inhibit recording of co-routine swaps.",
    "norm:mctrctl-retinh_op": "Inhibit recording of function returns.",
    "norm:mctrctl-indljmpinh_op": "Inhibit recording of other indirect jumps (with linkage).",
    "norm:mctrctl-dirljmpinh_op": "Inhibit recording of other direct jumps (with linkage).",
    "norm:mctrctl-custom_op": "WARL bits designated for custom use.",
    "norm:mctrctl-impl": "All fields are optional except for M, S, U, and BPFRZ.  All unimplemented fields are read-only 0, while all implemented fields are writable.  If the Sscofpmf extension is implemented, LCOFIFRZ must be writable.",
    "norm:Ssctr_sctrctl_op": "The sctrctl register provides supervisor mode access to a subset of mctrctl.",
    "norm:Ssctr_sctrctl_acc": "Bits 2 and 9 in sctrctl are read-only 0. As a result, the M and MTE fields in mctrctl are not accessible through sctrctl.  All other mctrctl fields are accessible through sctrctl.",
    "norm:Ssctr_vsctrctl_sz_acc_op": "If the H extension is implemented, the vsctrctl register is a 64-bit read/write register that is VS-mode's version of supervisor register sctrctl.  When V=1, vsctrctl substitutes for the usual sctrctl, so instructions that normally read or modify sctrctl actually access vsctrctl instead.",
    "norm:vsctr-s_op": "Enable transfer recording in VS-mode.",
    "norm:vsctrctl-u_op": "Enable transfer recording in VU-mode.",
    "norm:vsctrctl-ste_op": "Enables recording of traps to VS-mode when S=0.",
    "norm:vsctrctl-bpfrz_op": "Set sctrstatus.FROZEN on a breakpoint exception that traps to VS-mode.",
    "norm:vsctrctl-lcofifrz_op": "Set sctrstatus.FROZEN on local-counter-overflow interrupt (LCOFI) that traps to VS-mode.",
    "norm:sctrdepth": "The 32-bit sctrdepth register specifies the depth of the CTR buffer.",
    "norm:sctrdepth_depth_op0": "WARL field that selects the depth of the CTR buffer.",
    "norm:sctrdepth_depth_op1": "The depth of the CTR buffer dictates the number of entries to which the hardware records transfers. For a depth of N, the hardware records transfers to entries 0..N-1. All &lt;&lt;_entry_registers, Entry Registers&gt;&gt; read as '0' and are read-only when the selected entry is in the range N to 255.  When the depth is increased, the newly accessible entries contain unspecified but legal values.",
    "norm:sctrdepth_depth": "It is implementation-specific which DEPTH value(s) are supported.",
    "norm:sctrdepth_mode": "Attempts to access sctrdepth from VS-mode or VU-mode raise a virtual-instruction exception, unless CTR state enable access restrictions apply.",
    "norm:sctrstatus": "The 32-bit sctrstatus register grants access to CTR status information and is updated by the hardware whenever CTR is active.  CTR is active when the current privilege mode is enabled for recording and CTR is not frozen.",
    "norm:sctrstatus_wrptr": "WARL field that indicates the physical CTR buffer entry to be written next.  It is incremented after new transfers are recorded (see &lt;&lt;Behavior&gt;&gt;), though there are exceptions when xctrctl.RASEMU=1, see &lt;&lt;RAS (Return Address Stack) Emulation Mode&gt;&gt;.  For a given CTR depth (where depth = 2^(DEPTH+4)^), WRPTR wraps to 0 on an increment when the value matches depth-1, and to depth-1 on a decrement when the value is 0.  Bits above those needed to represent depth-1 (e.g., bits 7:4 for a depth of 16) are read-only 0. On depth changes, WRPTR holds an unspecified but legal value.",
    "norm:sctrstatus-frozen_op": "Inhibit transfer recording.",
    "norm:Ssctr_sctrstatus_acc": "Undefined bits in sctrstatus are WPRI. Status fields may be added by future extensions,\nand software should ignore but preserve any fields that it does not recognize.  Undefined  bits must be implemented as read-only 0, unless a custom extension is implemented and enabled",
    "norm:siselect_acc_op": "The siselect index range 0x200 through 0x2FF is reserved for CTR logical entries 0 through 255. When siselect holds a value in this range, sireg provides access to ctrsource, sireg2 provides access to ctrtarget, and sireg3 provides access to ctrdata.  sireg4, sireg5, and sireg6 are read-only 0.",
    "norm:vsiselect_op": "When vsiselect holds a value in 0x200..0x2FF, the vsireg* registers provide access to the same CTR entry register state as the analogous sireg* registers.  There is not a separate set of entry registers for V=1.",
    "norm:ctrsource_op": "The ctrsource register contains the source program counter, which is the pc of the recorded control transfer instruction, or the epc of the recorded trap.",
    "norm:ctrsource_ctrtartget_ctrdata_Vbit": "The valid (V) bit is set by the hardware when a transfer is recorded in the selected CTR buffer entry, and implies that data in ctrsource, ctrtarget, and ctrdata is valid for this entry.",
    "norm:Ssctr_ctrsource_sz_acc_op": "ctrsource is an MXLEN-bit WARL register that must be able to hold all valid virtual or physical addresses that can serve as a pc. It need not be able to hold any invalid addresses; implementations may convert an invalid address into a valid address that the register is capable of holding.  When XLEN &lt; MXLEN, both explicit writes (by software) and implicit writes (for recorded transfers) will be zero-extended.",
    "norm:ctrtarget_op": "The ctrtarget register contains the target (destination) program counter\nof the recorded transfer.",
    "norm:ctrtarget_pc_next_br": "For a not-taken branch, ctrtarget holds the PC of the next sequential instruction following the branch.",
    "norm:ctrtarget_misp": "The optional MISP bit is set by the hardware\nwhen the recorded transfer is an instruction whose target or\ntaken/not-taken direction was mispredicted by the branch predictor. MISP\nis read-only 0 when not implemented.",
    "norm:ctrtarget_sz_acc": "ctrtarget is an MXLEN-bit WARL register that must be able to hold all valid virtual or physical addresses that can serve as a pc. It need not be able to hold any invalid addresses; implementations may convert an invalid address into a valid address that the register is capable of holding.  When XLEN &lt; MXLEN, both explicit writes (by software) and implicit writes (by recorded transfers) will be zero-extended.",
    "norm:ctrdata_sz_acc": "The ctrdata register contains metadata for the recorded transfer. This\nregister must be implemented, though all fields within it are optional.\nUnimplemented fields are read-only 0.  ctrdata is a 64-bit register.",
    "norm:ctrdata-type": "Identifies the type of the control flow transfer recorded in the entry, using the encodings listed in xref:transfer-type-defs[xrefstyle=short].  Implementations that do not support this field will report 0.",
    "norm:ctrdata-ccv": "Cycle Count Valid.",
    "norm:ctrdata-cc": "Cycle Count, composed of the Cycle Count Exponent (CCE, in\nCC[15:12]) and Cycle Count Mantissa (CCM, in CC[11:0]).",
    "norm:ctrdata_undef": "Undefined bits in ctrdata are WPRI. Undefined bits must be implemented as read-only 0, unless a &lt;&lt;_custom_extensions, custom extension&gt;&gt; is implemented and enabled.",
    "norm:sctrclr_op1": "Zeroes all  CTR &lt;&lt;_entry_registers, Entry Registers&gt;&gt;, for all DEPTH values",
    "norm:sctrclr_op2": "Zeroes the CTR cycle counter and CCV",
    "norm:sctrclr_acc": "Any read of ctrsource, ctrtarget, or ctrdata that follows SCTRCLR, such that it precedes the next qualified control transfer, will return the value 0.  Further, the first recorded transfer following SCTRCLR will have ctrdata.CCV=0.",
    "norm:sctrclr_exceptions": "SCTRCLR raises an illegal-instruction exception in U-mode, and a virtual-instruction exception in VU-mode, unless CTR state enable access restrictions apply.",
    "norm:mstateen_ctr1": "When mstateen0.CTR=1, accesses to CTR register state behave as described in &lt;&lt;CSRs&gt;&gt; and &lt;&lt;Entry Registers&gt;&gt; above, while SCTRCLR behaves as described in &lt;&lt;Supervisor CTR Clear Instruction&gt;&gt;.",
    "norm:mstateen_ctr0": "When mstateen0.CTR=0 and the privilege mode is less privileged than M-mode, the following operations raise an illegal-instruction exception:",
    "norm:mstateen_ctr0_execpt1": "Attempts to access sctrctl, vsctrctl, sctrdepth, or sctrstatus",
    "norm:mstateen_ctr0_execpt2": "Attempts to access sireg* when siselect is in 0x200..0x2FF, or vsireg* when vsiselect is in 0x200..0x2FF",
    "norm:mstateen_ctr0_execpt3": "Execution of the SCTRCLR instruction",
    "norm:mstateen_ctr0_qualified_transfer": "When mstateen0.CTR=0, qualified control transfers executed in privilege modes less privileged than M-mode will continue to implicitly update entry registers and sctrstatus.",
    "norm:hstateen_ctr": "If the H extension is implemented and mstateen0.CTR=1, the hstateen0.CTR bit controls access to supervisor CTR state when V=1.  This state includes sctrctl (really vsctrctl), sctrstatus, and sireg* (really vsireg*) when siselect (really vsiselect) is in 0x200..0x2FF.  hstateen0.CTR is read-only 0 when mstateen0.CTR=0.",
    "norm:hstateen_vs": "When mstateen0.CTR=1 and hstateen0.CTR=1, VS-mode accesses to supervisor CTR state behave as described in &lt;&lt;CSRs&gt;&gt; and &lt;&lt;Entry Registers&gt;&gt; above, while SCTRCLR behaves as described in &lt;&lt;Supervisor CTR Clear Instruction&gt;&gt;.  When mstateen0.CTR=1 and hstateen0.CTR=0, both VS-mode accesses to supervisor CTR state and VS-mode execution of SCTRCLR raise a virtual-instruction exception.",
    "norm:hstateen0_CTR0-V1_op": "When hstateen0.CTR=0, qualified control transfers executed while V=1 will continue to implicitly update entry registers and sctrstatus.",
    "norm:ctr_behavior": "CTR records qualified control transfers.  Control transfers are qualified if they meet the following criteria:",
    "norm:ctr_behavior_criteria0": "The current privilege mode is enabled",
    "norm:ctr_behavior_criteri1": "The transfer type is not inhibited",
    "norm:ctr_behavior_criteria2": "sctrstatus.FROZEN is not set",
    "norm:ctr_behavior_criteria3": "The transfer completes/retires",
    "norm:ctr_stack": "Such qualified transfers update the &lt;&lt;_entry_registers, Entry Registers&gt;&gt; at logical entry 0.  As a result, older entries are pushed down the stack; the record previously in logical entry 0 moves to logical entry 1, the record in logical entry 1 moves to logical entry 2, and so on.  If the CTR buffer is full, the oldest recorded entry (previously at entry depth-1) is lost.",
    "norm:ctr_validbit": "Recorded transfers will set the ctrsource.V bit to 1, and will update all implemented record fields.",
    "norm:trap_enabled": "Traps between enabled privilege modes are recorded as normal.",
    "norm:trap_disabled_src": "Traps from a disabled privilege mode to an enabled privilege mode are partially recorded, such that the ctrsource.PC is 0.",
    "norm:trap_disabled_tgt": "Traps from an enabled mode to a disabled mode, known as external traps, are not recorded by default.",
    "norm:trapret_enabled": "Trap returns between enabled privilege modes are recorded as normal.",
    "norm:trapret_to_disabled": "Trap returns from an enabled mode back to a disabled mode are partially recorded, such that ctrtarget.PC is 0.",
    "norm:trapret_from_disabled": "Trap returns from a disabled mode to an enabled mode are not recorded.",
    "norm:debug_recording_inhibited": "Recording in Debug Mode is always inhibited. Transfers into and out of Debug Mode are never recorded.",
    "norm:trap_ee": "Recorded",
    "norm:trap_ed": "External trap.  Not recorded by default,",
    "norm:trap_de": "Recorded, ctrsource.PC is 0.",
    "norm:trap_dd": "Not recorded.",
    "norm:trapret_ee": "Recorded.",
    "norm:trapret_ed": "Recorded, ctrtarget.PC is 0.",
    "norm:trapret_de": "Not recorded.",
    "norm:trapret_dd": "Not recorded.",
    "norm:exttrap_def": "External traps are traps from a privilege mode enabled for CTR recording to a privilege mode that is not enabled for CTR recording.  By default external traps are not recorded, but privileged software running in the target mode of the trap can opt-in to allowing CTR to record external traps into that mode. The xctrctl.xTE bits allow M-mode, S-mode, and VS-mode to opt-in separately.",
    "norm:exttrap_requirements": "External trap recording depends not only on the target mode, but on any intervening modes, which are modes that are more privileged than the source mode but less privileged than the target mode.  Not only must the external trap enable bit for the target mode be set, but the external trap enable bit(s) for any intervening modes must also be set.",
    "norm:exttrap_us": "sctrctl.STE",
    "norm:exttrap_um": "mctrctl.MTE, sctrctl.STE",
    "norm:exttrap_sm": "mctrctl.MTE",
    "norm:exttrap_vuvs": "vsctrctl.STE",
    "norm:exttrap_vuhs": "sctrctl.STE, vsctrctl.STE",
    "norm:exttrap_vum": "mctrctl.MTE, sctrctl.STE, vsctrctl.STE",
    "norm:exttrap_vshs": "sctrctl.STE",
    "norm:exttrap_vsm": "mctrctl.MTE, sctrctl.STE",
    "norm:exttrap_ctrtarget0": "In records for external traps, the ctrtarget.PC is 0.",
    "norm:exttrap_implreq": "If external trap recording is implemented, mctrctl.MTE and sctrctl.STE must be implemented, while vsctrctl.STE must be implemented if the H extension is implemented.",
    "norm:ttf_default": "Default CTR behavior, when all transfer type filter bits (xctrctl[47:32]) are unimplemented or 0, is to record all control transfers within enabled privileged modes. By setting transfer type filter bits, software can opt out of recording select transfer types, or opt into recording non-default operations.  All transfer type filter bits are optional.",
    "norm:ttype0": "Not used by CTR",
    "norm:ttype1": "Exception",
    "norm:ttype2": "Interrupt",
    "norm:ttype3": "Trap return",
    "norm:ttype4": "Not-taken branch",
    "norm:ttype5": "Taken branch",
    "norm:ttype8": "Indirect call",
    "norm:ttype9": "Direct call",
    "norm:ttype10": "Indirect jump (without linkage)",
    "norm:ttype11": "Direct jump (without linkage)",
    "norm:ttype12": "Co-routine swap",
    "norm:ttype13": "Function return",
    "norm:ttype14": "Other indirect jump (with linkage)",
    "norm:ttype15": "Other direct jump (with linkage)",
    "norm:various_jump_enc": "Encodings 8 through 15 refer to various encodings of jump instructions.  The types are distinguished as described below.",
    "norm:ctrdata_cc_supported": "The ctrdata register may optionally include a count of CPU cycles elapsed since the prior CTR record.  The elapsed cycle count value is represented by the CC field, which has a 12-bit mantissa component (Cycle Count Mantissa, or CCM) and a 4-bit exponent component (Cycle Count Exponent, or CCE).",
    "norm:ccounter_inc": "The elapsed cycle counter (CtrCycleCounter) increments at the same rate as the mcycle counter.  Only cycles while CTR is active are counted, where active implies that the current privilege mode is enabled for recording and CTR is not frozen.  The CC field is encoded such that CCE holds 0 if the CtrCycleCounter value is less than 4096, otherwise it holds the index of the most significant one bit in the CtrCycleCounter value, minus 11.  CCM holds CtrCycleCounter bits CCE+10:CCE-1.",
    "norm:ccounter_reset": "The CtrCycleCounter is reset on writes to xctrctl, and on execution of SCTRCLR, to ensure that any accumulated cycle counts do not persist across a context switch.",
    "norm:ccounter_impl": "An implementation that supports cycle counting must implement CCV and all\nCCM bits, but may implement 0..4 exponent bits in CCE. Unimplemented CCE\nbits are read-only 0. For implementations that support transfer type\nfiltering, it is recommended to implement at least 3 exponent bits. This\nallows capturing the full latency of most functions, when recording only\ncalls and returns.",
    "norm:ccsize0": "4095",
    "norm:ccsize1": "8191",
    "norm:ccsize2": "32764",
    "norm:ccsize3": "524224",
    "norm:ccsize4": "134201344",
    "norm:ccounter_sat": "The CC value saturates when all implemented bits in CCM and CCE are 1.",
    "norm:ccounter_ccv": "The CC value is valid only when the Cycle Count Valid (CCV) bit is set.  If CCV=0, the CC value might not hold the correct count of elapsed active cycles since the last recorded transfer.  The next record will have CCV=0 after a write to xctrctl, or execution of SCTRCLR, since CtrCycleCounter is reset.  CCV should additionally be cleared after any other implementation-specific scenarios where active cycles might not be counted in CtrCycleCounter.",
    "norm:ctrctl_rasemu_op": "When the optional xctrctl.RASEMU bit is implemented and set to 1, transfer recording behavior is altered to emulate the behavior of a return-address stack (RAS).",
    "norm:sctrstatus-frozen_set": "When sctrctl.LCOFIFRZ=1 and a local-counter-overflow interrupt\n(LCOFI) traps (as a result of an HPM counter overflow) to M-mode or to S-mode, sctrstatus.FROZEN is set by hardware. This inhibits CTR recording until software clears FROZEN. The LCOFI trap itself is not recorded.",
    "norm:freeze_bp": "Similarly, on a breakpoint exception that traps to M-mode or S-mode with sctrctl.BPFRZ=1, FROZEN is set by hardware. The breakpoint exception itself is not recorded.",
    "norm:freeze_vs": "If the H extension is implemented, freeze behavior for LCOFIs and breakpoint exceptions that trap to VS-mode is determined by the LCOFIFRZ and BPFRZ values, respectively, in vsctrctl.  This includes virtual LCOFIs pended by a hypervisor.",
    "norm:custom_bits": "Any custom CTR extension must be associated with a non-zero value within the designated custom bits in xctrctl.  When the custom bits hold a non-zero value that enables a custom extension, the extension may alter standard CTR behavior, and may define new custom status fields within sctrstatus or the CTR &lt;&lt;_entry_registers, Entry Registers&gt;&gt;.  All custom status fields, and standard status fields whose behavior is altered by the custom extension, must revert to standard behavior when the custom bits hold zero.  This includes read-only 0 behavior for any bits undefined by any implemented standard extensions.",
    "norm:sstatus": "The sstatus register is an SXLEN-bit read/write register formatted as shown in  when SXLEN=32 and  when SXLEN=64. The sstatus register keeps track of the processor&#8217;s current operating state.",
    "norm:sstatus-spp": "The SPP bit indicates the privilege level at which a hart was executing before entering supervisor mode. When a trap is taken, SPP is set to 0 if the trap originated from user mode, or 1 otherwise. When an SRET instruction (see ) is executed to return from the trap handler, the privilege level is set to user mode if the SPP bit is 0, or supervisor mode if the SPP bit is 1; SPP is then set to 0.",
    "norm:sstatus-sie": "The SIE bit enables or disables all interrupts in supervisor mode. When SIE is clear, interrupts are not taken while in supervisor mode. When the hart is running in user-mode, the value in SIE is ignored, and supervisor-level interrupts are enabled. The supervisor can disable individual interrupt sources using the sie CSR.",
    "norm:sstatus-spie": "The SPIE bit indicates whether supervisor interrupts were enabled prior to trapping into supervisor mode. When a trap is taken into supervisor mode, SPIE is set to SIE, and SIE is set to 0. When an SRET instruction is executed, SIE is set to SPIE, then SPIE is set to 1.",
    "norm:sstatus-uxl": "The UXL field controls the value of XLEN for U-mode, termed UXLEN, which may differ from the value of XLEN for S-mode, termed SXLEN. The encoding of UXL is the same as that of the MXL field of misa, shown in .",
    "norm:sstatus_uxl_sz": "When SXLEN=32, the UXL field does not exist, and UXLEN=32. When SXLEN=64, it is a WARL field that encodes the current value of UXLEN. In particular, an implementation may make UXL be a read-only field whose value always ensures that UXLEN=SXLEN.",
    "norm:sstatus-uxl_behavior": "If UXLEN≠SXLEN, instructions executed in the narrower mode must ignore source register operand bits above the configured XLEN, and must sign-extend results to fill the widest supported XLEN in the destination register.",
    "norm:hint_sxlen": "Some HINT instructions are encoded as integer computational instructions that overwrite their destination register with its current value, e.g., c.addi x8, 0. When such a HINT is executed with XLEN &lt; SXLEN and bits SXLEN..XLEN of the destination register not all equal to bit XLEN-1, it is implementation-defined whether bits SXLEN..XLEN of the destination register are unchanged or are overwritten with copies of bit XLEN-1.",
    "norm:sstatus-mxr": "The MXR (Make eXecutable Readable) bit modifies the privilege with which loads access virtual memory. When MXR=0, only loads from pages marked readable (R=1 in ) will succeed. When MXR=1, loads from pages marked either readable or executable (R=1 or X=1) will succeed. MXR has no effect when page-based virtual memory is not in effect.",
    "norm:sstatus-sum": "The SUM (permit Supervisor User Memory access) bit modifies the privilege with which S-mode loads and stores access virtual memory. When SUM=0, S-mode memory accesses to pages that are accessible by U-mode (U=1 in ) will fault. When SUM=1, these accesses are permitted. SUM has no effect when page-based virtual memory is not in effect, nor when executing in U-mode. Note that S-mode can never execute instructions from user pages, regardless of the state of SUM.",
    "norm:sstatus-sum_satp-mode": "SUM is read-only 0 if satp.MODE is read-only 0.",
    "norm:sstatus_ube": "The UBE bit is a WARL field that controls the endianness of explicit memory accesses made from U-mode, which may differ from the endianness of memory accesses in S-mode. An implementation may make UBE be a read-only field that always specifies the same endianness as for S-mode.",
    "norm:sstatus_ube_implicit": "UBE has no effect on instruction fetches, which are implicit memory accesses that are always little-endian.",
    "norm:sstatus-spelp": "Access to the SPELP field, added by Zicfilp, accesses the homonymous fields of mstatus when V=0, and the homonymous fields of vsstatus when V=1.",
    "norm:sstatus_sdt": "The S-mode-disable-trap (SDT) bit is a WARL field introduced by the Ssdbltrp extension to address double trap (See ) at privilege modes lower than M.",
    "norm:sstatus_sdt_sstatus_sie_overwrite": "When the SDT bit is set to 1 by an explicit CSR write, the SIE (Supervisor Interrupt Enable) bit is cleared to 0. This clearing occurs regardless of the value written, if any, to the SIE bit by the same write. The SIE bit can only be set to 1 by an explicit CSR write if the SDT bit is being set to 0 by the same write or is already 0.",
    "norm:sstatus_sdt_trap": "When a trap is to be taken into S-mode, if the SDT bit is currently 0, it is then set to 1, and the trap is delivered as expected. However, if SDT is already set to 1, then this is an unexpected trap. In the event of an unexpected trap, a double-trap exception trap is delivered into M-mode. To deliver this trap, the hart writes registers, except mcause and mtval2, with the same information that the unexpected trap would have written if it was taken into M-mode. The mtval2 register is then set to what would be otherwise written into the mcause register by the unexpected trap. The mcause register is set to 16, the double-trap exception code.",
    "norm:sstatus_sdt_sret": "An SRET instruction sets the SDT bit to 0.",
    "norm:stvec": "The stvec register is an SXLEN-bit read/write register that holds trap vector configuration, consisting of a vector base address (BASE) and a vector mode (MODE).",
    "norm:stvec_op": "The BASE field in stvec is a  field that can hold any valid virtual or physical address, subject to the following alignment constraints: the address must be 4-byte aligned, and MODE settings other than Direct might impose additional alignment constraints on the value in the BASE field.",
    "norm:stvec_sz_base": "Note that the CSR contains only bits XLEN-1 through 2 of the address BASE. When used as an address, the lower two bits are filled with zeroes to obtain an XLEN-bit address that is always aligned on a 4-byte boundary.",
    "norm:sip_sie": "The sip register is an SXLEN-bit read/write register containing information on pending interrupts, while sie is the corresponding SXLEN-bit read/write register containing interrupt enable bits. Interrupt cause number i (as reported in CSR scause, ) corresponds with bit i in both sip and sie. Bits 15:0 are allocated to standard interrupt causes only, while bits 16 and above are designated for platform use.",
    "norm:sie_sip_supervisor_strap": "An interrupt i will trap to S-mode if both of the following are true: (a) either the current privilege mode is S and the SIE bit in the sstatus register is set, or the current privilege mode has less privilege than S-mode; and (b) bit i is set in both sip and sie.",
    "norm:sie_sip_strap_time_constraint": "These conditions for an interrupt trap to occur must be evaluated in a bounded amount of time from when an interrupt becomes, or ceases to be, pending in sip, and must also be evaluated immediately following the execution of an SRET instruction or an explicit write to a CSR on which these interrupt trap conditions expressly depend (including sip, sie and sstatus).",
    "norm:s_interrupt_priority": "Interrupts to S-mode take priority over any interrupts to lower privilege modes.",
    "norm:sip_acc": "Each individual bit in register sip may be writable or may be\nread-only.",
    "norm:sip_op": "When bit i in sip is writable, a pending interrupt i\ncan be cleared by writing 0 to this bit. If interrupt i can become\npending but bit i in sip is read-only, the implementation must\nprovide some other mechanism for clearing the pending interrupt (which\nmay involve a call to the execution environment).",
    "norm:sie_acc": "A bit in sie must be writable if the corresponding interrupt can ever\nbecome pending. Bits of sie that are not writable are read-only zero.",
    "norm:sip_sie_bits_sz": "The standard portions (bits 15:0) of registers sip and sie are formatted as shown in Figures  and  respectively.",
    "norm:sip-seip_sie-seie": "Bits sip.SEIP and sie.SEIE are the interrupt-pending and interrupt-enable bits for supervisor-level external interrupts. If implemented, SEIP is read-only in sip, and is set and cleared by the execution environment, typically through a platform-specific interrupt controller.",
    "norm:sip-stip_sie-stie": "Bits sip.STIP and sie.STIE are the interrupt-pending and interrupt-enable bits for supervisor-level timer interrupts. If implemented, STIP is read-only in sip. When the Sstc extension is not implemented, STIP is set and cleared by the execution environment. When the Sstc extension is implemented, STIP reflects the timer interrupt signal resulting from stimecmp. The sip.STIP bit, in response to timer interrupts generated by stimecmp, is set by writing stimecmp with a value that is less than or equal to time, and is cleared by writing stimecmp with a value greater than time.",
    "norm:sip-ssip_sie-ssie": "Bits sip.SSIP and sie.SSIE are the interrupt-pending and interrupt-enable bits for supervisor-level software interrupts. If implemented, SSIP is writable in sip and may also be set to 1 by a platform-specific interrupt controller.",
    "norm:sip_sie_Sscofpmf": "If the Sscofpmf extension is implemented, bits sip.LCOFIP and sie.LCOFIE are the interrupt-pending and interrupt-enable bits for local-counter-overflow interrupts. LCOFIP is read-write in sip and reflects the occurrence of a local counter-overflow overflow interrupt request resulting from any of the mhpmeventn.OF bits being set. If the Sscofpmf extension is not implemented, sip.LCOFIP and sie.LCOFIE are read-only zeros.",
    "norm:sip_sie_unimpl": "Each standard interrupt type (SEI, STI, SSI, or LCOFI) may not be implemented, in which case the corresponding interrupt-pending and interrupt-enable bits are read-only zeros. All bits in sip and sie are WARL fields. The implemented interrupts may be found by writing one to every bit location in sie, then reading back to see which bit positions hold a one.",
    "norm:sip_sie_priority_bit_order": "Multiple simultaneous interrupts destined for supervisor mode are handled in the following decreasing priority order: SEI, SSI, STI, LCOFI.",
    "norm:supervisor_timer_scheduling": "The implementation must provide a facility for scheduling timer interrupts in terms of the real-time counter, time.",
    "norm:scounteren": "The counter-enable (scounteren) CSR is a 32-bit register that controls the availability of the hardware performance monitoring counters to U-mode.",
    "norm:scounteren_op": "When the CY, TM, IR, or HPMn bit in the scounteren register is clear, attempts to read the cycle, time, instret, or hpmcountern register while executing in U-mode will cause an illegal-instruction exception. When one of these bits is set, access to the corresponding register is permitted.",
    "norm:scounteren_acc": "scounteren must be implemented. However, any of the bits may be read-only zero, indicating reads to the corresponding counter will cause an exception when executing in U-mode. Hence, they are effectively WARL fields.",
    "norm:sscratch": "The sscratch CSR is an SXLEN-bit read/write register, dedicated for use by the supervisor. Typically, sscratch is used to hold a pointer to the hart-local supervisor context while the hart is executing user code. At the beginning of a trap handler, software normally uses a CSRRW instruction to swap sscratch with an integer register to obtain an initial working register.",
    "norm:sepc": "sepc is an SXLEN-bit read/write CSR formatted as shown in . The low bit of sepc (sepc[0]) is always zero. On implementations that support only IALIGN=32, the two low bits (sepc[1:0]) are always zero.",
    "norm:sepc_op_mask_ialign32": "If an implementation allows IALIGN to be either 16 or 32 (by changing CSR misa, for example), then, whenever IALIGN=32, bit sepc[1] is masked on reads so that it appears to be 0. This masking occurs also for the implicit read by the SRET instruction. Though masked, sepc[1] remains writable when IALIGN=32.",
    "norm:sepc_acc_invalid_addr": "sepc is a WARL register that must be able to hold all valid virtual addresses. It need not be capable of holding all possible invalid addresses. Prior to writing sepc, implementations may convert an invalid address into some other invalid address that sepc is capable of holding.",
    "norm:sepc_op_trap_write": "When a trap is taken into S-mode, sepc is written with the virtual address of the instruction that was interrupted or that encountered the exception. Otherwise, sepc is never written by the implementation, though it may be explicitly written by software.",
    "norm:scause": "The scause CSR is an SXLEN-bit read-write register formatted as shown in . When a trap is taken into S-mode, scause is written with a code indicating the event that caused the trap. Otherwise, scause is never written by the implementation, though it may be explicitly written by software.",
    "norm:scause_exception_code_acc": "The\nException Code is a WLRL field.",
    "norm:scause-exception_code_sz": "It is required to hold the values 0–31\n(i.e., bits 4–0 must be implemented), but otherwise it is only\nguaranteed to hold supported exception codes.",
    "norm:scause-interrupt": "The Interrupt bit in the scause register is set if the trap was caused by an interrupt. The Exception Code field contains a code identifying the last exception or interrupt.  lists the possible exception codes for the current supervisor ISAs. The Exception Code is a WLRL field. It is required to hold the values 0–31 (i.e., bits 4–0 must be implemented), but otherwise it is only guaranteed to hold supported exception codes.",
    "norm:stval": "The stval CSR is an SXLEN-bit read-write register formatted as shown in . When a trap is taken into S-mode, stval is written with exception-specific information to assist software in handling the trap. Otherwise, stval is never written by the implementation, though it may be explicitly written by software. The hardware platform will specify which exceptions must set stval informatively, which may unconditionally set it to zero, and which may exhibit either behavior, depending on the underlying event that caused the exception.",
    "norm:stval_op_faulting_addr": "If stval is written with a nonzero value when a breakpoint, address-misaligned, access-fault, page-fault, or hardware-error exception occurs on an instruction fetch, load, or store, then stval will contain the faulting virtual address.",
    "norm:stval_op_breakpoint": "On a breakpoint exception raised by an EBREAK or C.EBREAK instruction, stval is written with either zero or the virtual address of the instruction.",
    "norm:stval_op_load_store_fault": "If stval is written with a nonzero value when a misaligned load or store causes an access-fault, page-fault, or hardware-error exception, then stval will contain the virtual address of the portion of the access that caused the fault.",
    "norm:stval_faulting_address_variable_instr": "If stval is written with a nonzero value when an instruction access-fault, page-fault, or hardware-error exception occurs on a hart with variable-length instructions, then stval will contain the virtual address of the portion of the instruction that caused the fault, while sepc will point to the beginning of the instruction.",
    "norm:stval_op_illegal_instr": "The stval register can optionally also be used to return the faulting instruction bits on an illegal-instruction exception (sepc points to the faulting instruction in memory). If stval is written with a nonzero value when an illegal-instruction exception occurs, then stval will contain the shortest of:",
    "norm:stval_op_illegal_instr_format": "The value loaded into stval on an illegal-instruction exception is right-justified and all unused upper bits are cleared to zero.",
    "norm:stval_exception_info": "On a trap caused by a software-check exception, the stval register holds the cause for the exception. The following encodings are defined:",
    "norm:stval_op_other_traps": "For other traps, stval is set to zero, but a future standard may redefine stval’s setting for other traps.",
    "norm:stval_acc": "stval is a WARL register that must be able to hold all valid virtual addresses and the value 0. It need not be capable of holding all possible invalid addresses. Prior to writing stval, implementations may convert an invalid address into some other invalid address that stval is capable of holding. If the feature to return the faulting instruction bits is implemented, stval must also be able to hold all values less than 2N, where N is the smaller of SXLEN and ILEN.",
    "norm:senvcfg": "The senvcfg CSR is an SXLEN-bit read/write register, formatted as shown in , that controls certain characteristics of the U-mode execution environment.",
    "norm:senvcfg-fiom": "If bit FIOM (Fence of I/O implies Memory) is set to one in senvcfg, FENCE instructions executed in U-mode are modified so the requirement to order accesses to device I/O implies also the requirement to order main memory accesses.  details the modified interpretation of FENCE instruction bits PI, PO, SI, and SO in U-mode when FIOM=1.",
    "norm:senvcfg-fiom_op_atomic": "Similarly, for U-mode when FIOM=1, if an atomic instruction that accesses a region ordered as device I/O has its aq and/or rl bit set, then that instruction is ordered as though it accesses both device I/O and memory.",
    "norm:senvcfg-fiom_acc": "If satp.MODE is read-only zero (always Bare), the implementation may make FIOM read-only zero.",
    "norm:senvcfg-cbze": "The Zicboz extension adds the CBZE (Cache Block Zero instruction enable) field to senvcfg. The CBZE field controls execution of the cache block zero instruction (CBO.ZERO) in U-mode. Execution of CBO.ZERO in U-mode is enabled only if execution of the instruction is enabled for use in S-mode and CBZE is set to 1; otherwise, an illegal-instruction exception is raised. When the Zicboz extension is not implemented, CBZE is read-only zero.",
    "norm:senvcfg-cbcfe": "The Zicbom extension adds the CBCFE (Cache Block Clean and Flush instruction Enable) field to senvcfg to control execution of the CBO.CLEAN and CBO.FLUSH instructions in U-mode. Execution of these instructions in U-mode is enabled only if execution of these instructions is enabled for use in S-mode and CBCFE is set to 1; otherwise, an illegal-instruction exception is raised. When the Zicbom extension is not implemented, CBCFE is read-only zero.",
    "norm:senvcfg_cbie": "The Zicbom extension adds the CBIE (Cache Block Invalidate instruction Enable) WARL field to senvcfg to control execution of the CBO.INVAL instruction in U-mode. The encoding 10b is reserved. When the Zicbom extension is not implemented, CBIE is read-only zero. Execution of CBO.INVAL in U-mode is enabled only if execution of the instruction is enabled for use in S-mode and CBIE is set to 01b or 11b; otherwise, an illegal-instruction exception is raised.",
    "norm:cbo-inval_s-mode_op0": "If CBO.INVAL is enabled in S-mode to perform a flush operation, then when the\ninstruction is enabled in U-mode it performs a flush operation, even if CBIE\nis set to 11b. Otherwise, the instruction behaves as follows, depending on the\nCBIE encoding:",
    "norm:cbo-inval_s-mode_op1": "",
    "norm:cbo-inval_s-mode_op2": "",
    "norm:senvcfg-pmm_Ssnpm": "If the Ssnpm extension is implemented, the PMM field enables or disables pointer masking (see ) for the next-lower privilege mode (U/VU), according to the values in . If Ssnpm is not implemented, PMM is read-only zero. The PMM field is read-only zero for RV32.",
    "norm:senvcfg-lpe_Zicfilp": "The Zicfilp extension adds the LPE field in senvcfg. When the LPE field is set to 1, the Zicfilp extension is enabled in VU/U-mode. When the LPE field is 0, the Zicfilp extension is not enabled in VU/U-mode and the following rules apply to VU/U-mode:",
    "norm:senvcfg-sse_Zicfilp": "The Zicfiss extension adds the SSE field in senvcfg. When the SSE field is set to 1, the Zicfiss extension is activated in VU/U-mode. When the SSE field is 0, the Zicfiss extension remains inactive in VU/U-mode, and the following rules apply:",
    "norm:satp": "The satp CSR is an SXLEN-bit read/write register, formatted as shown in  for SXLEN=32 and  for SXLEN=64, which controls supervisor-mode address translation and protection. This register holds the physical page number (PPN) of the root page table, i.e., its supervisor physical address divided by 4 KiB; an address space identifier (ASID), which facilitates address-translation fences on a per-address-space basis; and the MODE field, which selects the current address-translation scheme. Further details on the access to this register are described in .",
    "norm:satp-mode": "shows the encodings of the MODE field when SXLEN=32 and SXLEN=64. When MODE=Bare, supervisor virtual addresses are equal to supervisor physical addresses, and there is no additional memory protection beyond the physical memory protection scheme described in . To select MODE=Bare, software must write zero to the remaining fields of satp (bits 30–0 when SXLEN=32, or bits 59–0 when SXLEN=64). Attempting to select MODE=Bare with a nonzero pattern in the remaining fields has an UNSPECIFIED effect on the value that the remaining fields assume and an UNSPECIFIED effect on address translation and protection behavior.",
    "norm:satp-mode_sxlen32": "When SXLEN=32, the only other valid setting for MODE is Sv32, a paged virtual-memory scheme described in .",
    "norm:satp-mode_sxlen64": "When SXLEN=64, three paged virtual-memory schemes are defined: Sv39, Sv48, and Sv57, described in , , and , respectively. One additional scheme, Sv64, will be defined in a later version of this specification. The remaining MODE settings are reserved for future use and may define different interpretations of the other fields in satp.",
    "norm:satp-mode_op_unsupported": "Implementations are not required to support all MODE settings, and if satp is written with an unsupported MODE, the entire write has no effect; no fields in satp are modified.",
    "norm:satp_asidlen": "The number of ASID bits is UNSPECIFIED and may be zero. The number of implemented ASID bits, termed ASIDLEN, may be determined by writing one to every bit position in the ASID field, then reading back the value in satp to see which bit positions in the ASID field hold a one. The least-significant bits of ASID are implemented first: that is, if ASIDLEN &gt; 0, ASID[ASIDLEN-1:0] is writable. The maximal value of ASIDLEN, termed ASIDMAX, is 9 for Sv32 or 16 for Sv39, Sv48, and Sv57.",
    "norm:satp_op_active": "The satp CSR is considered active when the effective privilege mode is S-mode or U-mode. Executions of the address-translation algorithm may only begin using a given value of satp when satp is active.",
    "norm:satp_op_sfence-vma": "Note that writing satp does not imply any ordering constraints between page-table updates and subsequent address translations, nor does it imply any invalidation of address-translation caches. If the new address space’s page tables have been modified, or if an ASID is reused, it may be necessary to execute an SFENCE.VMA instruction (see ) after, or in some cases before, writing satp.",
    "norm:stimecmp-stimecmph_sz_acc": "The stimecmp CSR is a 64-bit register and\nhas 64-bit precision on all RV32 and RV64 systems.\nIn RV32 only, accesses to the stimecmp CSR access the low 32 bits,\nwhile accesses to the stimecmph CSR access the high 32 bits of stimecmp.",
    "norm:mip_sip-stip_op": "A supervisor timer interrupt becomes pending, as reflected in the STIP bit in the mip and sip registers whenever time contains a value greater than or equal to stimecmp, treating the values as unsigned integers. If the result of this comparison changes, it is guaranteed to be reflected in STIP eventually, but not necessarily immediately. The interrupt remains posted until stimecmp becomes greater than time, typically as a result of writing stimecmp. The interrupt will be taken based on the standard interrupt enable and delegation rules.",
    "norm:sfence-vma_ordering": "Executing an SFENCE.VMA instruction guarantees that any previous stores\nalready visible to the current RISC-V hart are ordered before certain\nimplicit references by subsequent instructions in that hart to the\nmemory-management data structures. The specific set of operations\nordered by SFENCE.VMA is determined by rs1 and rs2, as described\nbelow.",
    "norm:sfence-vma_invalidation": "SFENCE.VMA is also used to invalidate entries in the\naddress-translation cache associated with a hart (see &lt;&lt;sv32algorithm&gt;&gt;).",
    "norm:sfence-vma_op": "The supervisor memory-management fence instruction SFENCE.VMA is used to synchronize updates to in-memory memory-management data structures with current execution. Instruction execution causes implicit reads and writes to these data structures; however, these implicit references are ordinarily not ordered with respect to explicit loads and stores. Executing an SFENCE.VMA instruction guarantees that any previous stores already visible to the current RISC-V hart are ordered before certain implicit references by subsequent instructions in that hart to the memory-management data structures. The specific set of operations ordered by SFENCE.VMA is determined by rs1 and rs2, as described below. SFENCE.VMA is also used to invalidate entries in the address-translation cache associated with a hart (see ). Further details on the behavior of this instruction are described in  and .",
    "norm:sfence-vma_all_asid_va": "If rs1=x0 and rs2=x0, the fence orders all reads and writes\nmade to any level of the page tables, for all address spaces. The fence\nalso invalidates all address-translation cache entries, for all address\nspaces.",
    "norm:sfence-vma_asid_only": "If rs1=x0 and rs2{ne}x0, the fence orders all\nreads and writes made to any level of the page tables, but only for the\naddress space identified by integer register rs2. Accesses to global\nmappings (see &lt;&lt;translation&gt;&gt;) are not ordered. The\nfence also invalidates all address-translation cache entries matching\nthe address space identified by integer register rs2, except for\nentries containing global mappings.",
    "norm:sfence-vma_va_all_asid": "If rs1{ne}x0 and rs2=x0, the fence orders only\nreads and writes made to leaf page table entries corresponding to the\nvirtual address in rs1, for all address spaces. The fence also\ninvalidates all address-translation cache entries that contain leaf page\ntable entries corresponding to the virtual address in rs1, for all\naddress spaces.",
    "norm:sfence-vma_va_asid": "If rs1{ne}x0 and rs2{ne}x0, the\nfence orders only reads and writes made to leaf page table entries\ncorresponding to the virtual address in rs1, for the address space\nidentified by integer register rs2. Accesses to global mappings are\nnot ordered. The fence also invalidates all address-translation cache\nentries that contain leaf page table entries corresponding to the\nvirtual address in rs1 and that match the address space identified by\ninteger register rs2, except for entries containing global mappings.",
    "norm:sfence-vma_invalid_va": "If the value held in rs1 is not a valid virtual address, then the SFENCE.VMA instruction has no effect. No exception is raised in this case.",
    "norm:sfence-vma_rs2_bits": "When rs2≠x0, bits SXLEN-1:ASIDMAX of the value held in rs2 are reserved for future standard use. Until their use is defined by a standard extension, they should be zeroed by software and ignored by current implementations. Furthermore, if ASIDLEN&lt;ASIDMAX, the implementation shall ignore bits ASIDMAX-1:ASIDLEN of the value held in rs2.",
    "norm:sfence-vma_ordering_semantics": "An implicit read of the memory-management data structures may return any translation for an address that was valid at any time since the most recent SFENCE.VMA that subsumes that address. The ordering implied by SFENCE.VMA does not place implicit reads and writes to the memory-management data structures into the global memory order in a way that interacts cleanly with the standard RVWMO ordering rules. In particular, even though an SFENCE.VMA orders prior explicit accesses before subsequent implicit accesses, and those implicit accesses are ordered before their associated explicit accesses, SFENCE.VMA does not necessarily place prior explicit accesses before subsequent explicit accesses in the global memory order. These implicit loads also need not otherwise obey normal program order semantics with respect to prior loads or stores to the same address.",
    "norm:sfence-vma_implicit_access": "Implementations must only perform implicit reads of the translation data structures pointed to by the current contents of the satp register or a subsequent valid (V=1) translation data structure entry, and must only raise exceptions for implicit accesses that are generated as a result of instruction execution, not those that are performed speculatively.",
    "norm:sfence-vma-sum-mxr_effect": "Changes to the sstatus fields SUM and MXR take effect immediately,\nwithout the need to execute an SFENCE.VMA instruction.",
    "norm:sfence-vma-mode_effect": "Changing\nsatp.MODE from Bare to other modes and vice versa also takes effect\nimmediately, without the need to execute an SFENCE.VMA instruction.",
    "norm:sfence-vma-asid_effect": "Likewise, changes to satp.ASID take effect immediately.",
    "norm:asid_hart_private": "If a hart employs an address-translation cache, that cache must appear to be private to that hart. In particular, the meaning of an ASID is local to a hart; software may choose to use the same ASID to refer to different address spaces on different harts.",
    "norm:satp_mode_roz_sfence_illegal": "For implementations that make satp.MODE read-only zero (always Bare), attempts to execute an SFENCE.VMA instruction might raise an illegal-instruction exception.",
    "norm:satp-ppn_sv32_sz": "22-bit physical page number (PPN)",
    "norm:fetch_page_fault_no_x": "Attempting to fetch an instruction from a page that does not have\nexecute permissions raises a fetch page-fault exception.",
    "norm:load_page_fault_no_r": "Attempting to execute a load, load-reserved, or cache-block management\ninstruction whose effective address lies\nwithin a page without read permissions raises a load page-fault exception.",
    "norm:store_page_fault_no_w": "Attempting to execute a store, store-conditional, AMO, or cache-block zero instruction\ninstruction whose effective address lies within a page without write\npermissions raises a store page-fault exception.",
    "norm:Sv39_sxlen": "simple paged virtual-memory system for\nSXLEN=64",
    "norm:Sv39_va_sz": "supports 39-bit virtual address spaces",
    "norm:Sv39_va_signext": "must have bits 63–39 all equal to bit 38, or else\na page-fault exception will occur",
    "norm:Sv39_vpn_sz": "27-bit VPN",
    "norm:satp-ppn_sv39_sz": "44-bit PPN",
    "norm:Sv39_levels": "three-level page table",
    "norm:Sv39_page_offset_sz": "12-bit page offset is untranslated",
    "norm:Sv39_pte_count": "2^9^ page table entries\n(PTEs)",
    "norm:Sv39_pte_sz": "eight bytes each",
    "norm:Sv39_pt_sz": "exactly the size of a page",
    "norm:Sv39_pt_align": "must always be aligned to a page boundary",
    "norm:Sv39_pte_svnapot_rsv": "If Svnapot is not implemented, bit 63 remains\nreserved and must be zeroed by software for forward compatibility, or\nelse a page-fault exception is raised",
    "norm:Sv39_pte_svpbmt_rsv": "If Svpbmt is not implemented, bits 62-61 remain\nreserved and must be zeroed by software for forward compatibility, or\nelse a page-fault exception is raised",
    "norm:Sv39_pte_future_rsv": "must be zeroed by software for forward\ncompatibility. If any of these bits are set, a page-fault exception is\nraised",
    "norm:Sv39_leaf_any_level": "Any level of PTE may be a leaf PTE",
    "norm:Sv39_page_sizes": "2 MiB megapages and 1 GiB gigapages",
    "norm:Sv39_superpage_align": "must be virtually and physically\naligned to a boundary equal to its size",
    "norm:Sv39_superpage_align_fault": "A page-fault exception is raised if\nthe physical address is insufficiently aligned",
    "norm:Sv39_LEVELS": "LEVELS equals 3",
    "norm:Sv39_PTESIZE": "PTESIZE equals 8",
    "norm:Sv48_sxlen": "SXLEN=64",
    "norm:Sv48_va_sz": "48-bit virtual address spaces",
    "norm:Sv48_requires_Sv39": "Implementations that support Sv48 must also\nsupport Sv39",
    "norm:Sv48_va_signext": "must have bits 63–48 all equal to bit 47, or else\na page-fault exception will occur",
    "norm:Sv48_vpn_sz": "36-bit VPN",
    "norm:satp-ppn_sv48_sz": "44-bit PPN",
    "norm:Sv48_levels": "four-level page table",
    "norm:Sv48_page_offset_sz": "12-bit page offset is untranslated",
    "norm:Sv48_leaf_any_level": "Any level of PTE may be a leaf PTE",
    "norm:Sv48_page_sizes": "2 MiB megapages, 1 GiB gigapages, and\n512 GiB terapages",
    "norm:Sv48_superpage_align": "must be virtually and physically aligned to\na boundary equal to its size",
    "norm:Sv48_superpage_align_fault": "A page-fault exception is raised if\nthe physical address is insufficiently aligned",
    "norm:Sv48_LEVELS": "LEVELS equals 4",
    "norm:Sv48_PTESIZE": "PTESIZE equals 8",
    "norm:Sv57_sxlen": "RV64 systems",
    "norm:Sv57_va_sz": "57-bit virtual address spaces",
    "norm:Sv57_requires_Sv48": "Implementations that support Sv57 must also\nsupport Sv48",
    "norm:Sv57_va_signext": "must have bits 63–57 all equal to bit 56, or else\na page-fault exception will occur",
    "norm:Sv57_vpn_sz": "45-bit VPN",
    "norm:satp-ppn_sv57_sz": "44-bit PPN",
    "norm:Sv57_levels": "five-level page table",
    "norm:Sv57_page_offset_sz": "12-bit page offset is untranslated",
    "norm:Sv57_leaf_any_level": "Any level of PTE may be a leaf PTE",
    "norm:Sv57_page_sizes": "2 MiB megapages, 1 GiB gigapages, 512 GiB\nterapages, and 256 TiB petapages",
    "norm:Sv57_superpage_align": "must be virtually and physically aligned to\na boundary equal to its size",
    "norm:Sv57_superpage_align_fault": "A page-fault exception is raised if\nthe physical address is insufficiently aligned",
    "norm:Sv57_LEVELS": "LEVELS equals 5",
    "norm:Sv57_PTESIZE": "PTESIZE equals 8",
    "norm:Svnapot_pte_N": "N=1",
    "norm:Svnapot_range_napot": "Such ranges must be of a naturally aligned\npower-of-2 (NAPOT) granularity larger than the base page size",
    "norm:Svnapot_depends_Sv39": "The Svnapot extension depends on the Sv39\nextension",
    "norm:Svnapot_valid_encoding": "valid according to &lt;&lt;ptenapot&gt;&gt;",
    "norm:Svnapot_implicit_read_ppn_subst": "implicit reads of a NAPOT PTE\nreturn a copy of pte in which pte.ppn[i][pte.napot_bits-1:0]\nis replaced by vpn[i][pte.napot_bits-1:0]",
    "norm:Svnapot_reserved_encoding_fault": "reserved according to\n&lt;&lt;ptenapot&gt;&gt;, then a page-fault exception must be raised",
    "norm:Svnapot_cache_entries": "Implicit reads of NAPOT page table entries\nmay create address-translation cache entries mapping\na + j×PTESIZE to a copy of pte in which\npte.ppn[i][pte.napot_bits-1:0] is replaced by\nvpn[i][pte.napot_bits-1:0], for any or all j such that\nj &gt;&gt; napot_bits = vpn[i] &gt;&gt; napot_bits, all for the\naddress space identified in satp as loaded by step 1",
    "norm:Svnapot_hyp_gstage": "Svnapot is also supported in G-stage\ntranslation",
    "norm:Svpbmt_depends_Sv39": "The Svpbmt extension depends on the Sv39 extension",
    "norm:Svpbmt_impl_may_override_pmas": "Implementations may override additional PMAs not explicitly listed in\n&lt;&lt;pbmt&gt;&gt;.",
    "norm:Svpbmt_nonleaf_pte_pbmt_must_be_zero": "Until their use is defined by a standard extension, they must be cleared\nby software for forward compatibility, or else a page-fault exception is\nraised.",
    "norm:Svpbmt_leaf_pte_pbmt_reserved_3_fault": "Until this value is defined by a standard extension, using\nthis reserved value in a leaf PTE raises a page-fault exception.",
    "norm:Svpbmt_obeys_mem_ordering": "memory accesses to such pages obey the memory ordering rules of the\nfinal effective attribute,",
    "norm:Svpbmt_io_pma_nc_pbmt_obey_rvwmo": "If the underlying physical memory attribute for a page is I/O, and the\npage has PBMT=NC, then\naccesses to that page obey RVWMO.",
    "norm:Svpbmt_io_pma_nc_pbmt_treated_as_io_and_memory": "accesses to such pages are considered to be both I/O and main memory\naccesses for the purposes of FENCE, .aq, and .rl.",
    "norm:Svpbmt_memory_pma_io_pbmt_strong_io_ordering": "accesses to that page obey strong channel\n0 I/O ordering rules.",
    "norm:Svpbmt_memory_pma_io_pbmt_treated_as_io_and_memory": "accesses to\nsuch pages are considered to be both I/O and main memory accesses for\nthe purposes of FENCE, .aq, and .rl.",
    "norm:Svpbmt_aliasing_attribute": "When Svpbmt is used with non-zero PBMT encodings, it is possible for\nmultiple virtual aliases of the same physical page to exist\nsimultaneously with different memory attributes. It is also possible for\na U-mode or S-mode mapping through a PTE with Svpbmt enabled to observe\ndifferent memory attributes for a given region of physical memory than a\nconcurrent access to the same page performed by M-mode or when\nMODE=Bare. In such cases,\nthe behaviors dictated by the attributes\n(including coherence, which is otherwise unaffected) may be violated.",
    "norm:Svpbmt_noncacheable_aliasing_no_coherence_loss": "Accessing the same location using different attributes that are both\nnon-cacheable (e.g., NC and IO)\ndoes not cause loss of coherence,",
    "norm:Svpbmt_noncacheable_aliasing_may_weaken_ordering": "might result in weaker memory ordering than the stricter attribute\nordinarily guarantees.",
    "norm:Svpbmt_noncacheable_aliasing_fence_prevents_ordering_loss": "fence iorw, iorw instruction\nbetween such accesses suffices to prevent loss of memory ordering.",
    "norm:Svpbmt_cacheable_aliasing_may_cause_coherence_loss": "may\ncause loss of coherence.",
    "norm:Svpbmt_cacheable_aliasing_fence_flush_fence_required": "prevents both loss of coherence and loss of memory ordering:",
    "norm:Svpbmt_hgatp_stage_override_rule": "if hgatp.MODE is not equal to zero, non-zero G-stage PTE PBMT bits\noverride the attributes in the PMA to produce an intermediate set of\nattributes.",
    "norm:Svpbmt_vsatp_stage_override_rule": "if vsatp.MODE is not equal to zero, non-zero VS-stage PTE PBMT\nbits override the intermediate attributes to produce the final set of\nattributes used by accesses to the page in question.",
    "norm:Svinval_split_fine_grained": "that can be more efficiently batched or pipelined on certain classes of\nhigh-performance implementation.",
    "norm:Svinval_sinval_vma_invalidates_same_as_sfence_vma": "However, unlike SFENCE.VMA, SINVAL.VMA\ninstructions are only ordered with respect to SFENCE.VMA,\nSFENCE.W.INVAL, and SFENCE.INVAL.IR instructions as defined below.",
    "norm:Svinval_sfence_w_inval_orders_before_sinval_vma": "The SFENCE.INVAL.IR\ninstruction guarantees that any previous SINVAL.VMA instructions executed\nby the current hart are ordered before subsequent implicit references by\nthat hart to the memory-management data structures.",
    "norm:Svinval_sequence_rs1_rs2": "the values of rs1 and rs2 for the SFENCE.VMA are the same as those\nused in the SINVAL.VMA,",
    "norm:Svinval_sequence_reads_writes_before": "reads and writes prior to the SFENCE.W.INVAL are considered to be\nthose prior to the SFENCE.VMA,",
    "norm:Svinval_sequence_reads_writes_after": "reads and writes following the SFENCE.INVAL.IR are considered to be\nthose subsequent to the SFENCE.VMA.",
    "norm:Svinval_hinval_vvma_gvma": "These have the same semantics as SINVAL.VMA, except that they combine with\nSFENCE.W.INVAL and SFENCE.INVAL.IR to replace HFENCE.VVMA and\nHFENCE.GVMA, respectively, instead of SFENCE.VMA.",
    "norm:Svinval_hinval_gvma_uses_vmid": "HINVAL.GVMA uses VMIDs instead of ASIDs.",
    "norm:Svinval_illegal_instruction_u_mode": "In particular, an attempt to execute any of\nthese instructions in U-mode always raises an illegal-instruction\nexception.",
    "norm:Svinval_illegal_instruction_tvm": "An attempt to execute SINVAL.VMA or HINVAL.GVMA in S-mode or HS-mode when\nmstatus.TVM=1 also raises an illegal-instruction exception.",
    "norm:Svinval_virtual_instruction_vu_vs": "An attempt to execute HINVAL.VVMA or HINVAL.GVMA in VS-mode or VU-mode, or to\nexecute SINVAL.VMA in VU-mode, raises a virtual-instruction exception.",
    "norm:Svinval_virtual_instruction_vtvms": "When hstatus.VTVM=1, an attempt to execute SINVAL.VMA in VS-mode also raises\na virtual-instruction exception.",
    "norm:Svinval_sfence_w_inval_inval_u_mode": "raises an illegal-instruction exception.",
    "norm:Svinval_sfence_w_inval_inval_vu_mode": "Doing so in VU-mode raises a virtual-instruction exception.",
    "norm:Svinval_sfence_w_inval_inval_s_vs_mode": "SFENCE.W.INVAL and SFENCE.INVAL.IR are unaffected by the mstatus.TVM and\nhstatus.VTVM fields and hence are always permitted in S-mode and VS-mode.",
    "norm:Svadu_hw_update_a_d_bits": "If the Svadu extension is implemented, the menvcfg.ADUE field is writable.",
    "norm:Svadu_hypervisor_adue_writable": "If the hypervisor extension is additionally implemented, the henvcfg.ADUE\nfield is also writable.",
    "norm:Svadu_disabled_hw_update_falls_back_to_svade": "When hardware updating of A/D bits is disabled, the Svade extension,\nwhich mandates exceptions when A/D bits need be set, instead takes effect.",
    "norm:Svvptc_explicit_stores_update_valid_bit": "When the Svvptc extension is implemented, explicit stores by a hart that update\nthe Valid bit of leaf and/or non-leaf PTEs from 0 to 1 and are visible to a hart\nwill eventually become visible within a bounded timeframe to subsequent implicit\naccesses by that hart to such PTEs.",
    "norm:Svrsw60t59b_reserved_bits_60_59": "If the Svrsw60t59b extension is implemented, then bits 60-59 of the page table\nentries (PTEs) are reserved for use by supervisor software and are ignored by\nthe implementation.",
    "norm:Svrsw60t59b_h_g_stage_reserved_bits": "If the Hypervisor (H) extension is also implemented, then bits 60-59 of the\nG-stage PTEs are reserved for use by supervisor software and are ignored by\nthe implementation.",
    "norm:Svrsw60t59b_depends_on_sv39": "The Svrsw60t59b extension depends on Sv39.",
    "norm:Ssqosid_shared_resource_need_management": "When multiple workloads execute concurrently on modern processors—equipped with\nlarge core counts, multiple cache hierarchies, and multiple memory controllers—\nthe performance of any given workload becomes less deterministic, or even\nnon-deterministic, due to shared resource contention.",
    "norm:Ssqosid_hw_monitoring_required": "To manage performance variability, system software needs resource allocation and\nmonitoring capabilities. These capabilities allow for the reservation of\nresources like cache and bandwidth, thus meeting individual performance\ntargets\nwhile minimizing interference.",
    "norm:Ssqosid_srmcfg_introduced": "To facilitate this, the QoS Identifiers extension (Ssqosid) introduces the\nsrmcfg register, which configures a hart with two identifiers: a Resource\nControl ID (RCID) and a Monitoring Counter ID (MCID). These identifiers\naccompany each request issued by the hart to shared resource controllers.",
    "norm:Ssqosid_metadata_used_by_controllers": "Additional metadata, like the nature of the memory access and the ID of the\noriginating supervisor domain, can accompany RCID and MCID. Resource\ncontrollers may use this metadata for differentiated service such as a different\ncapacity allocation for code storage vs. data storage. Resource controllers can\nuse this data for security policies such as not exposing statistics of one\nsecurity domain to another.",
    "norm:Ssqosid_cbqri_spec": "These identifiers are crucial for the RISC-V Capacity and Bandwidth Controller\nQoS Register Interface (CBQRI) specification, which provides methods for\nsetting resource usage limits and monitoring resource consumption. The RCID\ncontrols resource allocations, while the MCID is used for tracking resource\nusage.",
    "norm:Ssqosid_srmcfg_register_size": "The srmcfg register is an SXLEN-bit read/write register used to configure a\nResource Control ID (RCID) and a Monitoring Counter ID (MCID). Both RCID\nand MCID are WARL fields.",
    "norm:Ssqosid_rcid_mcid_accompany_requests": "The RCID and MCID accompany each request made by the hart to shared resource\ncontrollers. The RCID is used to determine the resource allocations (e.g.,\ncache occupancy limits, memory bandwidth limits, etc.) to enforce. The MCID\nis used to identify a counter to monitor resource usage.",
    "norm:Ssqosid_srmcfg_csr_applies_to_all_modes": "The RCID and MCID configured in the srmcfg CSR apply to all privilege\nmodes of software execution on that hart by default, but this behavior may be\noverridden by future extensions.",
    "norm:Ssqosid_smstateen_srmcfg_requires_mstateen0": "If extension Smstateen is implemented together with Ssqosid, then Ssqosid also\nrequires the SRMCFG bit in mstateen0 to be implemented.",
    "norm:Ssqosid_srmcfg_access_illegal_instruction": "If mstateen0.SRMCFG is 0, attempts to access srmcfg in privilege modes\nless privileged than M-mode raise an illegal-instruction exception.",
    "norm:Ssqosid_srmcfg_access_virtual_instruction": "If mstateen0.SRMCFG is 1 or if extension Smstateen is not implemented,\nattempts to access srmcfg when V=1 raise a virtual-instruction exception.",
    "norm:sstc_purpose": "This extension serves to provide supervisor mode with its own CSR-based timer\ninterrupt facility that it can directly manage to provide its own timer service\n(in the form of having its own stimecmp register) - thus eliminating the large\noverheads for emulating S/HS-mode timers and timer interrupt generation up in\nM-mode.",
    "norm:sstc_vs_facility": "Further, this extension adds a similar facility to the Hypervisor\nextension for VS-mode.",
    "norm:stimecmp_exist": "This extension adds the S-level stimecmp\nCSR (&lt;&lt;stimecmp&gt;&gt;)",
    "norm:vstimecmp_exist": "and the VS-level vstimecmp CSR (&lt;&lt;vstimecmp&gt;&gt;).",
    "norm:stce_bit_exist": "This extension adds the STCE bit to the menvcfg\n(&lt;&lt;sec:menvcfg&gt;&gt;) and henvcfg\n(&lt;&lt;sec:henvcfg&gt;&gt;) CSRs.",
    "norm:mhpmevent-INH_op": "Each of the five xINH bits, when set, inhibit counting of events while in privilege mode x. All-zeroes for these bits results in counting of events in all modes.",
    "norm:mhpmevent-OF_op": "The OF bit is set when the corresponding hpmcounter overflows, and remains set\nuntil written by software.",
    "norm:hpmcounter_overflow": "Since hpmcounter values are unsigned values,\noverflow is defined as unsigned overflow of the implemented counter bits.",
    "norm:count_overflow_interrupt": "If an hpmcounter overflows while the associated OF bit is zero, then a \"count overflow interrupt request\" is generated. If the OF bit is one, then no interrupt request is generated. Consequently the OF bit also functions as a count overflow interrupt disable for the associated hpmcounter.",
    "norm:count_overflow_trigger": "Count overflow never results from writes to the mhpmcountern or mhpmeventn registers, only from hardware increments of counter registers.",
    "norm:mhpmevent-OF_bit_Set": "Generation of a count-overflow-interrupt request by an hpmcounter sets the\nassociated OF bit.",
    "norm:LCOFIP_op": "When an OF bit is set, it eventually, but not necessarily immediately, sets\nthe LCOFIP bit in the mip/sip registers.",
    "norm:scountovf_op": "This extension adds the scountovf CSR, a 32-bit read-only register that contains shadow copies of the OF bits in the 29 mhpmevent CSRs (mhpmevent3 - mhpmevent31) - where scountovf bit X corresponds to mhpmeventX.",
    "norm:scountovf_smode_read_access_control": "Read access to bit X is subject to the same mcounteren (or mcounteren and\nhcounteren) CSRs that mediate access to the hpmcounter CSRs by S-mode (or\nVS-mode).",
    "norm:scountovf_mmode_read_access": "In M-mode, scountovf bit X is always readable.",
    "norm:scountovf_smode_read_access": "In S/HS-mode, scountovf bit X is readable when mcounteren bit\nX is set, and otherwise reads as zero.",
    "norm:scountovf_vsmode_read_access": "Similarly, in VS mode, scountovf bit\nX is readable when mcounteren bit X and hcounteren bit X are both set,\nand otherwise reads as zero.",
    "norm:H_mtval_nrz": "CSR mtval must not be read-only zero",
    "norm:H_vm_supported": "standard\npage-based address translation must be supported, either Sv32 for RV32,\nor a minimum of Sv39 for RV64",
    "norm:misa-h_op": "The hypervisor extension is enabled by setting bit 7 in the misa CSR",
    "norm:H_csrs_hs_not_vs": "Additional CSRs are provided to HS-mode, but not to VS-mode,\nto manage two-stage address translation and to control the behavior of a\nVS-mode guest: hstatus, hedeleg, hideleg, hvip, hip, hie,\nhgeip, hgeie, henvcfg, henvcfgh, hcounteren, htimedelta,\nhtimedeltah, htval, htinst, and hgatp.",
    "norm:H_vscsrs_sub": "When V=1, the VS CSRs substitute for the corresponding supervisor CSRs,\ntaking over all functions of the usual supervisor CSRs except as\nspecified otherwise. Instructions that normally read or modify a\nsupervisor CSR shall instead access the corresponding VS CSR.",
    "norm:H_vscsrs_acc_vs": "When V=1,\nan attempt to read or write a VS CSR directly by its own separate CSR\naddress causes a virtual-instruction exception.",
    "norm:H_vscsrs_acc_u": "Attempts from U-mode\ncause an illegal-instruction exception as usual.",
    "norm:H_vscsrs_acc_m_hs": "The VS CSRs can be\naccessed as themselves only from M-mode or HS-mode.",
    "norm:H_vscsrs_v1": "While V=1, the normal HS-level supervisor CSRs that are replaced by VS\nCSRs retain their values but do not affect the behavior of the machine\nunless specifically documented to do so.",
    "norm:H_vscsrs_v0": "when V=0, the VS\nCSRs do not ordinarily affect the behavior of the machine other than\nbeing readable and writable by CSR instructions.",
    "norm:H_scsrs_nomatch": "Some standard supervisor CSRs (senvcfg, scounteren, and scontext, possibly others) have no matching VS CSR. These supervisor CSRs continue to have their usual function and accessibility even when V=1, except with VS-mode and VU-mode substituting for HS-mode and U-mode. Hypervisor software is expected to manually swap the contents of these registers as needed.",
    "norm:hsxlen": "we use the term HSXLEN to refer to the effective XLEN\nwhen executing in HS-mode",
    "norm:vsxlen": "VSXLEN to refer to the effective XLEN\nwhen executing in VS-mode.",
    "norm:hstatus_sz_acc_op": "The hstatus register is an HSXLEN-bit read/write register formatted as shown in  when HSXLEN=32 and  when HSXLEN=64. The hstatus register provides facilities analogous to the mstatus register for tracking and controlling the exception behavior of a VS-mode guest.",
    "norm:hstatus-vsxl_op": "The VSXL field controls the effective XLEN for VS-mode (known as\nVSXLEN), which may differ from the XLEN for HS-mode (HSXLEN).",
    "norm:hstatus-vsxl_32": "When\nHSXLEN=32, the VSXL field does not exist, and VSXLEN=32.",
    "norm:hstatus_vsxl_64": "When HSXLEN=64,\nVSXL is a WARL field that is encoded the same as the MXL field of misa,\nshown in &lt;&lt;norm:misa_mxl_enc&gt;&gt;.",
    "norm:vsxl_ro": "In particular, an\nimplementation may make VSXL be a read-only field whose value always\nensures that VSXLEN=HSXLEN.",
    "norm:hstatus-vsxl_change": "If HSXLEN is changed from 32 to a wider width, and if field VSXL is not restricted to a single value, it gets the value corresponding to the widest supported width not wider than the new HSXLEN.",
    "norm:hstatus-vtsr_op": "When VTSR=1, an attempt in VS-mode to execute SRET raises a\nvirtual-instruction exception.",
    "norm:hstatus-vtw_op": "When VTW=1 (and assuming mstatus.TW=0),\nan attempt in VS-mode to execute WFI raises a virtual-instruction\nexception if the WFI does not complete within an\nimplementation-specific, bounded time limit.",
    "norm:vtw_virtinstr": "An implementation may have\nWFI always raise a virtual-instruction exception in VS-mode when VTW=1\n(and mstatus.TW=0), even if there are pending globally-disabled\ninterrupts when the instruction is executed.",
    "norm:hstatus-vtvm_op": "When VTVM=1, an attempt in\nVS-mode to execute SFENCE.VMA or SINVAL.VMA or to access CSR satp\nraises a virtual-instruction exception.",
    "norm:hstatus_vgein_op": "The VGEIN (Virtual Guest External Interrupt Number) field selects a guest external interrupt source for VS-level external interrupts. VGEIN is a WLRL field that must be able to hold values between zero and the maximum guest external interrupt number (known as GEILEN), inclusive. When VGEIN=0, no guest external interrupt source is selected for VS-level external interrupts. GEILEN may be zero, in which case VGEIN may be read-only zero. Guest external interrupts are explained in , and the use of VGEIN is covered further in .",
    "norm:hstatus-hu_op": "Field HU (Hypervisor in U-mode) controls whether the virtual-machine load/store instructions, HLV, HLVX, and HSV, can be used also in U-mode. When HU=1, these instructions can be executed in U-mode the same as in HS-mode. When HU=0, all hypervisor instructions cause an illegal-instruction exception in U-mode.",
    "norm:hstatus-spv_op": "The SPV bit (Supervisor Previous Virtualization mode) is written by the\nimplementation whenever a trap is taken into HS-mode. Just as the SPP\nbit in sstatus is set to the (nominal) privilege mode at the time of\nthe trap, the SPV bit in hstatus is set to the value of the\nvirtualization mode V at the time of the trap.",
    "norm:hstatus-spv_sret": "When an SRET instruction\nis executed when V=0, V is set to SPV.",
    "norm:hstatus-spvp_op": "When V=1 and a trap is taken into HS-mode, bit SPVP (Supervisor Previous Virtual Privilege) is set to the nominal privilege mode at the time of the trap, the same as sstatus.SPP. But if V=0 before a trap, SPVP is left unchanged on trap entry. SPVP controls the effective privilege of explicit memory accesses made by the virtual-machine load/store instructions, HLV, HLVX, and HSV.",
    "norm:hstatus-gva_op": "Field GVA (Guest Virtual Address) is written by the implementation whenever a trap is taken into HS-mode. For any trap (breakpoint, address misaligned, access fault, page fault, or guest-page fault) that writes a guest virtual address to stval, GVA is set to 1. For any other trap into HS-mode, GVA is set to 0.",
    "norm:hstatus_vsbe_op": "The VSBE bit is a WARL field that controls the endianness of explicit memory accesses made from VS-mode. If VSBE=0, explicit load and store memory accesses made from VS-mode are little-endian, and if VSBE=1, they are big-endian. VSBE also controls the endianness of all implicit accesses to VS-level memory management data structures, such as page tables. An implementation may make VSBE a read-only field that always specifies the same endianness as HS-mode.",
    "norm:hedeleg_sz_acc": "Register hedeleg is a 64-bit read/write register, formatted as shown in\n&lt;&lt;hedelegreg&gt;&gt;.",
    "norm:hideleg_sz_acc": "Register hideleg is an HSXLEN-bit read/write register, formatted as shown in\n&lt;&lt;hidelegreg&gt;&gt;.",
    "norm:hedeleg_op": "A synchronous trap that has been delegated to HS-mode (using medeleg)\nis further delegated to VS-mode if V=1 before the trap and the\ncorresponding hedeleg bit is set.",
    "norm:hdeleg_acc": "Each bit of hedeleg shall be\neither writable or read-only zero. Many bits of hedeleg are required\nspecifically to be writable or zero, as enumerated in\n&lt;&lt;hedeleg-bits&gt;&gt;. Bit 0, corresponding to\ninstruction address-misaligned exceptions, must be writable if\nIALIGN=32.",
    "norm:hedelegh_sz_acc_op": "When XLEN=32, hedelegh is a 32-bit read/write register that aliases bits 63:32 of hedeleg. Register hedelegh does not exist when XLEN=64.",
    "norm:hideleg_op": "An interrupt that has been delegated to HS-mode (using mideleg) is\nfurther delegated to VS-mode if the corresponding hideleg bit is set.",
    "norm:hideleg_acc": "Among bits 15:0 of hideleg, bits 10, 6, and 2 (corresponding to the\nstandard VS-level interrupts) are writable, and bits 12, 9, 5, and 1\n(corresponding to the standard S-level interrupts) are read-only zeros.",
    "norm:hideleg_trans": "When a virtual supervisor external interrupt (code 10) is delegated to VS-mode, it is automatically translated by the machine into a supervisor external interrupt (code 9) for VS-mode, including the value written to vscause on an interrupt trap. Likewise, a virtual supervisor timer interrupt (6) is translated into a supervisor timer interrupt (5) for VS-mode, and a virtual supervisor software interrupt (2) is translated into a supervisor software interrupt (1) for VS-mode. Similar translations may or may not be done for platform interrupt causes (codes 16 and above).",
    "norm:hvip_sz_op": "Register hvip is an HSXLEN-bit read/write register that a hypervisor can write to indicate virtual interrupts intended for VS-mode. Bits of hvip that are not writable are read-only zeros.",
    "norm:hvip_acc": "The standard portion (bits 15:0) of hvip is formatted as shown in . Bits VSEIP, VSTIP, and VSSIP of hvip are writable. Setting VSEIP=1 in hvip asserts a VS-level external interrupt; setting VSTIP asserts a VS-level timer interrupt; and setting VSSIP asserts a VS-level software interrupt.",
    "norm:hip_hie_sz_acc": "Registers hip and hie are HSXLEN-bit read/write registers that\nsupplement HS-level’s sip and sie respectively.",
    "norm:hip_op": "The hip register\nindicates pending VS-level and hypervisor-specific interrupts",
    "norm:hie_op": "hie contains enable bits for the same interrupts",
    "norm:sie_hip_hie_mutex": "For each writable bit in sie, the corresponding bit shall be read-only zero in both hip and hie. Hence, the nonzero bits in sie and hie are always mutually exclusive, and likewise for sip and hip.",
    "norm:hideleg_hs": "An interrupt i will trap to HS-mode whenever all of the following are true: (a) either the current operating mode is HS-mode and the SIE bit in the sstatus register is set, or the current operating mode has less privilege than HS-mode; (b) bit i is set in both sip and sie, or in both hip and hie; and (c) bit i is not set in hideleg.",
    "norm:hip_acc": "If bit i of sie is read-only zero, the same bit in register hip may be writable or may be read-only. When bit i in hip is writable, a pending interrupt i can be cleared by writing 0 to this bit. If interrupt i can become pending in hip but bit i in hip is read-only, then either the interrupt can be cleared by clearing bit i of hvip, or the implementation must provide some other mechanism for clearing the pending interrupt (which may involve a call to the execution environment).",
    "norm:hie_acc": "A bit in hie shall be writable if the corresponding interrupt can ever become pending in hip. Bits of hie that are not writable shall be read-only zero.",
    "norm:hip_sgeip_sgeie_acc_op": "Bits hip.SGEIP and hie.SGEIE are the interrupt-pending and interrupt-enable bits for guest external interrupts at supervisor level (HS-level). SGEIP is read-only in hip, and is 1 if and only if the bitwise logical-AND of CSRs hgeip and hgeie is nonzero in any bit. (See .)",
    "norm:hip_vseip_vseie_op": "Bits hip.VSEIP and hie.VSEIE are the interrupt-pending and interrupt-enable bits for VS-level external interrupts. VSEIP is read-only in hip, and is the logical-OR of these interrupt sources:",
    "norm:hip_vstip_vstie_acc_op": "Bits hip.VSTIP and hie.VSTIE are the interrupt-pending and interrupt-enable bits for VS-level timer interrupts. VSTIP is read-only in hip, and is the logical-OR of hvip.VSTIP and, when the Sstc extension is implemented, the timer interrupt signal resulting from vstimecmp. The hip.VSTIP bit, in response to timer interrupts generated by vstimecmp, is set by writing vstimecmp with a value that is less than or equal to the sum of time and htimedelta, truncated to 64 bits; it is cleared by writing vstimecmp with a greater value. The hip.VSTIP bit remains defined while V=0 as well as V=1.",
    "norm:hip_vssip_vssie_op": "Bits hip.VSSIP and hie.VSSIE are the interrupt-pending and interrupt-enable bits for VS-level software interrupts. VSSIP in hip is an alias (writable) of the same bit in hvip.",
    "norm:hsint_priority": "Multiple simultaneous interrupts destined for HS-mode are handled in the following decreasing priority order: SEI, SSI, STI, SGEI, VSEI, VSSI, VSTI, LCOFI.",
    "norm:hgeip_sz_acc_op": "The hgeip register is an HSXLEN-bit read-only register, formatted as\nshown in &lt;&lt;hgeipreg&gt;&gt;, that indicates pending guest\nexternal interrupts for this hart.",
    "norm:hgeie_sz_acc_op": "The hgeie register is an HSXLEN-bit\nread/write register, formatted as shown in\n&lt;&lt;hgeiereg&gt;&gt;, that contains enable bits for the\nguest external interrupts at this hart.",
    "norm:hgeip_hgeie_fields": "Guest external interrupt number\ni corresponds with bit i in both hgeip and hgeie.",
    "norm:geilen": "The number of bits implemented in hgeip and hgeie for guest external interrupts is UNSPECIFIED and may be zero. This number is known as GEILEN. The least-significant bits are implemented first, apart from bit 0. Hence, if GEILEN is nonzero, bits GEILEN:1 shall be writable in hgeie, and all other bit positions shall be read-only zeros in both hgeip and hgeie.",
    "norm:hgeie_op": "Register hgeie selects the subset of guest external interrupts that cause a supervisor-level (HS-level) guest external interrupt. The enable bits in hgeie do not affect the VS-level external interrupt signal selected from hgeip by hstatus.VGEIN.",
    "norm:henvcfg_sz_acc_op": "The henvcfg CSR is a 64-bit read/write register, formatted as shown in , that controls certain characteristics of the execution environment when virtualization mode V=1.",
    "norm:henvcfg-fiom_op": "If bit FIOM (Fence of I/O implies Memory) is set to one in henvcfg, FENCE instructions executed when V=1 are modified so the requirement to order accesses to device I/O implies also the requirement to order main memory accesses.  details the modified interpretation of FENCE instruction bits PI, PO, SI, and SO when FIOM=1 and V=1.",
    "norm:henvcfg-fiom_order": "Similarly, when FIOM=1 and V=1, if an atomic instruction that accesses a region ordered as device I/O has its aq and/or rl bit set, then that instruction is ordered as though it accesses both device I/O and memory.",
    "norm:henvcfg-pbmte_op": "The PBMTE bit controls whether the Svpbmt extension is available for use in VS-stage address translation. When PBMTE=1, Svpbmt is available for VS-stage address translation. When PBMTE=0, the implementation behaves as though Svpbmt were not implemented for VS-stage address translation. If Svpbmt is not implemented, PBMTE is read-only zero.",
    "norm:henvcfg-adue_op": "If the Svadu extension is implemented, the ADUE bit controls whether hardware updating of PTE A/D bits is enabled for VS-stage address translation. When ADUE=1, hardware updating of PTE A/D bits is enabled during VS-stage address translation, and the implementation behaves as though the Svade extension were not implemented for VS-mode address translation. When ADUE=0, the implementation behaves as though Svade were implemented for VS-stage address translation. If Svadu is not implemented, ADUE is read-only zero.",
    "norm:henvcfg-stce": "The Sstc extension adds the STCE (STimecmp Enable) bit to henvcfg CSR. When the Sstc extension is not implemented, STCE is read-only zero. The STCE bit enables vstimecmp for VS-mode when set to one. When STCE bit is henvcfg is zero, an attempt to access stimecmp (really vstimecmp) when V=1 raises a virtual-instruction exception, and VSTIP in hip reverts to its defined behavior as if this extension is not implemented.",
    "norm:henvcfg-cbze": "The Zicboz extension adds the CBZE (Cache Block Zero instruction enable) field to henvcfg. The CBZE field applies to execution of the cache block zero instruction (CBO.ZERO) in privilege modes VS and VU, and only when the instruction is HS-qualified. If the instruction is not HS-qualified, it raises an illegal-instruction exception. If the instruction is HS-qualified and the CBZE field is set to 1, the instruction is enabled for execution; otherwise, if the CBZE field is set to 0, it raises a virtual-instruction exception. When the Zicboz extension is not implemented, CBZE is read-only zero.",
    "norm:henvcfg-cbcfe": "The Zicbom extension adds the CBCFE (Cache Block Clean and Flush instruction Enable) field to henvcfg. When V=1, if the CBO.CLEAN and CBO.FLUSH instructions are not HS-qualified, they raise an illegal-instruction exception. If the instructions are HS-qualified and the CBCFE field is set to 1, the instructions are enabled for execution; otherwise, if the CBCFE field is set to 0, they raise a virtual-instruction exception. When the Zicbom extension is not implemented, CBCFE is read-only zero.",
    "norm:henvcfg_cbie": "The Zicbom extension adds the CBIE (Cache Block Invalidate instruction Enable) WARL field to henvcfg. The CBIE field controls execution of the cache block invalidate instruction (CBO.INVAL) in privilege modes VS and VU. The encoding 10b is reserved. When the Zicbom extension is not implemented, CBIE is read-only zero.",
    "norm:cbo-inval_h-mode_veq1_op": "When V=1, if the CBO.INVAL instruction is not HS-qualified, it raises an illegal-instruction exception. If the instruction is HS-qualified and the CBIE field is set to 01b or 11b, the instruction is enabled for execution; otherwise, it raises a virtual-instruction exception.",
    "norm:cbo-inval_h-mode_op0": "If CBO.INVAL is enabled in HS-mode to perform a flush operation, then when the\ninstruction is enabled in VS- or VU-mode it performs a flush operation, even if\nCBIE is set to 11b. Otherwise, when the instruction is enabled for\nexecution, its behavior depends on the CBIE encoding, as follows:",
    "norm:cbo-inval_h-mode_op1": "",
    "norm:cbo-inval_h-mode_op2": "",
    "norm:henvcfg-pmm_op": "If the Ssnpm extension is implemented, the PMM field enables or disables pointer masking (see ) for VS-mode, according to the values in . When the Ssnpm extension is not implemented, the PMM field is read-only zero. The PMM field is read-only zero for RV32.",
    "norm:henvcfg-lpe_op": "The Zicfilp extension adds the LPE field in henvcfg. When the LPE field is set to 1, the Zicfilp extension is enabled in VS-mode. When the LPE field is 0, the Zicfilp extension is not enabled in VS-mode and the following rules apply to VS-mode:",
    "norm:henvcfg-sse_op": "The Zicfiss extension adds the SSE field in henvcfg. If the SSE field is set to 1, the Zicfiss extension is activated in VS-mode. When the SSE field is 0, the Zicfiss extension remains inactive in VS-mode, and the following rules apply when V=1:",
    "norm:henvcfg-dte_op": "The Ssdbltrp extension adds the double-trap-enable (DTE) field in henvcfg. When henvcfg.DTE is zero, the implementation behaves as though Ssdbltrp is not implemented for VS-mode and the vsstatus.SDT bit is read-only zero.",
    "norm:henvcfgh_sz_acc_op": "When XLEN=32, henvcfgh is a 32-bit read/write register that aliases bits 63:32 of henvcfg. Register henvcfgh does not exist when XLEN=64.",
    "norm:hcounteren_sz": "The counter-enable register hcounteren is a 32-bit register that controls the availability of the hardware performance monitoring counters to the guest virtual machine.",
    "norm:hcounteren_op": "When the CY, TM, IR, or HPMn bit in the hcounteren register is clear, attempts to read the cycle, time, instret, or hpmcounter n register while V=1 will cause a virtual-instruction exception if the same bit in mcounteren is 1. When one of these bits is set, access to the corresponding register is permitted when V=1, unless prevented for some other reason. In VU-mode, a counter is not readable unless the applicable bits are set in both hcounteren and scounteren.",
    "norm:hcounteren_acc": "In addition, when the TM bit in the hcounteren register is clear, attempts to access the vstimecmp register (via stimecmp) while executing in VS-mode will cause a virtual-instruction exception if the same bit in mcounteren is set. When this bit and the same bit in mcounteren are both set, access to the vstimecmp register (if implemented) is permitted in VS-mode.",
    "norm:hcounteren_warl": "hcounteren must be implemented. However, any of the bits may be read-only zero, indicating reads to the corresponding counter will cause an exception when V=1. Hence, they are effectively WARL fields.",
    "norm:htimedelta_sz_acc_op": "The htimedelta CSR is a 64-bit read/write register\nthat contains the delta\nbetween the value of the time CSR and the value returned in VS-mode or\nVU-mode. That is, reading the time CSR in VS or VU mode returns the\nsum of the contents of htimedelta and the actual value of time.",
    "norm:htimedeltah_sz_acc_op": "When XLEN=32, htimedeltah is a 32-bit read/write register that aliases bits 63:32 of htimedelta. Register htimedeltah does not exist when XLEN=64.",
    "norm:time_htimedelta_req": "If the time CSR is implemented, htimedelta (and htimedeltah for XLEN=32) must be implemented.",
    "norm:htval_sz_acc_op": "The htval register is an HSXLEN-bit read/write register formatted as shown in . When a trap is taken into HS-mode, htval is written with additional exception-specific information, alongside stval, to assist software in handling the trap.",
    "norm:htval_trapval": "When a guest-page-fault trap is taken into HS-mode, htval is written with either zero or the guest physical address that faulted, shifted right by 2 bits. For other traps, htval is set to zero, but a future standard or extension may redefine htval&#8217;s setting for other traps.",
    "norm:htval_val": "htval is a WARL register that must be able to hold zero and may be capable of holding only an arbitrary subset of other 2-bit-shifted guest physical addresses, if any.",
    "norm:htinst_sz_acc_op": "The htinst register is an HSXLEN-bit read/write register formatted as shown in . When a trap is taken into HS-mode, htinst is written with a value that, if nonzero, provides information about the instruction that trapped, to assist software in handling the trap. The values that may be written to htinst on a trap are documented in .",
    "norm:htinst_val": "htinst is a WARL register that need only be able to hold the values that the implementation may automatically write to it on a trap.",
    "norm:hgatp_sz_acc_op": "The hgatp register is an HSXLEN-bit read/write register, formatted as\nshown in &lt;&lt;rv32hgatp&gt;&gt; for HSXLEN=32 and\n&lt;&lt;rv64hgatp&gt;&gt; for HSXLEN=64, which controls\nG-stage address translation and protection, the second stage of\ntwo-stage translation for guest virtual addresses (see\n&lt;&lt;two-stage-translation&gt;&gt;).",
    "norm:hgatp_tvm_illegal": "When mstatus.TVM=1, attempts to read or write hgatp while\nexecuting in HS-mode will raise an illegal-instruction exception.",
    "norm:hgatp-mode_bare": "&lt;&lt;hgatp-mode&gt;&gt; shows the encodings of the MODE field when\nHSXLEN=32 and HSXLEN=64. When MODE=Bare, guest physical addresses are\nequal to supervisor physical addresses, and there is no further memory\nprotection for a guest virtual machine beyond the physical memory\nprotection scheme described in &lt;&lt;pmp&gt;&gt;. In this\ncase, software must write zero to the remaining fields in hgatp.",
    "norm:hgatp-mode_sv": "When HSXLEN=32, the only other valid setting for MODE is Sv32x4, which is a modification of the usual Sv32 paged virtual-memory scheme, extended to support 34-bit guest physical addresses. When HSXLEN=64, modes Sv39x4, Sv48x4, and Sv57x4 are defined as modifications of the Sv39, Sv48, and Sv57 paged virtual-memory schemes. All of these paged virtual-memory schemes are described in .",
    "norm:hgatp_mode_warl": "A write to hgatp with an unsupported MODE value is not ignored as it is for satp. Instead, the fields of hgatp are WARL in the normal way, when so indicated.",
    "norm:hgatp-ppn_op": "As explained in , for the paged virtual-memory schemes (Sv32x4, Sv39x4, Sv48x4, and Sv57x4), the root page table is 16 KiB and must be aligned to a 16-KiB boundary. In these modes, the lowest two bits of the physical page number (PPN) in hgatp always read as zeros. An implementation that supports only the defined paged virtual-memory schemes and/or Bare may make PPN[1:0] read-only zero.",
    "norm:hgatp_vmid": "The number of VMID bits is UNSPECIFIED and may be zero.",
    "norm:hgatp_vmid_lsbs": "The\nleast-significant bits of VMID are implemented first: that is, if\nVMIDLEN &gt; 0, VMID[VMIDLEN-1:0] is writable. The maximal\nvalue of VMIDLEN, termed VMIDMAX, is 7 for Sv32x4 or 14 for Sv39x4,\nSv48x4, and Sv57x4.",
    "norm:vsstatus_sz_acc_op": "The vsstatus register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register sstatus, formatted as shown in  when VSXLEN=32 and  when VSXLEN=64. When V=1, vsstatus substitutes for the usual sstatus, so instructions that normally read or modify sstatus actually access vsstatus instead.",
    "norm:vsstatus_uxl_op": "The UXL field controls the effective XLEN for VU-mode, which may differ from the XLEN for VS-mode (VSXLEN). When VSXLEN=32, the UXL field does not exist, and VU-mode XLEN=32. When VSXLEN=64, UXL is a WARL field that is encoded the same as the MXL field of misa, shown in . In particular, an implementation may make UXL be a read-only copy of field VSXL of hstatus, forcing VU-mode XLEN=VSXLEN.",
    "norm:vsstatus-uxl_change": "If VSXLEN is changed from 32 to a wider width, and if field UXL is not restricted to a single value, it gets the value corresponding to the widest supported width not wider than the new VSXLEN.",
    "norm:vsstatus-fs_op": "When V=1, both vsstatus.FS and the HS-level sstatus.FS are in effect. Attempts to execute a floating-point instruction when either field is 0 (Off) raise an illegal-instruction exception. Modifying the floating-point state when V=1 causes both fields to be set to 3 (Dirty).",
    "norm:vsstatus-vs_op": "Similarly, when V=1, both vsstatus.VS and the HS-level sstatus.VS are in effect. Attempts to execute a vector instruction when either field is 0 (Off) raise an illegal-instruction exception. Modifying the vector state when V=1 causes both fields to be set to 3 (Dirty).",
    "norm:vsstatus-sd_xs_op": "Read-only fields SD and XS summarize the extension context status as it is visible to VS-mode only. For example, the value of the HS-level sstatus.FS does not affect vsstatus.SD.",
    "norm:vsstatus_ube": "An implementation may make field UBE be a read-only copy of hstatus.VSBE.",
    "norm:vsstatus_v0": "When V=0, vsstatus does not directly affect the behavior of the machine, unless a virtual-machine load/store (HLV, HLVX, or HSV) or the MPRV feature in the mstatus register is used to execute a load or store as though V=1.",
    "norm:vsstatus-spelp_op": "The Zicfilp extension adds the SPELP field that holds the previous ELP, and is updated as specified in . The SPELP field is encoded as follows:",
    "norm:vsstatus-sdt_op": "The Ssdbltrp adds an S-mode-disable-trap (SDT) field extension to address double trap (See ) in VS-mode.",
    "norm:vsip_vsie_sz_acc_op": "The vsip and vsie registers are VSXLEN-bit read/write registers that are VS-mode’s versions of supervisor CSRs sip and sie, formatted as shown in  and  respectively. When V=1, vsip and vsie substitute for the usual sip and sie, so instructions that normally read or modify sip/sie actually access vsip/vsie instead. However, interrupts directed to HS-level continue to be indicated in the HS-level sip register, not in vsip, when V=1.",
    "norm:vsip_vsie-lcofi": "Extension Shlcofideleg supports delegating LCOFI interrupts to VS-mode. If the Shlcofideleg extension is implemented, hideleg bit 13 is writable; otherwise, it is read-only zero. When bit 13 of hideleg is zero, vsip.LCOFIP and vsie.LCOFIE are read-only zeros. Else, vsip.LCOFIP and vsie.LCOFIE are aliases of sip.LCOFIP and sie.LCOFIE.",
    "norm:vsip_vsie-sei": "When bit 10 of hideleg is zero, vsip.SEIP and vsie.SEIE are read-only zeros. Else, vsip.SEIP and vsie.SEIE are aliases of hip.VSEIP and hie.VSEIE.",
    "norm:vsip_vsie-sti": "When bit 6 of hideleg is zero, vsip.STIP and vsie.STIE are read-only zeros. Else, vsip.STIP and vsie.STIE are aliases of hip.VSTIP and hie.VSTIE.",
    "norm:vsip_vsie-ssi": "When bit 2 of hideleg is zero, vsip.SSIP and vsie.SSIE are read-only zeros. Else, vsip.SSIP and vsie.SSIE are aliases of hip.VSSIP and hie.VSSIE.",
    "norm:vstvec_sz_acc_op": "The vstvec register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register stvec, formatted as shown in . When V=1, vstvec substitutes for the usual stvec, so instructions that normally read or modify stvec actually access vstvec instead. When V=0, vstvec does not directly affect the behavior of the machine.",
    "norm:vsscratch_sz_acc_op": "The vsscratch register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register sscratch, formatted as shown in . When V=1, vsscratch substitutes for the usual sscratch, so instructions that normally read or modify sscratch actually access vsscratch instead. The contents of vsscratch never directly affect the behavior of the machine.",
    "norm:vspec_sz_acc_op": "The vsepc register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register sepc, formatted as shown in . When V=1, vsepc substitutes for the usual sepc, so instructions that normally read or modify sepc actually access vsepc instead. When V=0, vsepc does not directly affect the behavior of the machine.",
    "norm:vsepc_warl": "vsepc is a WARL register that must be able to hold the same set of values that sepc can hold.",
    "norm:vscause_sz_acc_op": "The vscause register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register scause, formatted as shown in . When V=1, vscause substitutes for the usual scause, so instructions that normally read or modify scause actually access vscause instead. When V=0, vscause does not directly affect the behavior of the machine.",
    "norm:vscause_wlrl": "vscause is a WLRL register that must be able to hold the same set of values that scause can hold.",
    "norm:vstval_sz_acc_op": "The vstval register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register stval, formatted as shown in . When V=1, vstval substitutes for the usual stval, so instructions that normally read or modify stval actually access vstval instead. When V=0, vstval does not directly affect the behavior of the machine.",
    "norm:vstval_warl": "vstval is a WARL register that must be able to hold the same set of values that stval can hold.",
    "norm:vsatp_sz_acc_op": "The vsatp register is a VSXLEN-bit read/write register that is VS-mode’s version of supervisor register satp, formatted as shown in  for VSXLEN=32 and  for VSXLEN=64. When V=1, vsatp substitutes for the usual satp, so instructions that normally read or modify satp actually access vsatp instead. vsatp controls VS-stage address translation, the first stage of two-stage translation for guest virtual addresses (see ).",
    "norm:vs_stage_speculative_a_bit": "when vsatp is active, VS-stage\npage-table entries’ A bits must not be set as a result of speculative\nexecution, unless the effective privilege mode is VS or VU.",
    "norm:vsatp_mode_unsupported_v0": "When V=0, a write to vsatp with an unsupported MODE value is either\nignored as it is for satp, or the fields of vsatp are treated as WARL in\nthe normal way.",
    "norm:vsatp_mode_unsupported_v1": "However, when V=1, a write to satp with an unsupported\nMODE value is ignored and no write to vsatp is effected.",
    "norm:vsatp_v0": "When V=0, vsatp does not directly affect the behavior of the machine, unless a virtual-machine load/store (HLV, HLVX, or HSV) or the MPRV feature in the mstatus register is used to execute a load or store as though V=1.",
    "norm:vstimecmp_sz": "The vstimecmp CSR is a 64-bit register and has 64-bit precision on all RV32\nand RV64 systems.",
    "norm:vstimecmp_acc": "In RV32 only, accesses to the vstimecmp CSR access the low\n32 bits, while accesses to the vstimecmph CSR access the high 32 bits of\nvstimecmp.",
    "norm:hip-vstip_op": "A virtual supervisor timer interrupt becomes pending, as reflected in the\nVSTIP bit in the hip register, whenever (time + htimedelta), truncated\nto 64 bits, contains a value greater than or equal to vstimecmp, treating\nthe values as unsigned integers.",
    "norm:hip-vstip_clear": "If the result of this comparison changes, it is guaranteed to be reflected in\nVSTIP eventually, but not necessarily immediately.\nThe interrupt remains posted until vstimecmp becomes greater than (time\n+ htimedelta), typically as a result of writing vstimecmp.",
    "norm:hip-vstip_enable": "The interrupt will be taken based on the standard interrupt enable and\ndelegation rules while V=1.",
    "norm:hlsv_mode": "The hypervisor virtual-machine load and store instructions are valid\nonly in M-mode or HS-mode, or in U-mode when hstatus.HU=1.",
    "norm:hlsv_priv": "Each\ninstruction performs an explicit memory access with an effective privilege mode\nof VS or VU. The effective privilege mode of the explicit memory access is VU\nwhen hstatus.SPVP=0, and VS when hstatus.SPVP=1.",
    "norm:hlsv_trans": "As usual for VS-mode and\nVU-mode, two-stage address translation is applied, and\nthe HS-level sstatus.SUM is ignored.",
    "norm:hlsv_sstatus-mxr": "HS-level sstatus.MXR makes\nexecute-only pages readable by explicit loads for both stages of address translation\n(VS-stage and G-stage)",
    "norm:hlsv_vsstatus-mxr": "vsstatus.MXR affects only the first\ntranslation stage (VS-stage).",
    "norm:hlsv_op": "For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU, and LD, there is a corresponding virtual-machine load instruction: HLV.B, HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU, HLV.D, and HSV.D are not valid for RV32, of course.",
    "norm:hlsv_u_op": "Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU, except that execute permission takes the place of read permission during address translation. That is, the memory being read must be executable in both stages of address translation, but read permission is not required. For the supervisor physical address that results from address translation, the supervisor physical memory attributes must grant both execute and read permissions. (The supervisor physical memory attributes are the machine’s physical memory attributes as modified by physical memory protection, , for supervisor level.)",
    "norm:hlvx-wu_valid32": "HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For RV32, HLVX.WU can be considered a variant of HLV.W, as sign extension is irrelevant for 32-bit values.)",
    "norm:hlsv_virtinst": "Attempts to execute a virtual-machine load/store instruction (HLV, HLVX,\nor HSV) when V=1 cause a virtual-instruction exception.",
    "norm:hlsv_illegalinst": "Attempts to execute one of these same instructions from U-mode when hstatus.HU=0 cause an\nillegal-instruction exception.",
    "norm:hfence-vvma_hfence-gvma_op": "The hypervisor memory-management fence instructions, HFENCE.VVMA and HFENCE.GVMA, perform a function similar to SFENCE.VMA (), except applying to the VS-level memory-management data structures controlled by CSR vsatp (HFENCE.VVMA) or the guest-physical memory-management data structures controlled by CSR hgatp (HFENCE.GVMA). Instruction SFENCE.VMA applies only to the memory-management data structures controlled by the current satp (either the HS-level satp when V=0 or vsatp when V=1).",
    "norm:hfence-vvma_mode": "HFENCE.VVMA is valid only in M-mode or HS-mode. Its effect is much the same as temporarily entering VS-mode and executing SFENCE.VMA. Executing an HFENCE.VVMA guarantees that any previous stores already visible to the current hart are ordered before all implicit reads by that hart done for VS-stage address translation for instructions that",
    "norm:hfence-vvma_limits": "Implicit reads need not be ordered when hgatp.VMID is different than at the time HFENCE.VVMA executed. If operand rs1≠x0, it specifies a single guest virtual address, and if operand rs2≠x0, it specifies a single guest address-space identifier (ASID).",
    "norm:hfence-vvma_asid": "When rs2≠x0, bits XLEN-1:ASIDMAX of the value held in rs2 are reserved for future standard use. Until their use is defined by a standard extension, they should be zeroed by software and ignored by current implementations. Furthermore, if ASIDLEN &lt; ASIDMAX, the implementation shall ignore bits ASIDMAX-1:ASIDLEN of the value held in rs2.",
    "norm:hfence-vvma_tvm": "Neither mstatus.TVM nor hstatus.VTVM causes HFENCE.VVMA to trap.",
    "norm:hfence-gvma_op": "HFENCE.GVMA is valid only in HS-mode when mstatus.TVM=0, or in M-mode (irrespective of mstatus.TVM). Executing an HFENCE.GVMA instruction guarantees that any previous stores already visible to the current hart are ordered before all implicit reads by that hart done for G-stage address translation for instructions that follow the HFENCE.GVMA. If operand rs1≠x0, it specifies a single guest physical address, shifted right by 2 bits, and if operand rs2≠x0, it specifies a single virtual machine identifier (VMID).",
    "norm:hfence-gvma_vmid": "When rs2≠x0, bits XLEN-1:VMIDMAX of the value held in rs2 are reserved for future standard use. Until their use is defined by a standard extension, they should be zeroed by software and ignored by current implementations. Furthermore, if VMIDLEN &lt; VMIDMAX, the implementation shall ignore bits VMIDMAX-1:VMIDLEN of the value held in rs2.",
    "norm:hfence-gvma_mode": "If hgatp.MODE is changed for a given VMID, an HFENCE.GVMA with rs1=x0 (and rs2 set to either x0 or the VMID) must be executed to order subsequent guest translations with the MODE change—even if the old MODE or new MODE is Bare.",
    "norm:hfence-vvma_hfence-gvma_exceptions": "Attempts to execute HFENCE.VVMA or HFENCE.GVMA when V=1 cause a virtual-instruction exception, while attempts to do the same in U-mode cause an illegal-instruction exception. Attempting to execute HFENCE.GVMA in HS-mode when mstatus.TVM=1 also causes an illegal-instruction exception.",
    "norm:mstatus_mpv_op": "The MPV bit (Machine Previous Virtualization Mode) is written by the implementation whenever a trap is taken into M-mode. Just as the MPP field is set to the (nominal) privilege mode at the time of the trap, the MPV bit is set to the value of the virtualization mode V at the time of the trap. When an MRET instruction is executed, the virtualization mode V is set to MPV, unless MPP=3, in which case V remains 0.",
    "norm:mstatus_gva_op": "Field GVA (Guest Virtual Address) is written by the implementation whenever a trap is taken into M-mode. For any trap (breakpoint, address misaligned, access fault, page fault, or guest-page fault) that writes a guest virtual address to mtval, GVA is set to 1. For any other trap into M-mode, GVA is set to 0.",
    "norm:mstatus_modes": "The TSR and TVM fields of mstatus affect execution only in HS-mode, not in VS-mode. The TW field affects execution in all modes except M-mode.",
    "norm:mstatus_tvm_hs": "Setting TVM=1 prevents HS-mode from accessing hgatp or executing HFENCE.GVMA or HINVAL.GVMA, but has no effect on accesses to vsatp or instructions HFENCE.VVMA or HINVAL.VVMA.",
    "norm:mstatus_mprv_hypervisor": "The hypervisor extension changes the behavior of the Modify Privilege field, MPRV, of mstatus. When MPRV=0, translation and protection behave as normal. When MPRV=1, explicit memory accesses are translated and protected, and endianness is applied, as though the current virtualization mode were set to MPV and the current nominal privilege mode were set to MPP.  enumerates the cases.",
    "norm:mstatus_mprv_hlsv": "MPRV does not affect the virtual-machine load/store instructions, HLV, HLVX, and HSV. The explicit loads and stores of these instructions always act as though V=1 and the nominal privilege mode were hstatus.SPVP, overriding MPRV.",
    "norm:mideleg_acc_h": "When the hypervisor extension is implemented, bits 10, 6, and 2 of mideleg (corresponding to the standard VS-level interrupts) are each read-only one. Furthermore, if any guest external interrupts are implemented (GEILEN is nonzero), bit 12 of mideleg (corresponding to supervisor-level guest external interrupts) is also read-only one. VS-level interrupts and guest external interrupts are always delegated past M-mode to HS-mode.",
    "norm:mideleg_hroz": "For bits of mideleg that are zero, the corresponding bits in hideleg, hip, and hie are read-only zeros.",
    "norm:mip_mie_vs": "The hypervisor extension gives registers mip and mie additional active bits for the hypervisor-added interrupts.  and  show the standard portions (bits 15:0) of registers mip and mie when the hypervisor extension is implemented.",
    "norm:mip_mie_alias": "Bits SGEIP, VSEIP, VSTIP, and VSSIP in mip are aliases for the same bits in hypervisor CSR hip, while SGEIE, VSEIE, VSTIE, and VSSIE in mie are aliases for the same bits in hie.",
    "norm:mtval2_sz_acc_op": "The mtval2 register is an MXLEN-bit read/write register formatted as shown in . When a trap is taken into M-mode, mtval2 is written with additional exception-specific information, alongside mtval, to assist software in handling the trap.",
    "norm:mtval2_trapval": "When a guest-page-fault trap is taken into M-mode, mtval2 is written with either zero or the guest physical address that faulted, shifted right by 2 bits. For other traps, mtval2 is set to zero, but a future standard or extension may redefine mtval2&#8217;s setting for other traps.",
    "norm:mtval2_trapval_vstrans": "If a guest-page fault is due to an implicit memory access during first-stage (VS-stage) address translation, a guest physical address written to mtval2 is that of the implicit memory access that faulted. Additional information is provided in CSR mtinst to disambiguate such situations.",
    "norm:mtval2_trapval_other": "Otherwise, for misaligned loads and stores that cause guest-page faults, a nonzero guest physical address in mtval2 corresponds to the faulting portion of the access as indicated by the virtual address in mtval. For instruction guest-page faults on systems with variable-length instructions, a nonzero mtval2 corresponds to the faulting portion of the instruction as indicated by the virtual address in mtval.",
    "norm:mtval2_val": "mtval2 is a WARL register that must be able to hold zero and may be capable of holding only an arbitrary subset of other 2-bit-shifted guest physical addresses, if any.",
    "norm:mtval2_Ssdbltrap": "The Ssdbltrap extension (See ) requires the implementation of the mtval2 CSR.",
    "norm:mtinst_sz_acc_op": "The mtinst register is an MXLEN-bit read/write register formatted as shown in . When a trap is taken into M-mode, mtinst is written with a value that, if nonzero, provides information about the instruction that trapped, to assist software in handling the trap. The values that may be written to mtinst on a trap are documented in .",
    "norm:mtinst_val": "mtinst is a WARL register that need only be able to hold the values that the implementation may automatically write to it on a trap.",
    "norm:H_vm_twostage": "Whenever the current virtualization mode V is 1, two-stage address translation and protection is in effect. For any virtual memory access, the original virtual address is converted in the first stage by VS-level address translation, as controlled by the vsatp register, into a guest physical address. The guest physical address is then converted in the second stage by guest physical address translation, as controlled by the hgatp register, into a supervisor physical address. The two stages are known also as VS-stage and G-stage translation. Although there is no option to disable two-stage address translation when V=1, either stage of translation can be effectively disabled by zeroing the corresponding vsatp or hgatp register.",
    "norm:vsstatus-mxr_vm": "The vsstatus field MXR, which makes execute-only pages readable by explicit loads, only\noverrides VS-stage page protection. Setting MXR at VS-level does not\noverride guest-physical page protections.",
    "norm:sstatus-mxr_vm": "Setting MXR at HS-level,\nhowever, overrides both VS-stage and G-stage execute-only permissions.",
    "norm:H_vm_gstagetrans": "When V=1, memory accesses that would normally bypass address translation are subject to G-stage address translation alone. This includes memory accesses made in support of VS-stage address translation, such as reads and writes of VS-level page tables.",
    "norm:H_pmp": "Machine-level physical memory protection applies to supervisor physical addresses and is in effect regardless of virtualization mode.",
    "norm:hgatp-mode_bare_trans": "When the address translation scheme selected by the MODE field of hgatp is Bare, guest physical addresses are equal to supervisor physical addresses without modification, and no memory protection applies in the trivial translation of guest physical addresses to supervisor physical addresses.",
    "norm:hgatp-mode_x4": "When hgatp.MODE specifies a translation scheme of Sv32x4, Sv39x4, Sv48x4, or Sv57x4, G-stage address translation is a variation on the usual page-based virtual address translation scheme of Sv32, Sv39, Sv48, or Sv57, respectively. In each case, the size of the incoming address is widened by 2 bits (to 34, 41, 50, or 59 bits). To accommodate the 2 extra bits, the root page table (only) is expanded by a factor of four to be 16 KiB instead of the usual 4 KiB. Matching its larger size, the root page table also must be aligned to a 16 KiB boundary instead of the usual 4 KiB page boundary. Except as noted, all other aspects of Sv32, Sv39, Sv48, or Sv57 are adopted unchanged for G-stage translation. Non-root page tables and all page table entries (PTEs) have the same formats as documented in , , , and .",
    "norm:hgatp-mode_sv32x4": "For Sv32x4, an incoming guest physical address is partitioned into a virtual page number (VPN) and page offset as shown in . This partitioning is identical to that for an Sv32 virtual address as depicted in , except with 2 more bits at the high end in VPN[1]. (Note that the fields of a partitioned guest physical address also correspond one-for-one with the structure that Sv32 assigns to a physical address, depicted in .)",
    "norm:hgatp-mode_sv39x4": "For Sv39x4, an incoming guest physical address is partitioned as shown in . This partitioning is identical to that for an Sv39 virtual address as depicted in , except with 2 more bits at the high end in VPN[2]. Address bits 63:41 must all be zeros, or else a guest-page-fault exception occurs.",
    "norm:hgatp-mode_sv48x4": "For Sv48x4, an incoming guest physical address is partitioned as shown in . This partitioning is identical to that for an Sv48 virtual address as depicted in , except with 2 more bits at the high end in VPN[3]. Address bits 63:50 must all be zeros, or else a guest-page-fault exception occurs.",
    "norm:hgatp-mode_sv57x4": "For Sv57x4, an incoming guest physical address is partitioned as shown in . This partitioning is identical to that for an Sv57 virtual address as depicted in , except with 2 more bits at the high end in VPN[4]. Address bits 63:59 must all be zeros, or else a guest-page-fault exception occurs.",
    "norm:H_vm_gpatrans": "The conversion of an Sv32x4, Sv39x4, Sv48x4, or Sv57x4 guest physical address is accomplished with the same algorithm used for Sv32, Sv39, Sv48, or Sv57, as presented in , except that:",
    "norm:H_vm_gpapriv": "For G-stage address translation, all memory accesses (including those made to access data structures for VS-stage address translation) are considered to be user-level accesses, as though executed in U-mode. Access type permissions—readable, writable, or executable—are checked during G-stage translation the same as for VS-stage translation. For a memory access made to support VS-stage address translation (such as to read/write a VS-level page table), permissions and the need to set A and/or D bits at the G-stage level are checked as though for an implicit load or store, not for the original access type. However, any exception is always reported for the original access type (instruction, load, or store/AMO).",
    "norm:H_vm_gpa_g": "The G bit in all G-stage PTEs is currently not used. Until its use is defined by a standard extension, it should be cleared by software for forward compatibility, and must be ignored by hardware.",
    "norm:H_guest_page_fault": "Guest-page-fault traps may be delegated from M-mode to HS-mode under the control of CSR medeleg, but cannot be delegated to other privilege modes. On a guest-page fault, CSR mtval or stval is written with the faulting guest virtual address as usual, and mtval2 or htval is written either with zero or with the faulting guest physical address, shifted right by 2 bits. CSR mtinst or htinst may also be written with information about the faulting instruction or other reason for the access, as explained in .",
    "norm:H_straddle": "When an instruction fetch or a misaligned memory access straddles a page boundary, two different address translations are involved. When a guest-page fault occurs in such a circumstance, the faulting virtual address written to mtval/stval is the same as would be required for a regular page fault. Thus, the faulting virtual address may be a page-boundary address that is higher than the instruction&#8217;s original virtual address, if the byte at that page boundary is among the accessed bytes.",
    "norm:mtval2_htval_virtaddr": "When a guest-page fault is not due to an implicit memory access for VS-stage address translation, a nonzero guest physical address written to mtval2/htval shall correspond to the exact virtual address written to mtval/stval.",
    "norm:sfence-vma_v0": "The behavior of the SFENCE.VMA instruction is affected by the current virtualization mode V. When V=0, the virtual-address argument is an HS-level virtual address, and the ASID argument is an HS-level ASID. The instruction orders stores only to HS-level address-translation structures with subsequent HS-level address translations.",
    "norm:sfence-vma_v1": "When V=1, the virtual-address argument to SFENCE.VMA is a guest virtual address within the current virtual machine, and the ASID argument is a VS-level ASID within the current virtual machine. The current virtual machine is identified by the VMID field of CSR hgatp, and the effective ASID can be considered to be the combination of this VMID with the VS-level ASID. The SFENCE.VMA instruction orders stores only to the VS-level address-translation structures with subsequent VS-stage address translations for the same virtual machine, i.e., only when hgatp.VMID is the same as when the SFENCE.VMA executed.",
    "norm:H_cause": "The hypervisor extension augments the trap cause encoding.  lists the possible M-mode and HS-mode trap cause codes when the hypervisor extension is implemented. Codes are added for VS-level interrupts (interrupts 2, 6, 10), for supervisor-level guest external interrupts (interrupt 12), for virtual-instruction exceptions (exception 22), and for guest-page faults (exceptions 20, 21, 23). Furthermore, environment calls from VS-mode are assigned cause 10, whereas those from HS-mode or S-mode use cause 9 as usual.",
    "norm:H_cause_ecall": "HS-mode and VS-mode ECALLs use different cause values so they can be delegated separately.",
    "norm:H_cause_virtual_instruction": "When V=1, a virtual-instruction exception (code 22) is normally raised instead of an illegal-instruction exception if the attempted instruction is HS-qualified but is prevented from executing when V=1 either due to insufficient privilege or because the instruction is expressly disabled by a supervisor or hypervisor CSR such as scounteren or hcounteren. An instruction is HS-qualified if it would be valid to execute in HS-mode (for some values of the instruction&#8217;s register operands), assuming fields TSR and TVM of CSR mstatus are both zero.",
    "norm:H_cause_virtual_instruction_high": "A special rule applies for CSR instructions that access 32-bit high-half CSRs such as cycleh and htimedeltah. When V=1 and XLEN=32, an invalid attempt to access a high-half CSR raises a virtual-instruction exception instead of an illegal-instruction exception if the same CSR instruction for the corresponding low-half CSR (e.g.cycle or htimedelta) is HS-qualified.",
    "norm:H_illegal_high_half": "When XLEN&gt;32, an attempt to access a high-half CSR always raises an illegal-instruction exception.",
    "norm:H_virtinst_vs_nonhighctr_h0_m1": "in VS-mode, attempts to access a non-high-half counter CSR when the\ncorresponding bit in hcounteren is 0 and the same bit in mcounteren\nis 1;",
    "norm:H_virtinst_vs32_highctr_h0_m1": "in VS-mode, if XLEN=32, attempts to access a high-half counter CSR\nwhen the corresponding bit in hcounteren is 0 and the same bit in\nmcounteren is 1;",
    "norm:H_virtinst_vu_nonhighctr_h0_s0_m1": "in VU-mode, attempts to access a non-high-half counter CSR when the\ncorresponding bit in either hcounteren or scounteren is 0 and the\nsame bit in mcounteren is 1;",
    "norm:H_virtinst_vu32_highctr_h0_s0_m1": "in VU-mode, if XLEN=32, attempts to access a high-half counter CSR\nwhen the corresponding bit in either hcounteren or scounteren is 0\nand the same bit in mcounteren is 1;",
    "norm:H_virtinst_vu_vs_hinst": "in VS-mode or VU-mode, attempts to execute a hypervisor instruction\n(HLV, HLVX, HSV, or HFENCE);",
    "norm:H_virtinst_vu_vs_nonhigh_allowedhs_tvm0": "in VS-mode or VU-mode, attempts to access an implemented non-high-half\nhypervisor CSR or VS CSR when the same access (read/write) would be\nallowed in HS-mode, assuming mstatus.TVM=0;",
    "norm:H_virtinst_vu_vs32_high_allowedhs_tvm0": "in VS-mode or VU-mode, if XLEN=32, attempts to access an implemented\nhigh-half hypervisor CSR or high-half VS CSR when the same access\n(read/write) to the CSR\"s low-half partner would be allowed in HS-mode,\nassuming mstatus.TVM=0;",
    "norm:H_virtinst_vu_wfi_tw0": "in VU-mode, attempts to execute WFI when mstatus.TW=0",
    "norm:H_virtinst_vu_sret_sfence": "or to execute\na supervisor instruction (SRET or SFENCE);",
    "norm:H_virtinst_vu_nonhigh_supervisor_allowedhs_tvm0": "in VU-mode, attempts to access an implemented non-high-half supervisor\nCSR when the same access (read/write) would be allowed in HS-mode,\nassuming mstatus.TVM=0;",
    "norm:H_virtinst_vu32_high_supervisor_allowedhs_tvm0": "in VU-mode, if XLEN=32, attempts to access an implemented high-half\nsupervisor CSR when the same access to the CSR's low-half partner would\nbe allowed in HS-mode, assuming mstatus.TVM=0;",
    "norm:H_virtinst_wfi_vtw1_tw0": "in VS-mode, attempts to execute WFI when hstatus.VTW=1 and\nmstatus.TW=0, unless the instruction completes within an\nimplementation-specific, bounded time;",
    "norm:H_virtinst_vs_sret_vtsr1": "in VS-mode, attempts to execute SRET when hstatus.VTSR=1",
    "norm:H_virtinst_vs_sfence_sinval_satp_vtvm1": "in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA\ninstruction or to access satp, when hstatus.VTVM=1.",
    "norm:H_virtinst_xtval": "On a virtual-instruction trap, mtval or stval is written the same as for an illegal-instruction trap.",
    "norm:H_illegalinst_xstatus_fs_vs": "Fields FS and VS in registers sstatus and vsstatus deviate from the usual HS-qualified rule. If an instruction is prevented from executing because FS or VS is zero in either sstatus or vsstatus, the exception raised is always an illegal-instruction exception, never a virtual-instruction exception.",
    "norm:H_exception_priority": "If an instruction may raise multiple synchronous exceptions, the decreasing priority order of  indicates which exception is taken and reported in mcause or scause.",
    "norm:H_trap_deleg": "When a trap occurs in HS-mode or U-mode, it goes to M-mode, unless delegated by medeleg or mideleg, in which case it goes to HS-mode. When a trap occurs in VS-mode or VU-mode, it goes to M-mode, unless delegated by medeleg or mideleg, in which case it goes to HS-mode, unless further delegated by hedeleg or hideleg, in which case it goes to VS-mode.",
    "norm:H_trap_m_csrwrites": "When a trap is taken into M-mode, virtualization mode V gets set to 0, and fields MPV and MPP in mstatus (or mstatush) are set according to . A trap into M-mode also writes fields GVA, MPIE, and MIE in mstatus/mstatush and writes CSRs mepc, mcause, mtval, mtval2, and mtinst.",
    "norm:H_trap_hs_csrwrites": "When a trap is taken into HS-mode, virtualization mode V is set to 0, and hstatus.SPV and sstatus.SPP are set according to . If V was 1 before the trap, field SPVP in hstatus is set the same as sstatus.SPP; otherwise, SPVP is left unchanged. A trap into HS-mode also writes field GVA in hstatus, fields SPIE and SIE in sstatus, and CSRs sepc, scause, stval, htval, and htinst.",
    "norm:H_trap_vs_csrwrites": "When a trap is taken into VS-mode, vsstatus.SPP is set according to . Register hstatus and the HS-level sstatus are not modified, and the virtualization mode V remains 1. A trap into VS-mode also writes fields SPIE and SIE in vsstatus and writes CSRs vsepc, vscause, and vstval.",
    "norm:H_trap_xtinst": "On any trap into M-mode or HS-mode, one of these values is written automatically into the appropriate trap instruction CSR, mtinst or htinst:",
    "norm:H_trap_xtinst_interrupt": "On an interrupt, the value written to the trap instruction register is\nalways zero.",
    "norm:H_trap_xtinst_exception_lead-in": "On a synchronous exception, if a nonzero value is written,\none of the following shall be true about the value:",
    "norm:H_trap_xtinst_exception_list": "Bit 0 is 1, and replacing bit 1 with 1 makes the value into a valid encoding of a standard instruction.\n\nIn this case, the instruction that trapped is the same kind as indicated by the register value, and the register value is the transformation of the trapping instruction, as defined later. For example, if bits 1:0 are binary 11 and the register value is the encoding of a standard LW (load word) instruction, then the trapping instruction is LW, and the register value is the transformation of the trapping LW instruction.\nBit 0 is 1, and replacing bit 1 with 1 makes the value into an instruction encoding that is explicitly designated for a custom instruction (not an unused reserved encoding).\n\nThis is a custom value. The instruction that trapped is a non-standard instruction. The interpretation of a custom value is not otherwise specified by this standard.\nThe value is one of the special pseudoinstructions defined later, all of which have bits 1:0 equal to 00.",
    "norm:H_trap_xtinst_val": "shows the values that may be automatically written to the trap instruction register for each standard exception cause. For exceptions that prevent the fetching of an instruction, only zero or a pseudoinstruction value may be written. A custom value may be automatically written only if the instruction that traps is non-standard. A future standard or extension may permit other values to be written, chosen from the set of allowed values established earlier.",
    "norm:H_trap_xtinst_guestpage": "For guest-page faults, the trap instruction register is written with a special pseudoinstruction value if: (a) the fault is caused by an implicit memory access for VS-stage address translation, and (b) a nonzero value (the faulting guest physical address) is written to mtval2 or htval. If both conditions are met, the value written to mtinst or htinst must be taken from ; zero is not allowed.",
    "norm:H_trap_xtinst_guestpage_rw": "A write pseudoinstruction (0x00002020 or 0x00003020) is used for the case that the machine is attempting automatically to update bits A and/or D in VS-level page tables. All other implicit memory accesses for VS-stage address translation will be reads. If a machine never automatically updates bits A or D in VS-level page tables (leaving this to software), the write case will never arise. The fact that such a page table update must actually be atomic, not just a simple write, is ignored for the pseudoinstruction.",
    "norm:mret_h": "The MRET instruction is used to return from a trap taken into M-mode. MRET first determines what the new privilege mode will be according to the values of MPP and MPV in mstatus or mstatush, as encoded in . MRET then in mstatus/mstatush sets MPV=0, MPP=0, MIE=MPIE, and MPIE=1. Lastly, MRET sets the privilege mode as previously determined, and sets pc=mepc.",
    "norm:sret_h": "The SRET instruction is used to return from a trap taken into HS-mode or VS-mode. Its behavior depends on the current virtualization mode.",
    "norm:mret_v0": "When executed in M-mode or HS-mode (i.e., V=0), SRET first determines what the new privilege mode will be according to the values in hstatus.SPV and sstatus.SPP, as encoded in . SRET then sets hstatus.SPV=0, and in sstatus sets SPP=0, SIE=SPIE, and SPIE=1. Lastly, SRET sets the privilege mode as previously determined, and sets pc=sepc.",
    "norm:mret_v1": "When executed in VS-mode (i.e., V=1), SRET sets the privilege mode according to , in vsstatus sets SPP=0, SIE=SPIE, and SPIE=1, and lastly sets pc=vsepc.",
    "norm:mret_dt": "If the Ssdbltrp extension is implemented, when SRET is executed in HS-mode, if the new privilege mode is VU, the SRET instruction sets vsstatus.SDT to 0. When executed in VS-mode, vsstatus.SDT is set to 0.",
    "norm:Zicfilp_forward_traps": "A trap may need to be delivered to the same or to a higher privilege mode upon\ncompletion of JALR/C.JALR/C.JR, but before the instruction at the target\nof indirect call/jump was decoded",
    "norm:Zicfilp_forward_trap_async_interrupt": "Asynchronous interrupts.",
    "norm:Zicfilp_forward_trap_async_exception": "Synchronous exceptions with priority higher than that of a software-check\nexception with xtval set to \"landing pad fault (code=2)\" (See\n&lt;&lt;norm:exc_priority&gt;&gt; of Privileged Specification).",
    "norm:Zicfilp_exception_priority": "The software-check exception caused by Zicfilp has higher priority than an illegal-instruction exception but lower priority than instruction access-fault.",
    "norm:lpad_sw_exception": "The software-check exception due to the instruction not being an LPAD instruction when ELP is LP_EXPECTED or a software-check exception caused by the LPAD instruction itself leads to a trap being delivered to the same or to a higher privilege mode.",
    "norm:mstatus-mpelp_op": "To store the previous ELP state on trap delivery to M-mode, an MPELP\nbit is provided in the mstatus CSR.",
    "norm:mstatus-spelp_op": "To store the previous ELP state on trap\ndelivery to S/HS-mode, an SPELP bit is provided in the mstatus CSR.",
    "norm:sstatus-spelp_op": "The\nSPELP bit in mstatus can be accessed through the sstatus CSR.",
    "norm:vsstatus-spelp_op2": "To store\nthe previous ELP state on traps to VS-mode, a SPELP bit is defined in the\nvsstatus (VS-modes version of sstatus).",
    "norm:dcsr-pelp_op": "To store the previous ELP state on\ntransition to Debug Mode, a pelp bit is defined in the dcsr register.",
    "norm:Zicfilp_pelp_trap": "When a trap is taken into privilege mode x, the xPELP is set to ELP and ELP is set to NO_LP_EXPECTED.",
    "norm:Zicfilp_pelp_trap_return": "An MRET or SRET instruction is used to return from a trap in M-mode or S-mode, respectively.  When executing an xRET instruction, if the new privilege mode is y, then ELP is set to the value of xPELP if yLPE (see ) is 1; otherwise, it is set to NO_LP_EXPECTED; xPELP is set to NO_LP_EXPECTED.",
    "norm:Zicfilp_pelp_debug_mode": "Upon entry into Debug Mode, the pelp bit in dcsr is updated with the ELP at the privilege level the hart was previously in, and the ELP is set to NO_LP_EXPECTED. When a hart resumes from Debug Mode, if the new privilege mode is y, then ELP is set to the value of pelp if yLPE (see ) is 1; otherwise, it is set to NO_LP_EXPECTED.",
    "norm:zicfiss_ssp_csr": "Attempts to access the ssp CSR may result in either an illegal-instruction exception or a virtual-instruction  exception, contingent upon the state of the x`envcfg.SSE` fields. The conditions are specified as follows:",
    "norm:zicfiss_m_menvcfg-sse": "If the privilege mode is less than M and menvcfg.SSE is 0, an\nillegal-instruction exception is raised.",
    "norm:zicfiss_u_senvcfg-sse": "Otherwise, if in U-mode and senvcfg.SSE is 0, an illegal-instruction\nexception is raised.",
    "norm:zicfiss_vs_henvcfg-sse": "Otherwise, if in VS-mode and henvcfg.SSE is 0, a virtual-instruction\nexception is raised.",
    "norm:zicfiss_vu_henvcfg_senvcfg-sse": "Otherwise, if in VU-mode and either henvcfg.SSE or senvcfg.SSE is 0,\na virtual-instruction  exception is raised.",
    "norm:zicfiss_sse_access": "Otherwise, the access is allowed.",
    "norm:zicfiss_smode-xsse": "When S-mode is not implemented, then xSSE is 0 at both M and U privilege modes.",
    "norm:ss_page_enc": "The\nencoding R=0, W=1, and X=0, is defined to represent an SS page.",
    "norm:ssmp_menvcfg-sse": "When\nmenvcfg.SSE=0, this encoding remains reserved.",
    "norm:ssmp_henvcfg-sse": "Similarly, when V=1 and\nhenvcfg.SSE=0, this encoding remains reserved at VS and VU levels.",
    "norm:satp-mode_bare": "If satp.MODE (or vsatp.MODE when V=1) is set to Bare and the effective\nprivilege mode is less than M, shadow stack instructions raise a store/AMO access-fault exception.",
    "norm:ssmp_ssamoswap": "When the effective privilege mode is M, memory access\nby an SSAMOSWAP.W/D instruction results in a store/AMO access-fault exception.",
    "norm:ssmp_ss_page_access_fault": "Memory mapped as an SS page cannot be written to by instructions other than\nSSAMOSWAP.W/D, SSPUSH, and C.SSPUSH. Attempts will raise a store/AMO\naccess-fault exception.",
    "norm:ssmp_ss_cache_block_access_fault": "Access to a SS page using cache-block operation\n(CBO.*) instructions is not permitted. Such accesses will raise a store/AMO\naccess-fault exception.",
    "norm:ssmp_ss_implicit_access_fault": "Implicit accesses, including instruction fetches to an\nSS page, are not permitted. Such accesses will raise an access-fault exception\nappropriate to the access type.",
    "norm:ssmp_ss_load": "However, the shadow stack is readable by all\ninstructions that only load from memory.",
    "norm:ss_fault_exception_code": "If a shadow stack (SS) instruction raises an access-fault, page-fault, or\nguest-page-fault exception that is supposed to indicate the original instruction\ntype (load or store/AMO), then the reported exception cause is respectively a\nstore/AMO access fault (code 7), a store/AMO page fault (code 15), or a\nstore/AMO guest-page fault (code 23).",
    "norm:ssmp_ss_page_illegeal_access": "Should a shadow stack instruction access a page that is\nnot designated as a shadow stack page and is not marked as read-only\n(pte.xwr=001), a store/AMO access-fault exception will be invoked.",
    "norm:ssmp_ss_read_only_page": "Conversely,\nif the page being accessed by a shadow stack instruction is a read-only page, a\nstore/AMO page-fault exception will be triggered.",
    "norm:ssp_xlen_aligned": "If the virtual address in ssp is not XLEN aligned, then the SSPUSH/ C.SSPUSH/SSPOPCHK/C.SSPOPCHK instructions cause a store/AMO access-fault exception.",
    "norm:ssmp_ss_idempotent_memory": "If the memory referenced by\nSSPUSH/C.SSPUSH/SSPOPCHK/C.SSPOPCHK/SSAMOSWAP.W/D instructions is not\nidempotent, then the instructions cause a store/AMO access-fault exception.",
    "norm:active_g_stage_pte": "When G-stage page tables are active, the shadow stack instructions that access memory\nrequire the G-stage page table to have read-write permission for the accessed\nmemory; else a store/AMO guest-page-fault exception is raised.",
    "norm:HS-mode_invoke_error": "It enables HS-mode to invoke a critical error\nhandler in a virtual machine on a double trap in VS-mode.",
    "norm:M-mode_invoke_error": "It also allows M-mode\nto invoke a critical error handler in the OS/Hypervisor on a double trap in\nS/HS-mode.",
    "norm:menvcfg_DTE": "The Ssdbltrp extension adds the menvcfg.DTE (See &lt;&lt;sec:menvcfg&gt;&gt;)",
    "norm:sstatus_SDT": "and the\nsstatus.SDT fields (See &lt;&lt;sstatus&gt;&gt;).",
    "norm:henvcfg_DTE": "If the hypervisor extension is\nadditionally implemented, then the extension adds the henvcfg.DTE (See\n&lt;&lt;sec:henvcfg&gt;&gt;)",
    "norm:vsstatus_SDT": "and the vsstatus.SDT fields (See &lt;&lt;vsstatus&gt;&gt;).",
    "norm:pm_ignore_upper_bits": "RISC-V Pointer Masking (PM) is a feature that, when enabled, causes the CPU to ignore the upper bits of the effective address",
    "norm:pm_all_priv_modes": "Such tools can be applied in all privilege modes (U, S, and M).",
    "norm:pm_tag_check_impl": "The tag checks themselves can be implemented in software or hardware.",
    "norm:pm_ignore_va": "The ignore transformation differs depending on whether it applies to a virtual or physical address. For virtual addresses, it replaces the upper PMLEN bits with the sign extension of the PMLEN+1st bit.",
    "norm:pm_ignore_pa": "When applied to a physical address, including guest-physical addresses (i.e., all cases except when the active satp register's MODE field != Bare), the ignore transformation replaces the upper PMLEN bits with 0. This includes both the case of running in M-mode and running in other privilege modes with Bare address translation mode.",
    "norm:pm_apply_explicit": "When pointer masking is enabled, the ignore transformation will be applied to every explicit memory access (e.g., loads/stores, atomics operations, and floating point loads/stores).",
    "norm:pm_not_apply_implicit": "The transformation does not apply to implicit accesses such as page-table walks or instruction fetches.",
    "norm:pm_deterministic_effect": "Pointer masking with the same value of PMLEN always has the same effect for the same type of address (virtual or physical).",
    "norm:pmlen_supported_values": "The current standard only supports PMLEN=XLEN-48 (i.e., PMLEN=16 in RV64) and PMLEN=XLEN-57 (i.e., PMLEN=7 in RV64).",
    "norm:pmlen_future_reserved": "A setting has been reserved to potentially support other values of PMLEN in future standards.",
    "norm:pm_per_mode_control": "Pointer masking is controlled separately for different privilege modes.",
    "norm:pm_auto_apply_active_mode": "Different privilege modes may have different pointer masking settings active simultaneously and the hardware will automatically apply the pointer masking settings of the currently active privilege mode.",
    "norm:pm_config_next_higher": "A privilege mode's pointer masking setting is configured by bits in configuration registers of the next-higher privilege mode.",
    "norm:pm_mode_only_dependency": "the pointer masking setting that is applied only depends on the active privilege mode, not on the address that is being masked.",
    "norm:pm_mprv_spvp": "MPRV and SPVP affect pointer masking as well, causing the pointer masking settings of the effective privilege mode to be applied.",
    "norm:pm_mxr_exception": "When MXR is in effect at the effective privilege mode where explicit memory access is performed, pointer masking does not apply.",
    "norm:pm_cpu_only": "Pointer masking only applies to accesses generated by instructions on the CPU (including CPU extensions such as an FPU). E.g., it does not apply to accesses generated by page-table walks, the IOMMU, or devices.",
    "norm:pm_misaligned_equivalence": "Misaligned accesses are supported, subject to the same limitations as in the absence of pointer masking. The behavior is identical to applying the pointer masking transformation to every constituent aligned memory access.",
    "norm:pm_no_csr_sw": "No pointer masking operations are applied when software reads/writes to CSRs, including those meant to hold addresses.",
    "norm:pm_warl_unaffected": "The implemented WARL width of CSRs is unaffected by pointer masking",
    "norm:pm_csr_hw_apply": "pointer masking, when applicable, is applied for hardware writes to a CSR (e.g., when the hardware writes the transformed address to stval when taking an exception).",
    "norm:pm_debug_trigger": "Pointer masking is also applied, when applicable, to the memory access address when matching address triggers in debug.",
    "norm:pm_no_trap_vector_mask": "on trap delivery (e.g., due to an exception or interrupt), pointer masking will not be applied to the address of the trap handler.",
    "norm:pm_family_extensions": "Pointer masking refers to a number of separate extensions, all of which are privileged.",
    "norm:ssnpm_definition": "A supervisor-level extension that provides pointer masking for the next lower privilege mode (U-mode), and for VS- and VU-modes if the H extension is present.",
    "norm:smnpm_definition": "A machine-level extension that provides pointer masking for the next lower privilege mode (S/HS if S-mode is implemented, or U-mode otherwise).",
    "norm:smmpm_definition": "A machine-level extension that provides pointer masking for M-mode.",
    "norm:sspm_definition": "An extension that indicates that there is pointer-masking support available in supervisor mode, with some facility provided in the supervisor execution environment to control pointer masking.",
    "norm:supm_definition": "An extension that indicates that there is pointer-masking support available in user mode, with some facility provided in the application execution environment to control pointer masking.",
    "norm:pm_rv64_only": "Pointer masking only applies to RV64.",
    "norm:pm_rv32_illegal": "In RV32, trying to enable pointer masking will result in an illegal WARL write and not update the pointer masking configuration bits",
    "norm:pm_uxl_clear": "Setting UXL/SXL/MXL to 1 will clear the corresponding pointer masking configuration bits.",
    "norm:pmlen_mode_depend": "the supported values of PMLEN may depend on the effective privilege mode. The current standard only defines PMLEN=XLEN-48 and PMLEN=XLEN-57,",
    "norm:pmlen_illegal_warl": "Trying to enable pointer masking in an unsupported scenario represents an illegal write to the corresponding pointer masking enable bit and follows WARL semantics."
  },
  "sections": {
    "title": "",
    "id": "",
    "children": [
      {
        "title": "Preface",
        "id": "_preface",
        "children": [],
        "tags": []
      },
      {
        "title": "Introduction",
        "id": "_introduction",
        "children": [
          {
            "title": "RISC-V Privileged Software Stack Terminology",
            "id": "_risc_v_privileged_software_stack_terminology",
            "children": [],
            "tags": []
          },
          {
            "title": "Privilege Levels",
            "id": "_privilege_levels",
            "children": [],
            "tags": [
              "norm:always-priv-level",
              "norm:priv-levels-txt",
              "norm:priv-levels-tbl",
              "norm:non-priv-exc",
              "norm:m-level-high-priv-only-mandatory",
              "norm:priv-combs-txt",
              "norm:priv-combs-tbl",
              "norm:m-mode-mandatory"
            ]
          },
          {
            "title": "Debug Mode",
            "id": "_debug_mode",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Control and Status Registers (CSRs)",
        "id": "priv-csrs",
        "children": [
          {
            "title": "CSR Address Mapping Conventions",
            "id": "_csr_address_mapping_conventions",
            "children": [],
            "tags": [
              "norm:Zicsr_rw",
              "norm:Zicsr_access",
              "norm:Zicsr_illegal_mode",
              "norm:Zicsr_illegal_acc",
              "norm:Zicwr_write_ro",
              "norm:Zicsr_debug-illegal"
            ]
          },
          {
            "title": "CSR Listing",
            "id": "_csr_listing",
            "children": [
              {
                "title": "Currently allocated RISC-V unprivileged CSR addresses",
                "id": "_currently_allocated_risc_v_unprivileged_csr_addresses",
                "children": [],
                "tags": []
              },
              {
                "title": "Currently allocated RISC-V supervisor-level CSR addresses",
                "id": "_currently_allocated_risc_v_supervisor_level_csr_addresses",
                "children": [],
                "tags": []
              },
              {
                "title": "Currently allocated RISC-V hypervisor and VS CSR addresses",
                "id": "_currently_allocated_risc_v_hypervisor_and_vs_csr_addresses",
                "children": [],
                "tags": []
              },
              {
                "title": "Currently allocated RISC-V machine-level CSR addresses",
                "id": "_currently_allocated_risc_v_machine_level_csr_addresses",
                "children": [],
                "tags": []
              },
              {
                "title": "Currently allocated RISC-V indirect CSR (Smcsrind) mappings",
                "id": "_currently_allocated_risc_v_indirect_csr_smcsrind_mappings",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "CSR Field Specifications",
            "id": "_csr_field_specifications",
            "children": [
              {
                "title": "Reserved Writes Preserve Values, Reads Ignore Values (WPRI)",
                "id": "_reserved_writes_preserve_values_reads_ignore_values_wpri",
                "children": [],
                "tags": [
                  "norm:Zicsr_wpri_roz"
                ]
              },
              {
                "title": "Write/Read Only Legal Values (WLRL)",
                "id": "_writeread_only_legal_values_wlrl",
                "children": [],
                "tags": [
                  "norm:Zicsr_wlrl",
                  "norm:Zicsr_wlrl_exception"
                ]
              },
              {
                "title": "Write Any Values, Reads Legal Values (WARL)",
                "id": "_write_any_values_reads_legal_values_warl",
                "children": [],
                "tags": [
                  "norm:Zicsr_warl"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "CSR Field Modulation",
            "id": "_csr_field_modulation",
            "children": [],
            "tags": []
          },
          {
            "title": "Implicit Reads of CSRs",
            "id": "_implicit_reads_of_csrs",
            "children": [],
            "tags": []
          },
          {
            "title": "CSR Width Modulation",
            "id": "csrwidthmodulation",
            "children": [],
            "tags": []
          },
          {
            "title": "Explicit Accesses to CSRs Wider than XLEN",
            "id": "_explicit_accesses_to_csrs_wider_than_xlen",
            "children": [],
            "tags": []
          }
        ],
        "tags": [
          "norm:Zicsr_higher_priv"
        ]
      },
      {
        "title": "Machine-Level ISA, Version 1.13",
        "id": "machine",
        "children": [
          {
            "title": "Machine-Level CSRs",
            "id": "_machine_level_csrs",
            "children": [
              {
                "title": "Machine ISA (misa) Register",
                "id": "misa",
                "children": [],
                "tags": [
                  "norm:misa_acc",
                  "norm:misa_always_rd",
                  "norm:misa_csr_implemented",
                  "norm:misa_enc_img",
                  "norm:misa_mxl_op_isa",
                  "norm:misa_mxl_acc",
                  "norm:misa_mxl_op_nz",
                  "norm:xlen_le_mxlen",
                  "norm:misa_mxl_enc",
                  "norm:misa_sz",
                  "norm:misa_extensions_enc_txt",
                  "norm:misa_i_op",
                  "norm:misa_e_op",
                  "norm:misa_extensions_warl_op",
                  "norm:misa_extensions_rst1",
                  "norm:misa_extensions_disabling",
                  "norm:misa_extensions_impl_def",
                  "norm:misa_extensions_disabling_def",
                  "norm:misa_extensions_rsv_ret_0",
                  "norm:misa_extensions_enc_tbl",
                  "norm:misa_x_op",
                  "norm:misa_b_op",
                  "norm:misa_m_op",
                  "norm:Zmmul_misa_m",
                  "norm:misa_s_op",
                  "norm:misa_u_op",
                  "norm:misa_e_acc",
                  "norm:misa_e_not_i",
                  "norm:misa_extensions_dependencies",
                  "norm:misa_inc_ialign"
                ]
              },
              {
                "title": "Machine Vendor ID (mvendorid) Register",
                "id": "_machine_vendor_id_mvendorid_register",
                "children": [],
                "tags": [
                  "norm:mvendorid_sz_acc_op",
                  "norm:mvendorid_always_rd",
                  "norm:mvendorid_enc"
                ]
              },
              {
                "title": "Machine Architecture ID (marchid) Register",
                "id": "_machine_architecture_id_marchid_register",
                "children": [],
                "tags": [
                  "norm:marchid_sz_acc_op",
                  "norm:marchid_always_rd"
                ]
              },
              {
                "title": "Machine Implementation ID (mimpid) Register",
                "id": "_machine_implementation_id_mimpid_register",
                "children": [],
                "tags": [
                  "norm:mimpid_op",
                  "norm:mimpid_always_rd"
                ]
              },
              {
                "title": "Hart ID (mhartid) Register",
                "id": "_hart_id_mhartid_register",
                "children": [],
                "tags": [
                  "norm:mhartid_sz_acc_op",
                  "norm:mhartid_always_rd",
                  "norm:mhartid_one_is_zero",
                  "norm:mhartid_unique"
                ]
              },
              {
                "title": "Machine Status (mstatus and mstatush) Registers",
                "id": "_machine_status_mstatus_and_mstatush_registers",
                "children": [
                  {
                    "title": "Privilege and Global Interrupt-Enable Stack in mstatus register",
                    "id": "privstack",
                    "children": [],
                    "tags": [
                      "norm:mstatus_mie_sie_op1",
                      "norm:mstatus_mie_sie_op2",
                      "norm:mstatus_xie_intr_en_dis",
                      "norm:mstatus_sie_spie_rdonly0",
                      "norm:mstatus_xpie_xpp_op",
                      "norm:mstatus_xpp_enc",
                      "norm:mstatus_mpp_sz",
                      "norm:mstatus_spp_sz",
                      "norm:mstatus_xpie_xie_xpp_trap_op",
                      "norm:mstatus_xret_op",
                      "norm:mstatus_xpp_warl",
                      "norm:mstatus_xpp_rdonly0"
                    ]
                  },
                  {
                    "title": "Double Trap Control in mstatus Register",
                    "id": "machine-double-trap",
                    "children": [],
                    "tags": [
                      "norm:mstatus_mdt_sz_warl",
                      "norm:mstatus_mdt_rst",
                      "norm:mstatus_mie_clr_by_mdt",
                      "norm:mstatus_mie_clr_by_mdt_rv64",
                      "norm:mstatus_mie_set_mdt_0",
                      "norm:mstatus_mie_set_mdt_0_rv64",
                      "norm:trap_exp",
                      "norm:trap_unexp_mdt_1",
                      "norm:trap_unexp_rnmi",
                      "norm:mstatus_mdt_not_set_rnmi",
                      "norm:trap_unexp_mnstatus_nmie_0",
                      "norm:trap_unexp_hndl_lead-in",
                      "norm:trap_unexp_hndl_rnmi",
                      "norm:trap_unexp_hndl_no_rnmi",
                      "norm:critical_error",
                      "norm:mstatus_mdt_clr_mret_sret",
                      "norm:sstatus_sdt_clr_mret_sret",
                      "norm:vsstatus_sdt_clr_mret_sret",
                      "norm:mstatus_mdt_clr_mnret",
                      "norm:sstatus_sdt_clr_mnret",
                      "norm:vsstatus_sdt_clr_mnret"
                    ]
                  },
                  {
                    "title": "Base ISA Control in mstatus Register",
                    "id": "xlen-control",
                    "children": [],
                    "tags": [
                      "norm:mstatus_sxl_uxl_warl_op",
                      "norm:mstatus_sxl_uxl_enc",
                      "norm:sxlen_uxlen",
                      "norm:mstatus_sxl_uxl_sxlen_uxlen_mxlen32",
                      "norm:mstatus_sxl_acc_mxlen64",
                      "norm:mstatus_sxl_rdonly_mxlen64",
                      "norm:mstatus_uxl_acc_mxlen64",
                      "norm:mstatus_uxl_rdonly_mxlen64",
                      "norm:mstatus_uxl_legal_vals_smode",
                      "norm:xlen_reduction_op",
                      "norm:xlen_reduction_hint_op1",
                      "norm:xlen_reduction_hint_op2"
                    ]
                  },
                  {
                    "title": "Memory Privilege in mstatus Register",
                    "id": "_memory_privilege_in_mstatus_register",
                    "children": [],
                    "tags": [
                      "norm:mstatus_mprv_ldst_op",
                      "norm:mstatus_mprv_inst_xlat_op",
                      "norm:mstatus_mprv_rdonly0_no_umode",
                      "norm:mstatus_mprv_clr_mret_sret_less_priv",
                      "norm:mstatus_mxr_op",
                      "norm:mstatus_mxr_rdonly0_no_smode",
                      "norm:mstatus_sum_op",
                      "norm:mstatus_sum_op_no-vm",
                      "norm:mstatus_sum_op_mprv_mpp",
                      "norm:mstatus_sum_rdonly0",
                      "norm:mstatus_mxr_sum_op_acc_fault"
                    ]
                  },
                  {
                    "title": "Endianness Control in mstatus and mstatush Registers",
                    "id": "_endianness_control_in_mstatus_and_mstatush_registers",
                    "children": [],
                    "tags": [
                      "norm:mstatus_mstatush_xbe_warl",
                      "norm:endianness_inst_fetch_little",
                      "norm:mstatus_mbe_op",
                      "norm:mstatus_sbe_op",
                      "norm:mstatus_ube_op",
                      "norm:mstatus_sbe_implicit",
                      "norm:mstatus_sbe_change_fence",
                      "norm:mstatus_sbe_rocopy",
                      "norm:mstatus_ube_rocopy"
                    ]
                  },
                  {
                    "title": "Virtualization Support in mstatus Register",
                    "id": "virt-control",
                    "children": [],
                    "tags": [
                      "norm:mstatus_tvm_warl_op",
                      "norm:mstatus_tw_warl",
                      "norm:mstatus_tw_op",
                      "norm:mstatus_tw_always_illegal",
                      "norm:mstatus_tw_acc",
                      "norm:mstatus_tw_umode_op",
                      "norm:mstatus_tsr_warl",
                      "norm:mstatus_tsr_op",
                      "norm:mstatus_tsr_acc"
                    ]
                  },
                  {
                    "title": "Extension Context Status in mstatus Register",
                    "id": "_extension_context_status_in_mstatus_register",
                    "children": [],
                    "tags": [
                      "norm:mstatus_fs_vs_warl",
                      "norm:mstatus_fs_op",
                      "norm:mstatus_vs_op",
                      "norm:mstatus_xs_op1",
                      "norm:mstatus_fs_vs_xs_enc",
                      "norm:mstatus_fs_acc1",
                      "norm:mstatus_fs_acc2",
                      "norm:mstatus_fs_rdonly0_s_no_f",
                      "norm:mstatus_vs_acc1",
                      "norm:mstatus_vs_acc2",
                      "norm:mstatus_vs_rdonly0_s_no_v",
                      "norm:mstatus_xs_acc",
                      "norm:mstatus_xs_equiv",
                      "norm:mstatus_xs_op2",
                      "norm:mstatus_sd_acc",
                      "norm:mstatus_sd_op",
                      "norm:mstatus_sd_rdonly0",
                      "norm:mstatus_fs_vs_xs_off_op",
                      "norm:mstatus_fs_vs_xs_initial_op",
                      "norm:mstatus_fs_vs_xs_clean_op",
                      "norm:mstatus_fs_vs_xs_dirty_op",
                      "norm:mstatus_fs_vs_xs_update_indep_priv",
                      "norm:mstatus_fs_wr",
                      "norm:mstatus_vs_wr",
                      "norm:mstatus_fs_imprecise",
                      "norm:mstatus_fs_no_dirty_track",
                      "norm:mstatus_fs_no_change_dirty",
                      "norm:mstatus_vs_imprecise",
                      "norm:mstatus_vs_no_change_dirty"
                    ]
                  },
                  {
                    "title": "Previous Expected Landing Pad (ELP) State in mstatus Register",
                    "id": "_previous_expected_landing_pad_elp_state_in_mstatus_register",
                    "children": [],
                    "tags": [
                      "norm:mstatus_spelp_mpelp_op",
                      "norm:mstatus_spelp_mpelp_enc_lead-in",
                      "norm:mstatus_spelp_mpelp_enc_list"
                    ]
                  }
                ],
                "tags": [
                  "norm:mstatus_sz_acc",
                  "norm:mstatush_sz_acc",
                  "norm:mstatush_enc"
                ]
              },
              {
                "title": "Machine Trap-Vector Base-Address (mtvec) Register",
                "id": "_machine_trap_vector_base_address_mtvec_register",
                "children": [],
                "tags": [
                  "norm:mtvec_sz_warl_acc",
                  "norm:mtvec_enc",
                  "norm:mtvec_mandatory",
                  "norm:mtvec_rdonly",
                  "norm:mtvec_base_align_4B",
                  "norm:mtvec_base_align_func_mode",
                  "norm:mtvec_mode_enc",
                  "norm:mtvec_mode_direct_op",
                  "norm:mtvec_mode_vectored_op",
                  "norm:rst_and_nmi_addr"
                ]
              },
              {
                "title": "Machine Trap Delegation (medeleg and mideleg) Registers",
                "id": "_machine_trap_delegation_medeleg_and_mideleg_registers",
                "children": [],
                "tags": [
                  "norm:trap_def_M-mode",
                  "norm:medeleg_mideleg_op1",
                  "norm:medeleg_sz_acc",
                  "norm:mideleg_sz_acc",
                  "norm:medeleg_mideleg_mandatory_S-mode",
                  "norm:medeleg_mideleg_op2",
                  "norm:medeleg_mideleg_omit_wo_S-mode",
                  "norm:trap_del_S-mode",
                  "norm:trap_del_S-mode_op",
                  "norm:trap_del_S-mode_no_M-mode",
                  "norm:medeleg_mideleg_warl",
                  "norm:medeleg_no_rd1",
                  "norm:mideleg_no_rd1",
                  "norm:mideleg_rd1_lower_level",
                  "norm:trap_never_trans_lower",
                  "norm:trap_horiz",
                  "norm:trap_del_intr_priv_lvl",
                  "norm:medeleg_enc_img",
                  "norm:medeleg_enc_txt",
                  "norm:medelegh_sz_acc_enc_xlen32",
                  "norm:medelegh_omit_xlen64",
                  "norm:mideleg_enc_img",
                  "norm:mideleg_enc_txt",
                  "norm:medeleg_when_rd0",
                  "norm:medeleg_16_no_rd0"
                ]
              },
              {
                "title": "Machine Interrupt (mip and mie) Registers",
                "id": "_machine_interrupt_mip_and_mie_registers",
                "children": [],
                "tags": [
                  "norm:mip_sz_acc",
                  "norm:mie_sz_acc",
                  "norm:mip_mie_enc_txt",
                  "norm:mip_enc_img",
                  "norm:mie_enc_img",
                  "norm:intr_mip_mie_op",
                  "norm:intr_mip_mie_bounded_time",
                  "norm:intr_mip_mie_xret_csrwr",
                  "norm:intr_M-mode_highest_pri",
                  "norm:mip_bits_wr_or_rdonly",
                  "norm:mip_bits_wr_op",
                  "norm:mip_bits_rdonly_op",
                  "norm:mie_bits_wr",
                  "norm:mie_bits_rdonly0",
                  "norm:mip_mie_std_enc_txt",
                  "norm:mip_std_enc_img",
                  "norm:mie_std_enc_img",
                  "norm:mip_meip_mie_meie_op",
                  "norm:mip_meip_rdonly",
                  "norm:mip_mtip_mie_mtie_op",
                  "norm:mip_mtip_rdonly",
                  "norm:mip_msip_mie_msie_op",
                  "norm:mip_msip_rdonly",
                  "norm:msip_sz_acc",
                  "norm:msip_enc",
                  "norm:msip_update_max_time",
                  "norm:mip_msip_mie_msie_maybe_rdonly0",
                  "norm:mip_sxip_mie_sxie_rdonly0",
                  "norm:mip_seip_mie_seie_op",
                  "norm:mip_seip_acc",
                  "norm:intr_sei_op",
                  "norm:mip_seip_rdcsr",
                  "norm:mip_seip_wrcsr",
                  "norm:mip_stip_mie_stie_op",
                  "norm:mip_stip_no-stimecmp_acc",
                  "norm:mip_stip_no-stimecmp_op2",
                  "norm:mip_stip_stimecmp_acc",
                  "norm:mip_stip_stimecmp_op2",
                  "norm:mip_stip_stimecmp_clr",
                  "norm:mip_ssip_mie_ssie_op",
                  "norm:mip_ssip_acc",
                  "norm:mip_ssip_intr_ctrl",
                  "norm:mip_lcofip_mie_lcofie_op",
                  "norm:mip_lcofip_acc",
                  "norm:mip_lcofip_op2",
                  "norm:mip_lcofip_mie_lcofie_rdonly0",
                  "norm:intr_M-mode_pri"
                ]
              },
              {
                "title": "Hardware Performance Monitor",
                "id": "_hardware_performance_monitor",
                "children": [],
                "tags": [
                  "norm:m_mode_perf_monitoring",
                  "norm:mcycle_op",
                  "norm:minstret_op",
                  "norm:mcycle_minstret_sz",
                  "norm:mcycle_minstret_rst",
                  "norm:mcycle_minstret_wr",
                  "norm:mcycle_shared",
                  "norm:mhpmcounter_num",
                  "norm:mhpmevent_sz_warl_op",
                  "norm:mhpmevent_enc",
                  "norm:mhpmcounter_mandatory",
                  "norm:mhpmcounter_mhpmevent_rdonly0",
                  "norm:mhpmcounter_warl",
                  "norm:mhpmcounter_sz",
                  "norm:mcycleh_minstreth_mhpmh_op",
                  "norm:mhpmeventh_presence"
                ]
              },
              {
                "title": "Machine Counter-Enable (mcounteren) Register",
                "id": "mcounteren",
                "children": [],
                "tags": [
                  "norm:mcounteren_sz",
                  "norm:mcounteren_op",
                  "norm:mcounteren_enc_img",
                  "norm:mcounteren_inc_inaccessible",
                  "norm:mcounteren_clr_ill_inst_exc",
                  "norm:mcounteren_set_nxt_priv",
                  "norm:mcounteren_tm_clr",
                  "norm:mcounteren_tm_set",
                  "norm:cycle_instret_hpmcounter_op_rdonly",
                  "norm:time_op_rdonly",
                  "norm:cycleh_instreth_hpmcounternh_op_rdonly",
                  "norm:timeh_op_rdonly",
                  "norm:time_csr_architectural_availability",
                  "norm:mcounteren_flds_mandatory_warl",
                  "norm:mcounteren_flds_rdonly0",
                  "norm:mcounteren_presence"
                ]
              },
              {
                "title": "Machine Counter-Inhibit (mcountinhibit) Register",
                "id": "_machine_counter_inhibit_mcountinhibit_register",
                "children": [],
                "tags": [
                  "norm:mcountinhibit_enc_img",
                  "norm:mcountinhibit_sz_warl_op1",
                  "norm:mcountinhibit_only_inc",
                  "norm:mcountinhibit_op2",
                  "norm:mcountinhibit_cy_shared",
                  "norm:mcountinhibit_not_impl"
                ]
              },
              {
                "title": "Machine Scratch (mscratch) Register",
                "id": "_machine_scratch_mscratch_register",
                "children": [],
                "tags": [
                  "norm:mscratch_sz_acc",
                  "norm:mscratch_enc_img"
                ]
              },
              {
                "title": "Machine Exception Program Counter (mepc) Register",
                "id": "_machine_exception_program_counter_mepc_register",
                "children": [],
                "tags": [
                  "norm:mepc_sz_acc",
                  "norm:mepc_align",
                  "norm:mepc_bit1_dyn_ialign_op",
                  "norm:mepc_warl",
                  "norm:mepc_inv_addr_conv",
                  "norm:mepc_op",
                  "norm:mepc_enc_img"
                ]
              },
              {
                "title": "Machine Cause (mcause) Register",
                "id": "mcause",
                "children": [],
                "tags": [
                  "norm:mcause_sz_acc",
                  "norm:mcause_op",
                  "norm:mcause_intr_op",
                  "norm:mcause_exccode_op",
                  "norm:mcause_exccode_wlrl",
                  "norm:mcause_enc_img",
                  "norm:mcause_exccode_ld_ldrsv",
                  "norm:mcause_exccode_st_sc_amo",
                  "norm:mcause_exccode_pri1",
                  "norm:mcause_exccode_enc_img",
                  "norm:exc_priority",
                  "norm:mcause_exccode_pri2"
                ]
              },
              {
                "title": "Machine Trap Value (mtval) Register",
                "id": "_machine_trap_value_mtval_register",
                "children": [],
                "tags": [
                  "norm:mtval_sz_acc",
                  "norm:mtval_op",
                  "norm:mtval_per_exc_behavior",
                  "norm:mtval_rdonly0",
                  "norm:mtval_vaddr_wr1",
                  "norm:mtval_vaddr_not_paddr",
                  "norm:mtval_enc_img",
                  "norm:mtval_vaddr_wr2",
                  "norm:mtval_varlen_wr",
                  "norm:mepc_varlen_wr",
                  "norm:mtval_instr_bits_lead-in",
                  "norm:mtval_instr_bits_list",
                  "norm:mtval_ill_instr_exc_in_low_bits",
                  "norm:mtval_swchk_lead-in",
                  "norm:mtval_swchk_list",
                  "norm:mtval_other_traps_zero",
                  "norm:mtval_warl",
                  "norm:mtval_vaddr_and_0_sz",
                  "norm:mtval_inv_addr_conv",
                  "norm:mtval_instr_bits_sz"
                ]
              },
              {
                "title": "Machine Configuration Pointer (mconfigptr) Register",
                "id": "_machine_configuration_pointer_mconfigptr_register",
                "children": [],
                "tags": [
                  "norm:mconfigptr_sz_acc",
                  "norm:mconfigptr_op",
                  "norm:mconfigptr_enc_img",
                  "norm:mconfigptr_align",
                  "norm:mconfigptr_mandatory",
                  "norm:mconfigptr_zero"
                ]
              },
              {
                "title": "Machine Environment Configuration (menvcfg) Register",
                "id": "sec:menvcfg",
                "children": [],
                "tags": [
                  "norm:menvcfg_sz_acc",
                  "norm:menvcfg_op",
                  "norm:menvcfg_enc_img",
                  "norm:menvcfg_fiom_fence_op",
                  "norm:menvcfg_fiom_atomic_op",
                  "norm:menvcfg_fiom_rdonly0_ok",
                  "norm:menvcfg_fiom_fence_presuc_op",
                  "norm:menvcfg_pbmte_op",
                  "norm:menvcfg_pbmte_rdonly0",
                  "norm:menvcfg_pbmte_henvcfg_pbmte_rdonly0",
                  "norm:menvcfg_pbmte_fence",
                  "norm:menvcfg_adue_op",
                  "norm:menvcfg_adue_rdonly0",
                  "norm:menvcfg_adue_henvcfg_adue_rdonly0",
                  "norm:menvcfg_adue_fence",
                  "norm:menvcfg_cde_op",
                  "norm:menvcfg_cde_rdonly0",
                  "norm:menvcfg_stce_op1",
                  "norm:menvcfg_stce_rdonly0",
                  "norm:menvcfg_stce_op2",
                  "norm:menvcfg_cbze_op",
                  "norm:menvcfg_cbze_rdonly0",
                  "norm:menvcfg_cbcfe_op",
                  "norm:menvcfg_cbcfe_rdonly0",
                  "norm:menvcfg_cbie_warl_op",
                  "norm:menvcfg_cbie_rdonly0",
                  "norm:menvcfg_cbie_cbo-inval_op_lead-in",
                  "norm:menvcfg_cbie_cbo-inval_op_list",
                  "norm:menvcfg_pmm_op",
                  "norm:menvcfg_pmm_rdonly0",
                  "norm:menvcfg_pmm_enc",
                  "norm:menvcfg_lpe_op_lead-in",
                  "norm:menvcfg_lpe_op_list",
                  "norm:menvcfg_sse_op_lead-in",
                  "norm:menvcfg_sse_op_list",
                  "norm:menvcfg_sse_rdonly0",
                  "norm:menvcfg_dte_op",
                  "norm:menvcfgh_sz_acc_op",
                  "norm:menvcfg_menvcfgh_no_U-mode"
                ]
              },
              {
                "title": "Machine Security Configuration (mseccfg) Register",
                "id": "sec:mseccfg",
                "children": [],
                "tags": [
                  "norm:mseccfg_sz_acc",
                  "norm:mseccfg_presence",
                  "norm:mseccfg_enc_img",
                  "norm:mseccfg_sseed_useed_presence",
                  "norm:mseccfg_useed_U-mode_op",
                  "norm:mseccfg_useed_rdonly0",
                  "norm:mseccfg_sseed_SorHS-mode_op",
                  "norm:mseccfg_sseed_rdonly0",
                  "norm:mseccfg_sseed_VSorVU-mode_op",
                  "norm:mseccfg_sseed_useed_op_tbl",
                  "norm:mseccfg_rlb_mmwp_mml_presence",
                  "norm:mseccfg_rlb_op_warl",
                  "norm:mseccfg_mmwp_op_warl",
                  "norm:mseccfg_mml_warl",
                  "norm:mseccfg_mml_sticky",
                  "norm:mseccfg_mml_set",
                  "norm:mseccfg_mml_pmpcfg_L_op",
                  "norm:mseccfg_mml_M_rule_op",
                  "norm:mseccfg_mml_SorU_rule_op",
                  "norm:mseccfg_mml_shared_rule_op",
                  "norm:mseccfg_mml_shared_L0_op",
                  "norm:mseccfg_mml_shared_L1_op",
                  "norm:mseccfg_mml_shared_LRWX_1111_op",
                  "norm:mseccfg_mml_X_restrict",
                  "norm:mseccfg_mml_exec_code",
                  "norm:mseccfg_pmm_presence_op",
                  "norm:mseccfg_pmm_rdonly0",
                  "norm:mseccfg_pmm_enc",
                  "norm:mseccfg_mlpe_presence",
                  "norm:mseccfg_mlpe_set_op",
                  "norm:mseccfg_mlpe_clr_op_lead-in",
                  "norm:mseccfg_mlpe_clr_op_list",
                  "norm:mseccfgh_sz_acc_op",
                  "norm:mseccfgh_presence"
                ]
              }
            ],
            "tags": [
              "norm:M_access_all_lower_priv_CSRs"
            ]
          },
          {
            "title": "Machine-Level Memory-Mapped Registers",
            "id": "_machine_level_memory_mapped_registers",
            "children": [
              {
                "title": "Machine Timer (mtime and mtimecmp) Registers",
                "id": "_machine_timer_mtime_and_mtimecmp_registers",
                "children": [],
                "tags": [
                  "norm:mtime_acc",
                  "norm:mtime_op",
                  "norm:mtime_tick_period",
                  "norm:mtime_wrap",
                  "norm:mtime_sz",
                  "norm:mtimecmp_sz",
                  "norm:mtime_intr_pending",
                  "norm:mtime_intr_taken",
                  "norm:mtime_enc_img",
                  "norm:mtimecmp_enc_img",
                  "norm:mtime_intr_mtip_visibility",
                  "norm:mtimecmp_rv32_wr",
                  "norm:mtime_mtimecmp_rv64_wr",
                  "norm:time_timeh_visibility_mtime"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Machine-Mode Privileged Instructions",
            "id": "_machine_mode_privileged_instructions",
            "children": [
              {
                "title": "Environment Call and Breakpoint",
                "id": "_environment_call_and_breakpoint",
                "children": [],
                "tags": [
                  "norm:ecall_op2",
                  "norm:ebreak_op2",
                  "norm:ecall_ebreak_epc_value",
                  "norm:ecall_ebreak_no_minstret_inc"
                ]
              },
              {
                "title": "Trap-Return Instructions",
                "id": "otherpriv",
                "children": [],
                "tags": [
                  "norm:xret_enc_img",
                  "norm:mret_presence",
                  "norm:sret_presence",
                  "norm:sret_ill_inst_exc_rst",
                  "norm:xret_in_higher_mode",
                  "norm:xret_in_lower_mode",
                  "norm:xret_op",
                  "norm:xret_clr_lr_resv"
                ]
              },
              {
                "title": "Wait for Interrupt",
                "id": "wfi",
                "children": [],
                "tags": [
                  "norm:wfi_op",
                  "norm:wfi_all_privileged_modes",
                  "norm:wfi_opt_U_mode",
                  "norm:wfi_ill_exc",
                  "norm:wfi_enc_img",
                  "norm:wfi_mepc_val",
                  "norm:wfi_resume_reason",
                  "norm:wfi_intr_dis",
                  "norm:wfi_unaffected_conditions",
                  "norm:wfi_no_intr_pc"
                ]
              },
              {
                "title": "Custom SYSTEM Instructions",
                "id": "_custom_system_instructions",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Reset",
            "id": "reset",
            "children": [],
            "tags": [
              "norm:M-mode_at_rst2",
              "norm:mstatus_mie_mprv_rst",
              "norm:mstatus_mstatush_mbe_rst",
              "norm:misa_extensions_rst2",
              "norm:ld_rsv_rst",
              "norm:pc_rst",
              "norm:mcause_rst1_val",
              "norm:pmp_A_L_rst",
              "norm:hgatp_vsatp_mode_rst",
              "norm:mnstatus_nmie_rst",
              "norm:warl_rst",
              "norm:mseccfg_mlpe_rst",
              "norm:mseccfg_mml_mmwp_rlb_rst",
              "norm:mcause_rst2_val",
              "norm:mcause_rst_zero",
              "norm:mseccfg_useed_sseed_rst",
              "norm:mcause_rst_alias_ok"
            ]
          },
          {
            "title": "Non-Maskable Interrupts",
            "id": "nmi",
            "children": [],
            "tags": [
              "norm:nmi_op",
              "norm:nmi_mcause_val1",
              "norm:nmi_mcause_val2",
              "norm:nmi_mcause_restrictions",
              "norm:nmi_no_rst"
            ]
          },
          {
            "title": "Physical Memory Attributes",
            "id": "pma",
            "children": [
              {
                "title": "Main Memory versus I/O Regions",
                "id": "_main_memory_versus_io_regions",
                "children": [],
                "tags": [
                  "norm:pma_mm_vs_io_def"
                ]
              },
              {
                "title": "Supported Access Type PMAs",
                "id": "_supported_access_type_pmas",
                "children": [],
                "tags": [
                  "norm:pma_mm_rw",
                  "norm:pma_mm_ifetch",
                  "norm:pma_mm_mandatory_sz",
                  "norm:pma_io_rwx_per_sz",
                  "norm:pma_vm_hw_tbl_acc"
                ]
              },
              {
                "title": "Atomicity PMAs",
                "id": "_atomicity_pmas",
                "children": [
                  {
                    "title": "AMO PMA",
                    "id": "_amo_pma",
                    "children": [],
                    "tags": [
                      "norm:pma_amo_levels",
                      "norm:pma_amo_sz_support",
                      "norm:pma_amo_far_subset_proc",
                      "norm:pma_amo_zacas_levels1",
                      "norm:pma_amo_zacas_levels2",
                      "norm:pma_amo_zacas_req_arith",
                      "norm:pma_amo_zabha_req"
                    ]
                  },
                  {
                    "title": "Reservability PMA",
                    "id": "_reservability_pma",
                    "children": [],
                    "tags": [
                      "norm:pma_rsrv_levels"
                    ]
                  }
                ],
                "tags": [
                  "norm:pma_cache_mm_all_atomics"
                ]
              },
              {
                "title": "Misaligned Atomicity Granule PMA",
                "id": "_misaligned_atomicity_granule_pma",
                "children": [],
                "tags": [
                  "norm:pma_mag_def",
                  "norm:pma_mag_insts",
                  "norm:pma_mag_op_within",
                  "norm:pma_mag_op_amo",
                  "norm:pma_mag_op_ldst",
                  "norm:pma_mag_exc",
                  "norm:pma_mag_op_rsrv",
                  "norm:pma_mag_op_vec",
                  "norm:pma_mag_op_implicit"
                ]
              },
              {
                "title": "Memory-Ordering PMAs",
                "id": "_memory_ordering_pmas",
                "children": [],
                "tags": [
                  "norm:pma_mo_io_chan_def",
                  "norm:pma_mo_io_chan_0",
                  "norm:pma_mo_io_chan_1",
                  "norm:pma_mo_io_chan_other",
                  "norm:pma_mo_dyn"
                ]
              },
              {
                "title": "Coherence and Cacheability PMAs",
                "id": "_coherence_and_cacheability_pmas",
                "children": [],
                "tags": [
                  "norm:pma_non_cacheable",
                  "norm:uncached_ignores_cached"
                ]
              },
              {
                "title": "Idempotency PMAs",
                "id": "_idempotency_pmas",
                "children": [],
                "tags": [
                  "norm:pma_idp_mm",
                  "norm:pma_idp_no_spec",
                  "norm:pma_idp_misaligned_exc",
                  "norm:pma_idp_implicit_ok",
                  "norm:pma_idp_implicit_sz"
                ]
              }
            ],
            "tags": [
              "norm:pma_indep_exec_context",
              "norm:pma_rtcfg_mmr",
              "norm:pma_chk_paddr",
              "norm:pma_precise_recom",
              "norm:pma_imprecise_ok"
            ]
          },
          {
            "title": "Physical Memory Protection",
            "id": "pmp",
            "children": [
              {
                "title": "Physical Memory Protection CSRs",
                "id": "_physical_memory_protection_csrs",
                "children": [
                  {
                    "title": "Address Matching",
                    "id": "_address_matching",
                    "children": [],
                    "tags": [
                      "norm:pmp_a_field_encoding",
                      "norm:pmp_a_field_off",
                      "norm:pmp_a_field_napot_na4",
                      "norm:pmp_napot_encoding_low_bits",
                      "norm:pmp_a_field_tor",
                      "norm:pmp_region_granularity_g",
                      "norm:pmp_na4_select_restriction",
                      "norm:pmp_napot_addr_read_mask",
                      "norm:pmp_tor_off_addr_read_mask",
                      "norm:pmp_addr_retention_on_mode_change"
                    ]
                  },
                  {
                    "title": "Locking and Privilege Mode",
                    "id": "pmp-locking",
                    "children": [],
                    "tags": [
                      "norm:pmp_l_bit_function",
                      "norm:pmp_l_bit_write_protection",
                      "norm:pmp_l_bit_m_mode_enforcement"
                    ]
                  },
                  {
                    "title": "Priority and Matching Logic",
                    "id": "_priority_and_matching_logic",
                    "children": [],
                    "tags": [
                      "norm:pmp_misaligned_access_behavior",
                      "norm:pmp_entry_priority",
                      "norm:pmp_full_match_required",
                      "norm:pmp_rwx_check",
                      "norm:pmp_no_entry_match",
                      "norm:pmp_access_fault_exception"
                    ]
                  }
                ],
                "tags": [
                  "norm:pmp_entry_structure",
                  "norm:pmp_entry_count",
                  "norm:pmp_csrs_warl_access",
                  "norm:pmp_csr_mode",
                  "norm:pmp_cfg_rv32_layout",
                  "norm:pmp_cfg_rv64_layout",
                  "norm:pmp_cfg_rv64_illegal",
                  "norm:pmp_addr_registers",
                  "norm:pmp_addr_encoding",
                  "norm:pmp_addr_warl",
                  "norm:pmp_cfg_permissions",
                  "norm:pmp_rwx_warl",
                  "norm:pmp_exec_fault",
                  "norm:pmp_load_fault",
                  "norm:pmp_store_fault"
                ]
              },
              {
                "title": "Physical Memory Protection and Paging",
                "id": "pmp-vmem",
                "children": [],
                "tags": [
                  "norm:pmp_with_paging",
                  "norm:pmp_speculative_translations",
                  "norm:pmp_sfence_required"
                ]
              }
            ],
            "tags": [
              "norm:pmp_granularity",
              "norm:pmp_mmode_only_regions",
              "norm:pmp_check_priv_modes",
              "norm:pmp_check_pagetable_access",
              "norm:pmp_mmode_locking",
              "norm:pmp_violation_precise_trap"
            ]
          }
        ],
        "tags": [
          "norm:M_highest_priv_mode",
          "norm:M-mode_at_rst1"
        ]
      },
      {
        "title": "\"Smstateen/Ssstateen\" Extensions, Version 1.0",
        "id": "smstateen",
        "children": [
          {
            "title": "State Enable Extensions",
            "id": "_state_enable_extensions",
            "children": [],
            "tags": [
              "norm:smstateen_mmode_rv64_csrs",
              "norm:smstateen_smode_rv64_csrs",
              "norm:smstateen_hypervisor_rv64_csrs",
              "norm:smstateen_rv32_upper_bits_csrs",
              "norm:stateen_op",
              "norm:smstateen_illegal_state_access",
              "norm:smstateen_implicit_state_update",
              "norm:sstateen_user_access_control",
              "norm:sstateen_bit_allocation",
              "norm:sstateen_bit_correspondence",
              "norm:mstateen_bit_allocation",
              "norm:mstateen_bit_encroachment",
              "norm:sstateen_encroachment_bits_roz",
              "norm:hstateen_encoding",
              "norm:stateen_warl_access",
              "norm:stateen_unimplemented_state_roz",
              "norm:stateen-reserved_roz",
              "norm:sstateen_vsmode_access_roz",
              "norm:sstateen_ro1_bits",
              "norm:hstateen_ro1_bits",
              "norm:mstateen_zero_initialization",
              "norm:hstateen_sstateen_zero_initialization",
              "norm:mstateen-bit-63_op",
              "norm:hstateen-bit-63_op",
              "norm:mstateen-bit-63_roz",
              "norm:hstateen-bit-63_writable"
            ]
          },
          {
            "title": "State Enable 0 Registers",
            "id": "_state_enable_0_registers",
            "children": [],
            "tags": [
              "norm:stateen0-c_op",
              "norm:stateen0-fcsr_op",
              "norm:stateen0-fcsr0_misa-f0_illegal_fpu_instr",
              "norm:stateen0-jvt_op",
              "norm:mstateen0-se0_op",
              "norm:hstateen0-SE0_op",
              "norm:mstateen0-envcfg_op",
              "norm:hstateen0-envcfg_op",
              "norm:mstateen0-csrind_op",
              "norm:hstateen0-csrind_op",
              "norm:mstateen0-imsic_op",
              "norm:hstateen0-imsic_op",
              "norm:mstateen0-aia_op",
              "norm:hstateen0-aia_op",
              "norm:mstateen0-context_op",
              "norm:hstateen0-context_op",
              "norm:mstateen0-p1p13_op",
              "norm:mstateen0-srmcfg_op"
            ]
          },
          {
            "title": "Usage",
            "id": "_usage",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smcsrind/Sscsrind\" Indirect CSR Access, Version 1.0",
        "id": "indirect-csr",
        "children": [
          {
            "title": "Introduction",
            "id": "_introduction_2",
            "children": [],
            "tags": [
              "norm:csr_access",
              "norm:select_value_separate_address_space",
              "norm:select_value_unrelated",
              "norm:csrs_alias"
            ]
          },
          {
            "title": "Machine-level CSRs",
            "id": "body",
            "children": [],
            "tags": [
              "norm:miph_csr_number",
              "norm:miselect_op",
              "norm:miselect_value_range",
              "norm:miselect_WARL",
              "norm:miselect_min_sz",
              "norm:miselect-msb_op",
              "norm:mireg_access_on_legal_miselect",
              "norm:mireg_access_behaviour"
            ]
          },
          {
            "title": "Supervisor-level CSRs",
            "id": "_supervisor_level_csrs",
            "children": [],
            "tags": [
              "norm:siselect_min_range",
              "norm:siselect-msb_op",
              "norm:sireg_access_on_illegal_siselect",
              "norm:sireg_access_on_legal_siselect",
              "norm:sireg_access_behaviour",
              "norm:sscsrind_smode_csrs_sz"
            ]
          },
          {
            "title": "Virtual Supervisor-level CSRs",
            "id": "_virtual_supervisor_level_csrs",
            "children": [],
            "tags": [
              "norm:vsiselect_min_range",
              "norm:vsiselect-msb_op",
              "norm:sscsrind_virtual_inst_fault",
              "norm:vsireg_access_on_legal_vsiselect",
              "norm:vsireg_access_behaviour",
              "norm:vsmode_virtual_inst_fault",
              "norm:sscsrind_vsmode_csrs_sz"
            ]
          },
          {
            "title": "Access control by the state-enable CSRs",
            "id": "_access_control_by_the_state_enable_csrs",
            "children": [],
            "tags": [
              "norm:sscsrind_csrs_access_control",
              "norm:hypervisor_impl_csrs_access_control"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smepmp\" Extension for PMP Enhancements for memory access and execution prevention in Machine mode, Version 1.0",
        "id": "smepmp",
        "children": [
          {
            "title": "Threat model",
            "id": "smepmp_threat",
            "children": [],
            "tags": [
              "norm:smepmp_no_mml_limit",
              "norm:smepmp_no_mml_behavior",
              "norm:smepmp_machine_unlimited",
              "norm:smepmp_attack_surface"
            ]
          },
          {
            "title": "Smepmp Physical Memory Protection Rules",
            "id": "_smepmp_physical_memory_protection_rules",
            "children": [],
            "tags": [
              "norm:mseccfg_fields_exist",
              "norm:mml_truth_table"
            ]
          },
          {
            "title": "Smepmp software discovery",
            "id": "_smepmp_software_discovery",
            "children": [],
            "tags": [
              "norm:mseccfg_locking",
              "norm:bootrom_discovery"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smcntrpmf\" Cycle and Instret Privilege Mode Filtering, Version 1.0",
        "id": "smcntrpmf",
        "children": [
          {
            "title": "Introduction",
            "id": "_introduction_3",
            "children": [],
            "tags": []
          },
          {
            "title": "CSRs",
            "id": "_csrs",
            "children": [
              {
                "title": "Machine Counter Configuration (mcyclecfg, minstretcfg) Registers",
                "id": "_machine_counter_configuration_mcyclecfg_minstretcfg_registers",
                "children": [],
                "tags": [
                  "norm:mcyclecfg_sz",
                  "norm:mcyclecfg_op",
                  "norm:all_xinh_zero",
                  "norm:unimplemented_mode_bits",
                  "norm:rv32_high_access",
                  "norm:csr_supervisor_access"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Counter Behavior",
            "id": "_counter_behavior",
            "children": [],
            "tags": [
              "norm:counter_inhibited_behavior",
              "norm:transition_counting_defined",
              "norm:cycle_counting",
              "norm:instret_non_inhibited",
              "norm:instret_exception",
              "norm:instret_xret"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Smrnmi\" Extension for Resumable Non-Maskable Interrupts, Version 1.0",
        "id": "rnmi",
        "children": [
          {
            "title": "RNMI Interrupt Signals",
            "id": "_rnmi_interrupt_signals",
            "children": [],
            "tags": [
              "norm:rnmi_priority",
              "norm:rnmi_not_disabled"
            ]
          },
          {
            "title": "RNMI Handler Addresses",
            "id": "_rnmi_handler_addresses",
            "children": [],
            "tags": [
              "norm:rnmi_trap_addr",
              "norm:rnmi_exc_trap_addr"
            ]
          },
          {
            "title": "RNMI CSRs",
            "id": "_rnmi_csrs",
            "children": [],
            "tags": [
              "norm:mnscratch_sz",
              "norm:mnscratch_acc",
              "norm:mnscratch_op",
              "norm:mnepc_sz",
              "norm:mnepc_acc",
              "norm:mnepc_op",
              "norm:mnepc_bit0",
              "norm:mnepc_ialign32",
              "norm:mnepc_ialign_mask",
              "norm:mnepc_bit1_writable",
              "norm:mnepc_warl",
              "norm:mnepc_invalid_convert",
              "norm:mncause_op",
              "norm:mncause_interrupt",
              "norm:mncause_interrupt_code",
              "norm:mncause_interrupt_zero",
              "norm:mncause_doubletrap",
              "norm:mnstatus_mnpp_op",
              "norm:mnstatus_mnpv_op",
              "norm:mnstatus_mnpelp_op",
              "norm:mnstatus_mnpelp_update",
              "norm:mnstatus_nmie_enable",
              "norm:mnstatus_nmie_disable",
              "norm:mnstatus_mprv_clear",
              "norm:mnstatus_nmie_reset",
              "norm:mnstatus_nmie_set_clear",
              "norm:mnstatus_wfi",
              "norm:mnstatus_reserved"
            ]
          },
          {
            "title": "MNRET Instruction",
            "id": "_mnret_instruction",
            "children": [],
            "tags": [
              "norm:mnret_mode",
              "norm:mnret_restore",
              "norm:mnret_mprv",
              "norm:mnret_zicfilp"
            ]
          },
          {
            "title": "RNMI Operation",
            "id": "_rnmi_operation",
            "children": [],
            "tags": [
              "norm:rnmi_entry",
              "norm:rnmi_entry_cause",
              "norm:rnmi_entry_priv",
              "norm:rnmi_entry_nmie_clear",
              "norm:rnmi_enter_mmode",
              "norm:rnmi_resume",
              "norm:rnmi_exception_nmie0"
            ]
          }
        ],
        "tags": [
          "norm:Smrnmi_csrs",
          "norm:mnret_exist"
        ]
      },
      {
        "title": "\"Smcdeleg/Ssccfg\" Counter Delegation Extensions, Version 1.0",
        "id": "smcdeleg",
        "children": [
          {
            "title": "Counter Delegation",
            "id": "_counter_delegation",
            "children": [],
            "tags": [
              "norm:smcdeleg_cde_en",
              "norm:ssccfg_illegal_sireg_cde0",
              "norm:ssccfg_illegal_sireg3_6",
              "norm:ssccfg_illegal_sireg4_5_xlen64",
              "norm:ssccfg_illegal_sireg_not_delegated",
              "norm:ssccfg_missing_extension_illegal",
              "norm:ssccfg_hyp_vs_or_vu_access_vsireg_illegal",
              "norm:ssccfg_hyp_m_s_vsireg_illegal",
              "norm:ssccfg_hyp_vs_access_sireg_conditional"
            ]
          },
          {
            "title": "Supervisor Counter Inhibit (scountinhibit) Register",
            "id": "_supervisor_counter_inhibit_scountinhibit_register",
            "children": [],
            "tags": [
              "norm:ssccfg_scountinhibit_exists",
              "norm:ssccfg_scountinhibit_delegated_rw",
              "norm:ssccfg_scountinhibit_nondelegated_ro",
              "norm:ssccfg_illegal_scountinhibit_cde0",
              "norm:ssccfg_illegal_scountinhibit_vs_vu"
            ]
          },
          {
            "title": "Virtualizing scountovf",
            "id": "_virtualizing_scountovf",
            "children": [],
            "tags": [
              "norm:ssccfg_virtual_scountovf_vs_vu"
            ]
          },
          {
            "title": "Virtualizing Local-Counter-Overflow Interrupts",
            "id": "_virtualizing_local_counter_overflow_interrupts",
            "children": [],
            "tags": [
              "norm:ssccfg_lcofi_mvip_mvien",
              "norm:ssccfg_lcofi_hvip_hvien"
            ]
          }
        ],
        "tags": [
          "norm:smcdeleg_ssccfg_tandem"
        ]
      },
      {
        "title": "\"Smdbltrp\" Double Trap Extension, Version 1.0",
        "id": "smdbltrp",
        "children": [],
        "tags": [
          "norm:Smdbltrp_with_Smrnmi_op"
        ]
      },
      {
        "title": "\"Smctr\" Control Transfer Records Extension, Version 1.0",
        "id": "smctr",
        "children": [
          {
            "title": "CSRs",
            "id": "_csrs_2",
            "children": [
              {
                "title": "Machine Control Transfer Records Control Register (mctrctl)",
                "id": "_machine_control_transfer_records_control_register_mctrctl",
                "children": [],
                "tags": [
                  "norm:Ssctr_mctrctl-sz_acc_op",
                  "norm:mctrctl-mode_op",
                  "norm:mctrctl-rasemu_op",
                  "norm:mctrctl-mte_op",
                  "norm:mctrctl-ste_op",
                  "norm:mctrctl-bpfrz_op",
                  "norm:mctrctl-lcofifrz_op",
                  "norm:mctrctl-excinh_op",
                  "norm:mctrctl-intrinh_op",
                  "norm:mctrctl-tretinh_op",
                  "norm:mctrctl-ntbren_op",
                  "norm:mctrctl-tkbrinh_op",
                  "norm:mctrctl-indcallinh_op",
                  "norm:mctrctl-dircallinh_op",
                  "norm:mctrctl-indjmpinh_op",
                  "norm:mctrctl-dirjmpinh_op",
                  "norm:mctrctl-corswapinh_op",
                  "norm:mctrctl-retinh_op",
                  "norm:mctrctl-indljmpinh_op",
                  "norm:mctrctl-dirljmpinh_op",
                  "norm:mctrctl-custom_op",
                  "norm:mctrctl-impl"
                ]
              },
              {
                "title": "Supervisor Control Transfer Records Control Register (sctrctl)",
                "id": "_supervisor_control_transfer_records_control_register_sctrctl",
                "children": [],
                "tags": [
                  "norm:Ssctr_sctrctl_op",
                  "norm:Ssctr_sctrctl_acc"
                ]
              },
              {
                "title": "Virtual Supervisor Control Transfer Records Control Register (vsctrctl)",
                "id": "_virtual_supervisor_control_transfer_records_control_register_vsctrctl",
                "children": [],
                "tags": [
                  "norm:Ssctr_vsctrctl_sz_acc_op",
                  "norm:vsctr-s_op",
                  "norm:vsctrctl-u_op",
                  "norm:vsctrctl-ste_op",
                  "norm:vsctrctl-bpfrz_op",
                  "norm:vsctrctl-lcofifrz_op"
                ]
              },
              {
                "title": "Supervisor Control Transfer Records Depth Register (sctrdepth)",
                "id": "_supervisor_control_transfer_records_depth_register_sctrdepth",
                "children": [],
                "tags": [
                  "norm:sctrdepth",
                  "norm:sctrdepth_depth_op0",
                  "norm:sctrdepth_depth_op1",
                  "norm:sctrdepth_depth",
                  "norm:sctrdepth_mode"
                ]
              },
              {
                "title": "Supervisor Control Transfer Records Status Register (sctrstatus)",
                "id": "_supervisor_control_transfer_records_status_register_sctrstatus",
                "children": [],
                "tags": [
                  "norm:sctrstatus",
                  "norm:sctrstatus_wrptr",
                  "norm:sctrstatus-frozen_op",
                  "norm:Ssctr_sctrstatus_acc"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Entry Registers",
            "id": "_entry_registers",
            "children": [
              {
                "title": "Control Transfer Record Source Register (ctrsource)",
                "id": "_control_transfer_record_source_register_ctrsource",
                "children": [],
                "tags": [
                  "norm:ctrsource_op",
                  "norm:ctrsource_ctrtartget_ctrdata_Vbit",
                  "norm:Ssctr_ctrsource_sz_acc_op"
                ]
              },
              {
                "title": "Control Transfer Record Target Register (ctrtarget)",
                "id": "_control_transfer_record_target_register_ctrtarget",
                "children": [],
                "tags": [
                  "norm:ctrtarget_op",
                  "norm:ctrtarget_pc_next_br",
                  "norm:ctrtarget_misp",
                  "norm:ctrtarget_sz_acc"
                ]
              },
              {
                "title": "Control Transfer Record Metadata Register (ctrdata)",
                "id": "_control_transfer_record_metadata_register_ctrdata",
                "children": [],
                "tags": [
                  "norm:ctrdata_sz_acc",
                  "norm:ctrdata-type",
                  "norm:ctrdata-ccv",
                  "norm:ctrdata-cc",
                  "norm:ctrdata_undef"
                ]
              }
            ],
            "tags": [
              "norm:siselect_acc_op",
              "norm:vsiselect_op"
            ]
          },
          {
            "title": "Instructions",
            "id": "_instructions",
            "children": [
              {
                "title": "Supervisor CTR Clear Instruction",
                "id": "_supervisor_ctr_clear_instruction",
                "children": [],
                "tags": [
                  "norm:sctrclr_op1",
                  "norm:sctrclr_op2",
                  "norm:sctrclr_acc",
                  "norm:sctrclr_exceptions"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "State Enable Access Control",
            "id": "_state_enable_access_control",
            "children": [],
            "tags": [
              "norm:mstateen_ctr1",
              "norm:mstateen_ctr0",
              "norm:mstateen_ctr0_execpt1",
              "norm:mstateen_ctr0_execpt2",
              "norm:mstateen_ctr0_execpt3",
              "norm:mstateen_ctr0_qualified_transfer",
              "norm:hstateen_ctr",
              "norm:hstateen_vs",
              "norm:hstateen0_CTR0-V1_op"
            ]
          },
          {
            "title": "Behavior",
            "id": "_behavior",
            "children": [
              {
                "title": "Privilege Mode Transitions",
                "id": "_privilege_mode_transitions",
                "children": [
                  {
                    "title": "Virtualization Mode Transitions",
                    "id": "_virtualization_mode_transitions",
                    "children": [],
                    "tags": []
                  },
                  {
                    "title": "External Traps",
                    "id": "_external_traps",
                    "children": [],
                    "tags": [
                      "norm:exttrap_def",
                      "norm:exttrap_requirements",
                      "norm:exttrap_us",
                      "norm:exttrap_um",
                      "norm:exttrap_sm",
                      "norm:exttrap_vuvs",
                      "norm:exttrap_vuhs",
                      "norm:exttrap_vum",
                      "norm:exttrap_vshs",
                      "norm:exttrap_vsm",
                      "norm:exttrap_ctrtarget0",
                      "norm:exttrap_implreq"
                    ]
                  }
                ],
                "tags": [
                  "norm:trap_enabled",
                  "norm:trap_disabled_src",
                  "norm:trap_disabled_tgt",
                  "norm:trapret_enabled",
                  "norm:trapret_to_disabled",
                  "norm:trapret_from_disabled",
                  "norm:debug_recording_inhibited",
                  "norm:trap_ee",
                  "norm:trap_ed",
                  "norm:trap_de",
                  "norm:trap_dd",
                  "norm:trapret_ee",
                  "norm:trapret_ed",
                  "norm:trapret_de",
                  "norm:trapret_dd"
                ]
              },
              {
                "title": "Transfer Type Filtering",
                "id": "_transfer_type_filtering",
                "children": [],
                "tags": [
                  "norm:ttf_default",
                  "norm:ttype0",
                  "norm:ttype1",
                  "norm:ttype2",
                  "norm:ttype3",
                  "norm:ttype4",
                  "norm:ttype5",
                  "norm:ttype8",
                  "norm:ttype9",
                  "norm:ttype10",
                  "norm:ttype11",
                  "norm:ttype12",
                  "norm:ttype13",
                  "norm:ttype14",
                  "norm:ttype15",
                  "norm:various_jump_enc"
                ]
              },
              {
                "title": "Cycle Counting",
                "id": "_cycle_counting",
                "children": [],
                "tags": [
                  "norm:ctrdata_cc_supported",
                  "norm:ccounter_inc",
                  "norm:ccounter_reset",
                  "norm:ccounter_impl",
                  "norm:ccsize0",
                  "norm:ccsize1",
                  "norm:ccsize2",
                  "norm:ccsize3",
                  "norm:ccsize4",
                  "norm:ccounter_sat",
                  "norm:ccounter_ccv"
                ]
              },
              {
                "title": "RAS (Return Address Stack) Emulation Mode",
                "id": "_ras_return_address_stack_emulation_mode",
                "children": [],
                "tags": [
                  "norm:ctrctl_rasemu_op"
                ]
              },
              {
                "title": "Freeze",
                "id": "_freeze",
                "children": [],
                "tags": [
                  "norm:sctrstatus-frozen_set",
                  "norm:freeze_bp",
                  "norm:freeze_vs"
                ]
              }
            ],
            "tags": [
              "norm:ctr_behavior",
              "norm:ctr_behavior_criteria0",
              "norm:ctr_behavior_criteri1",
              "norm:ctr_behavior_criteria2",
              "norm:ctr_behavior_criteria3",
              "norm:ctr_stack",
              "norm:ctr_validbit"
            ]
          },
          {
            "title": "Custom Extensions",
            "id": "_custom_extensions",
            "children": [],
            "tags": [
              "norm:custom_bits"
            ]
          }
        ],
        "tags": [
          "norm:ctr_depth",
          "norm:Smctr_recording_criteria",
          "norm:Smctr_transfer_steps",
          "norm:Smctr_CTR_CSR_interface",
          "norm:Smctr_scope",
          "norm:Ssctr_transfer_steps",
          "norm:Smctr_Ssctr_depend"
        ]
      },
      {
        "title": "Supervisor-Level ISA, Version 1.13",
        "id": "supervisor",
        "children": [
          {
            "title": "Supervisor CSRs",
            "id": "_supervisor_csrs",
            "children": [
              {
                "title": "Supervisor Status (sstatus) Register",
                "id": "sstatus",
                "children": [
                  {
                    "title": "Base ISA Control in sstatus Register",
                    "id": "_base_isa_control_in_sstatus_register",
                    "children": [],
                    "tags": [
                      "norm:sstatus-uxl",
                      "norm:sstatus_uxl_sz",
                      "norm:sstatus-uxl_behavior",
                      "norm:hint_sxlen"
                    ]
                  },
                  {
                    "title": "Memory Privilege in sstatus Register",
                    "id": "sum",
                    "children": [],
                    "tags": [
                      "norm:sstatus-mxr",
                      "norm:sstatus-sum",
                      "norm:sstatus-sum_satp-mode"
                    ]
                  },
                  {
                    "title": "Endianness Control in sstatus Register",
                    "id": "_endianness_control_in_sstatus_register",
                    "children": [],
                    "tags": [
                      "norm:sstatus_ube",
                      "norm:sstatus_ube_implicit"
                    ]
                  },
                  {
                    "title": "Previous Expected Landing Pad (ELP) State in sstatus Register",
                    "id": "_previous_expected_landing_pad_elp_state_in_sstatus_register",
                    "children": [],
                    "tags": [
                      "norm:sstatus-spelp"
                    ]
                  },
                  {
                    "title": "Double Trap Control in sstatus Register",
                    "id": "supv-double-trap",
                    "children": [],
                    "tags": [
                      "norm:sstatus_sdt",
                      "norm:sstatus_sdt_sstatus_sie_overwrite",
                      "norm:sstatus_sdt_trap",
                      "norm:sstatus_sdt_sret"
                    ]
                  }
                ],
                "tags": [
                  "norm:sstatus",
                  "norm:sstatus-spp",
                  "norm:sstatus-sie",
                  "norm:sstatus-spie"
                ]
              },
              {
                "title": "Supervisor Trap Vector Base Address (stvec)  Register",
                "id": "_supervisor_trap_vector_base_address_stvec_register",
                "children": [],
                "tags": [
                  "norm:stvec",
                  "norm:stvec_op",
                  "norm:stvec_sz_base"
                ]
              },
              {
                "title": "Supervisor Interrupt (sip and sie) Registers",
                "id": "_supervisor_interrupt_sip_and_sie_registers",
                "children": [],
                "tags": [
                  "norm:sip_sie",
                  "norm:sie_sip_supervisor_strap",
                  "norm:sie_sip_strap_time_constraint",
                  "norm:s_interrupt_priority",
                  "norm:sip_acc",
                  "norm:sip_op",
                  "norm:sie_acc",
                  "norm:sip_sie_bits_sz",
                  "norm:sip-seip_sie-seie",
                  "norm:sip-stip_sie-stie",
                  "norm:sip-ssip_sie-ssie",
                  "norm:sip_sie_Sscofpmf",
                  "norm:sip_sie_unimpl",
                  "norm:sip_sie_priority_bit_order"
                ]
              },
              {
                "title": "Supervisor Timers and Performance Counters",
                "id": "_supervisor_timers_and_performance_counters",
                "children": [],
                "tags": [
                  "norm:supervisor_timer_scheduling"
                ]
              },
              {
                "title": "Counter-Enable (scounteren) Register",
                "id": "_counter_enable_scounteren_register",
                "children": [],
                "tags": [
                  "norm:scounteren",
                  "norm:scounteren_op",
                  "norm:scounteren_acc"
                ]
              },
              {
                "title": "Supervisor Scratch (sscratch) Register",
                "id": "_supervisor_scratch_sscratch_register",
                "children": [],
                "tags": [
                  "norm:sscratch"
                ]
              },
              {
                "title": "Supervisor Exception Program Counter (sepc) Register",
                "id": "_supervisor_exception_program_counter_sepc_register",
                "children": [],
                "tags": [
                  "norm:sepc",
                  "norm:sepc_op_mask_ialign32",
                  "norm:sepc_acc_invalid_addr",
                  "norm:sepc_op_trap_write"
                ]
              },
              {
                "title": "Supervisor Cause (scause) Register",
                "id": "scause",
                "children": [],
                "tags": [
                  "norm:scause",
                  "norm:scause_exception_code_acc",
                  "norm:scause-exception_code_sz",
                  "norm:scause-interrupt"
                ]
              },
              {
                "title": "Supervisor Trap Value (stval) Register",
                "id": "_supervisor_trap_value_stval_register",
                "children": [],
                "tags": [
                  "norm:stval",
                  "norm:stval_op_faulting_addr",
                  "norm:stval_op_breakpoint",
                  "norm:stval_op_load_store_fault",
                  "norm:stval_faulting_address_variable_instr",
                  "norm:stval_op_illegal_instr",
                  "norm:stval_op_illegal_instr_format",
                  "norm:stval_exception_info",
                  "norm:stval_op_other_traps",
                  "norm:stval_acc"
                ]
              },
              {
                "title": "Supervisor Environment Configuration (senvcfg) Register",
                "id": "sec:senvcfg",
                "children": [],
                "tags": [
                  "norm:senvcfg",
                  "norm:senvcfg-fiom",
                  "norm:senvcfg-fiom_op_atomic",
                  "norm:senvcfg-fiom_acc",
                  "norm:senvcfg-cbze",
                  "norm:senvcfg-cbcfe",
                  "norm:senvcfg_cbie",
                  "norm:cbo-inval_s-mode_op0",
                  "norm:cbo-inval_s-mode_op1",
                  "norm:cbo-inval_s-mode_op2",
                  "norm:senvcfg-pmm_Ssnpm",
                  "norm:senvcfg-lpe_Zicfilp",
                  "norm:senvcfg-sse_Zicfilp"
                ]
              },
              {
                "title": "Supervisor Address Translation and Protection (satp) Register",
                "id": "satp",
                "children": [],
                "tags": [
                  "norm:satp",
                  "norm:satp-mode",
                  "norm:satp-mode_sxlen32",
                  "norm:satp-mode_sxlen64",
                  "norm:satp-mode_op_unsupported",
                  "norm:satp_asidlen",
                  "norm:satp_op_active",
                  "norm:satp_op_sfence-vma"
                ]
              },
              {
                "title": "Supervisor Timer (stimecmp) Register",
                "id": "stimecmp",
                "children": [],
                "tags": [
                  "norm:stimecmp-stimecmph_sz_acc",
                  "norm:mip_sip-stip_op"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Supervisor Instructions",
            "id": "_supervisor_instructions",
            "children": [
              {
                "title": "Supervisor Memory-Management Fence Instruction",
                "id": "sfence.vma",
                "children": [],
                "tags": [
                  "norm:sfence-vma_ordering",
                  "norm:sfence-vma_invalidation",
                  "norm:sfence-vma_op",
                  "norm:sfence-vma_all_asid_va",
                  "norm:sfence-vma_asid_only",
                  "norm:sfence-vma_va_all_asid",
                  "norm:sfence-vma_va_asid",
                  "norm:sfence-vma_invalid_va",
                  "norm:sfence-vma_rs2_bits",
                  "norm:sfence-vma_ordering_semantics",
                  "norm:sfence-vma_implicit_access",
                  "norm:sfence-vma-sum-mxr_effect",
                  "norm:sfence-vma-mode_effect",
                  "norm:sfence-vma-asid_effect",
                  "norm:asid_hart_private",
                  "norm:satp_mode_roz_sfence_illegal"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Sv32: Page-Based 32-bit Virtual-Memory Systems",
            "id": "sv32",
            "children": [
              {
                "title": "Addressing and Memory Protection",
                "id": "translation",
                "children": [],
                "tags": [
                  "norm:satp-ppn_sv32_sz",
                  "norm:fetch_page_fault_no_x",
                  "norm:load_page_fault_no_r",
                  "norm:store_page_fault_no_w"
                ]
              },
              {
                "title": "Virtual Address Translation Process",
                "id": "sv32algorithm",
                "children": [],
                "tags": []
              }
            ],
            "tags": []
          },
          {
            "title": "Sv39: Page-Based 39-bit Virtual-Memory System",
            "id": "sv39",
            "children": [
              {
                "title": "Addressing and Memory Protection",
                "id": "addressing-and-memory-protection",
                "children": [],
                "tags": [
                  "norm:Sv39_va_signext",
                  "norm:Sv39_vpn_sz",
                  "norm:satp-ppn_sv39_sz",
                  "norm:Sv39_levels",
                  "norm:Sv39_page_offset_sz",
                  "norm:Sv39_pte_count",
                  "norm:Sv39_pte_sz",
                  "norm:Sv39_pt_sz",
                  "norm:Sv39_pt_align",
                  "norm:Sv39_pte_svnapot_rsv",
                  "norm:Sv39_pte_svpbmt_rsv",
                  "norm:Sv39_pte_future_rsv",
                  "norm:Sv39_leaf_any_level",
                  "norm:Sv39_page_sizes",
                  "norm:Sv39_superpage_align",
                  "norm:Sv39_superpage_align_fault",
                  "norm:Sv39_LEVELS",
                  "norm:Sv39_PTESIZE"
                ]
              }
            ],
            "tags": [
              "norm:Sv39_sxlen",
              "norm:Sv39_va_sz"
            ]
          },
          {
            "title": "Sv48: Page-Based 48-bit Virtual-Memory System",
            "id": "sv48",
            "children": [
              {
                "title": "Addressing and Memory Protection",
                "id": "addressing-and-memory-protection-1",
                "children": [],
                "tags": [
                  "norm:Sv48_va_signext",
                  "norm:Sv48_vpn_sz",
                  "norm:satp-ppn_sv48_sz",
                  "norm:Sv48_levels",
                  "norm:Sv48_page_offset_sz",
                  "norm:Sv48_leaf_any_level",
                  "norm:Sv48_page_sizes",
                  "norm:Sv48_superpage_align",
                  "norm:Sv48_superpage_align_fault",
                  "norm:Sv48_LEVELS",
                  "norm:Sv48_PTESIZE"
                ]
              }
            ],
            "tags": [
              "norm:Sv48_sxlen",
              "norm:Sv48_va_sz",
              "norm:Sv48_requires_Sv39"
            ]
          },
          {
            "title": "Sv57: Page-Based 57-bit Virtual-Memory System",
            "id": "sv57",
            "children": [
              {
                "title": "Addressing and Memory Protection",
                "id": "addressing-and-memory-protection-2",
                "children": [],
                "tags": [
                  "norm:Sv57_va_signext",
                  "norm:Sv57_vpn_sz",
                  "norm:satp-ppn_sv57_sz",
                  "norm:Sv57_levels",
                  "norm:Sv57_page_offset_sz",
                  "norm:Sv57_leaf_any_level",
                  "norm:Sv57_page_sizes",
                  "norm:Sv57_superpage_align",
                  "norm:Sv57_superpage_align_fault",
                  "norm:Sv57_LEVELS",
                  "norm:Sv57_PTESIZE"
                ]
              }
            ],
            "tags": [
              "norm:Sv57_sxlen",
              "norm:Sv57_va_sz",
              "norm:Sv57_requires_Sv48"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"Svnapot\" Extension for NAPOT Translation Contiguity, Version 1.0",
        "id": "svnapot",
        "children": [],
        "tags": [
          "norm:Svnapot_pte_N",
          "norm:Svnapot_range_napot",
          "norm:Svnapot_depends_Sv39",
          "norm:Svnapot_valid_encoding",
          "norm:Svnapot_implicit_read_ppn_subst",
          "norm:Svnapot_reserved_encoding_fault",
          "norm:Svnapot_cache_entries",
          "norm:Svnapot_hyp_gstage"
        ]
      },
      {
        "title": "\"Svpbmt\" Extension for Page-Based Memory Types, Version 1.0",
        "id": "svpbmt",
        "children": [],
        "tags": [
          "norm:Svpbmt_depends_Sv39",
          "norm:Svpbmt_impl_may_override_pmas",
          "norm:Svpbmt_nonleaf_pte_pbmt_must_be_zero",
          "norm:Svpbmt_leaf_pte_pbmt_reserved_3_fault",
          "norm:Svpbmt_obeys_mem_ordering",
          "norm:Svpbmt_io_pma_nc_pbmt_obey_rvwmo",
          "norm:Svpbmt_io_pma_nc_pbmt_treated_as_io_and_memory",
          "norm:Svpbmt_memory_pma_io_pbmt_strong_io_ordering",
          "norm:Svpbmt_memory_pma_io_pbmt_treated_as_io_and_memory",
          "norm:Svpbmt_aliasing_attribute",
          "norm:Svpbmt_noncacheable_aliasing_no_coherence_loss",
          "norm:Svpbmt_noncacheable_aliasing_may_weaken_ordering",
          "norm:Svpbmt_noncacheable_aliasing_fence_prevents_ordering_loss",
          "norm:Svpbmt_cacheable_aliasing_may_cause_coherence_loss",
          "norm:Svpbmt_cacheable_aliasing_fence_flush_fence_required",
          "norm:Svpbmt_hgatp_stage_override_rule",
          "norm:Svpbmt_vsatp_stage_override_rule"
        ]
      },
      {
        "title": "\"Svinval\" Extension for Fine-Grained Address-Translation Cache Invalidation, Version 1.0",
        "id": "svinval",
        "children": [],
        "tags": [
          "norm:Svinval_split_fine_grained",
          "norm:Svinval_sinval_vma_invalidates_same_as_sfence_vma",
          "norm:Svinval_sfence_w_inval_orders_before_sinval_vma",
          "norm:Svinval_sequence_rs1_rs2",
          "norm:Svinval_sequence_reads_writes_before",
          "norm:Svinval_sequence_reads_writes_after",
          "norm:Svinval_hinval_vvma_gvma",
          "norm:Svinval_hinval_gvma_uses_vmid",
          "norm:Svinval_illegal_instruction_u_mode",
          "norm:Svinval_illegal_instruction_tvm",
          "norm:Svinval_virtual_instruction_vu_vs",
          "norm:Svinval_virtual_instruction_vtvms",
          "norm:Svinval_sfence_w_inval_inval_u_mode",
          "norm:Svinval_sfence_w_inval_inval_vu_mode",
          "norm:Svinval_sfence_w_inval_inval_s_vs_mode"
        ]
      },
      {
        "title": "\"Svadu\" Extension for Hardware Updating of A/D Bits, Version 1.0",
        "id": "sec:svadu",
        "children": [],
        "tags": [
          "norm:Svadu_hw_update_a_d_bits",
          "norm:Svadu_hypervisor_adue_writable",
          "norm:Svadu_disabled_hw_update_falls_back_to_svade"
        ]
      },
      {
        "title": "\"Svvptc\" Extension for Obviating Memory-Management Instructions after Marking PTEs Valid, Version 1.0",
        "id": "sec:svvptc",
        "children": [],
        "tags": [
          "norm:Svvptc_explicit_stores_update_valid_bit"
        ]
      },
      {
        "title": "\"Svrsw60t59b\" Extension for PTE Reserved-for-Software Bits 60-59, Version 1.0",
        "id": "sec:svrsw60t59b",
        "children": [],
        "tags": [
          "norm:Svrsw60t59b_reserved_bits_60_59",
          "norm:Svrsw60t59b_h_g_stage_reserved_bits",
          "norm:Svrsw60t59b_depends_on_sv39"
        ]
      },
      {
        "title": "\"Ssqosid\" Extension for Quality-of-Service (QoS) Identifiers, Version 1.0",
        "id": "ssqosid",
        "children": [
          {
            "title": "Supervisor Resource Management Configuration (srmcfg) register",
            "id": "_supervisor_resource_management_configuration_srmcfg_register",
            "children": [],
            "tags": [
              "norm:Ssqosid_srmcfg_register_size",
              "norm:Ssqosid_rcid_mcid_accompany_requests",
              "norm:Ssqosid_srmcfg_csr_applies_to_all_modes",
              "norm:Ssqosid_smstateen_srmcfg_requires_mstateen0",
              "norm:Ssqosid_srmcfg_access_illegal_instruction",
              "norm:Ssqosid_srmcfg_access_virtual_instruction"
            ]
          }
        ],
        "tags": [
          "norm:Ssqosid_shared_resource_need_management",
          "norm:Ssqosid_hw_monitoring_required",
          "norm:Ssqosid_srmcfg_introduced",
          "norm:Ssqosid_metadata_used_by_controllers",
          "norm:Ssqosid_cbqri_spec"
        ]
      },
      {
        "title": "\"Sstc\" Extension for Supervisor-mode Timer Interrupts, Version 1.0",
        "id": "Sstc",
        "children": [],
        "tags": [
          "norm:sstc_purpose",
          "norm:sstc_vs_facility",
          "norm:stimecmp_exist",
          "norm:vstimecmp_exist",
          "norm:stce_bit_exist"
        ]
      },
      {
        "title": "\"Sscofpmf\" Extension for Count Overflow and Mode-Based Filtering, Version 1.0",
        "id": "Sscofpmf",
        "children": [
          {
            "title": "Count Overflow Control",
            "id": "_count_overflow_control",
            "children": [],
            "tags": [
              "norm:mhpmevent-INH_op",
              "norm:mhpmevent-OF_op",
              "norm:hpmcounter_overflow",
              "norm:count_overflow_interrupt",
              "norm:count_overflow_trigger",
              "norm:mhpmevent-OF_bit_Set",
              "norm:LCOFIP_op"
            ]
          },
          {
            "title": "Supervisor Count Overflow (scountovf) Register",
            "id": "_supervisor_count_overflow_scountovf_register",
            "children": [],
            "tags": [
              "norm:scountovf_op",
              "norm:scountovf_smode_read_access_control",
              "norm:scountovf_mmode_read_access",
              "norm:scountovf_smode_read_access",
              "norm:scountovf_vsmode_read_access"
            ]
          }
        ],
        "tags": []
      },
      {
        "title": "\"H\" Extension for Hypervisor Support, Version 1.0",
        "id": "hypervisor",
        "children": [
          {
            "title": "Privilege Modes",
            "id": "_privilege_modes",
            "children": [],
            "tags": []
          },
          {
            "title": "Hypervisor and Virtual Supervisor CSRs",
            "id": "_hypervisor_and_virtual_supervisor_csrs",
            "children": [
              {
                "title": "Hypervisor Status (hstatus) Register",
                "id": "sec:hstatus",
                "children": [],
                "tags": [
                  "norm:hstatus_sz_acc_op",
                  "norm:hstatus-vsxl_op",
                  "norm:hstatus-vsxl_32",
                  "norm:hstatus_vsxl_64",
                  "norm:vsxl_ro",
                  "norm:hstatus-vsxl_change",
                  "norm:hstatus-vtsr_op",
                  "norm:hstatus-vtw_op",
                  "norm:vtw_virtinstr",
                  "norm:hstatus-vtvm_op",
                  "norm:hstatus_vgein_op",
                  "norm:hstatus-hu_op",
                  "norm:hstatus-spv_op",
                  "norm:hstatus-spv_sret",
                  "norm:hstatus-spvp_op",
                  "norm:hstatus-gva_op",
                  "norm:hstatus_vsbe_op"
                ]
              },
              {
                "title": "Hypervisor Trap Delegation (hedeleg and hideleg) Registers",
                "id": "_hypervisor_trap_delegation_hedeleg_and_hideleg_registers",
                "children": [],
                "tags": [
                  "norm:hedeleg_sz_acc",
                  "norm:hideleg_sz_acc",
                  "norm:hedeleg_op",
                  "norm:hdeleg_acc",
                  "norm:hedelegh_sz_acc_op",
                  "norm:hideleg_op",
                  "norm:hideleg_acc",
                  "norm:hideleg_trans"
                ]
              },
              {
                "title": "Hypervisor Interrupt (hvip, hip, and hie) Registers",
                "id": "hinterruptregs",
                "children": [],
                "tags": [
                  "norm:hvip_sz_op",
                  "norm:hvip_acc",
                  "norm:hip_hie_sz_acc",
                  "norm:hip_op",
                  "norm:hie_op",
                  "norm:sie_hip_hie_mutex",
                  "norm:hideleg_hs",
                  "norm:hip_acc",
                  "norm:hie_acc",
                  "norm:hip_sgeip_sgeie_acc_op",
                  "norm:hip_vseip_vseie_op",
                  "norm:hip_vstip_vstie_acc_op",
                  "norm:hip_vssip_vssie_op",
                  "norm:hsint_priority"
                ]
              },
              {
                "title": "Hypervisor Guest External Interrupt Registers (hgeip and hgeie)",
                "id": "hgeinterruptregs",
                "children": [],
                "tags": [
                  "norm:hgeip_sz_acc_op",
                  "norm:hgeie_sz_acc_op",
                  "norm:hgeip_hgeie_fields",
                  "norm:geilen",
                  "norm:hgeie_op"
                ]
              },
              {
                "title": "Hypervisor Environment Configuration Register (henvcfg)",
                "id": "sec:henvcfg",
                "children": [],
                "tags": [
                  "norm:henvcfg_sz_acc_op",
                  "norm:henvcfg-fiom_op",
                  "norm:henvcfg-fiom_order",
                  "norm:henvcfg-pbmte_op",
                  "norm:henvcfg-adue_op",
                  "norm:henvcfg-stce",
                  "norm:henvcfg-cbze",
                  "norm:henvcfg-cbcfe",
                  "norm:henvcfg_cbie",
                  "norm:cbo-inval_h-mode_veq1_op",
                  "norm:cbo-inval_h-mode_op0",
                  "norm:cbo-inval_h-mode_op1",
                  "norm:cbo-inval_h-mode_op2",
                  "norm:henvcfg-pmm_op",
                  "norm:henvcfg-lpe_op",
                  "norm:henvcfg-sse_op",
                  "norm:henvcfg-dte_op",
                  "norm:henvcfgh_sz_acc_op"
                ]
              },
              {
                "title": "Hypervisor Counter-Enable (hcounteren) Register",
                "id": "_hypervisor_counter_enable_hcounteren_register",
                "children": [],
                "tags": [
                  "norm:hcounteren_sz",
                  "norm:hcounteren_op",
                  "norm:hcounteren_acc",
                  "norm:hcounteren_warl"
                ]
              },
              {
                "title": "Hypervisor Time Delta (htimedelta) Register",
                "id": "_hypervisor_time_delta_htimedelta_register",
                "children": [],
                "tags": [
                  "norm:htimedelta_sz_acc_op",
                  "norm:htimedeltah_sz_acc_op",
                  "norm:time_htimedelta_req"
                ]
              },
              {
                "title": "Hypervisor Trap Value (htval) Register",
                "id": "_hypervisor_trap_value_htval_register",
                "children": [],
                "tags": [
                  "norm:htval_sz_acc_op",
                  "norm:htval_trapval",
                  "norm:htval_val"
                ]
              },
              {
                "title": "Hypervisor Trap Instruction (htinst) Register",
                "id": "_hypervisor_trap_instruction_htinst_register",
                "children": [],
                "tags": [
                  "norm:htinst_sz_acc_op",
                  "norm:htinst_val"
                ]
              },
              {
                "title": "Hypervisor Guest Address Translation and Protection (hgatp) Register",
                "id": "hgatp",
                "children": [],
                "tags": [
                  "norm:hgatp_sz_acc_op",
                  "norm:hgatp_tvm_illegal",
                  "norm:hgatp-mode_bare",
                  "norm:hgatp-mode_sv",
                  "norm:hgatp_mode_warl",
                  "norm:hgatp-ppn_op",
                  "norm:hgatp_vmid",
                  "norm:hgatp_vmid_lsbs"
                ]
              },
              {
                "title": "Virtual Supervisor Status (vsstatus) Register",
                "id": "vsstatus",
                "children": [],
                "tags": [
                  "norm:vsstatus_sz_acc_op",
                  "norm:vsstatus_uxl_op",
                  "norm:vsstatus-uxl_change",
                  "norm:vsstatus-fs_op",
                  "norm:vsstatus-vs_op",
                  "norm:vsstatus-sd_xs_op",
                  "norm:vsstatus_ube",
                  "norm:vsstatus_v0",
                  "norm:vsstatus-spelp_op",
                  "norm:vsstatus-sdt_op"
                ]
              },
              {
                "title": "Virtual Supervisor Interrupt (vsip and vsie) Registers",
                "id": "_virtual_supervisor_interrupt_vsip_and_vsie_registers",
                "children": [],
                "tags": [
                  "norm:vsip_vsie_sz_acc_op",
                  "norm:vsip_vsie-lcofi",
                  "norm:vsip_vsie-sei",
                  "norm:vsip_vsie-sti",
                  "norm:vsip_vsie-ssi"
                ]
              },
              {
                "title": "Virtual Supervisor Trap Vector Base Address (vstvec) Register",
                "id": "_virtual_supervisor_trap_vector_base_address_vstvec_register",
                "children": [],
                "tags": [
                  "norm:vstvec_sz_acc_op"
                ]
              },
              {
                "title": "Virtual Supervisor Scratch (vsscratch) Register",
                "id": "_virtual_supervisor_scratch_vsscratch_register",
                "children": [],
                "tags": [
                  "norm:vsscratch_sz_acc_op"
                ]
              },
              {
                "title": "Virtual Supervisor Exception Program Counter (vsepc) Register",
                "id": "_virtual_supervisor_exception_program_counter_vsepc_register",
                "children": [],
                "tags": [
                  "norm:vspec_sz_acc_op",
                  "norm:vsepc_warl"
                ]
              },
              {
                "title": "Virtual Supervisor Cause (vscause) Register",
                "id": "_virtual_supervisor_cause_vscause_register",
                "children": [],
                "tags": [
                  "norm:vscause_sz_acc_op",
                  "norm:vscause_wlrl"
                ]
              },
              {
                "title": "Virtual Supervisor Trap Value (vstval) Register",
                "id": "_virtual_supervisor_trap_value_vstval_register",
                "children": [],
                "tags": [
                  "norm:vstval_sz_acc_op",
                  "norm:vstval_warl"
                ]
              },
              {
                "title": "Virtual Supervisor Address Translation and Protection (vsatp) Register",
                "id": "_virtual_supervisor_address_translation_and_protection_vsatp_register",
                "children": [],
                "tags": [
                  "norm:vsatp_sz_acc_op",
                  "norm:vs_stage_speculative_a_bit",
                  "norm:vsatp_mode_unsupported_v0",
                  "norm:vsatp_mode_unsupported_v1",
                  "norm:vsatp_v0"
                ]
              },
              {
                "title": "Virtual Supervisor Timer (vstimecmp) Register",
                "id": "vstimecmp",
                "children": [],
                "tags": [
                  "norm:vstimecmp_sz",
                  "norm:vstimecmp_acc",
                  "norm:hip-vstip_op",
                  "norm:hip-vstip_clear",
                  "norm:hip-vstip_enable"
                ]
              }
            ],
            "tags": [
              "norm:H_csrs_hs_not_vs",
              "norm:H_vscsrs_sub",
              "norm:H_vscsrs_acc_vs",
              "norm:H_vscsrs_acc_u",
              "norm:H_vscsrs_acc_m_hs",
              "norm:H_vscsrs_v1",
              "norm:H_vscsrs_v0",
              "norm:H_scsrs_nomatch",
              "norm:hsxlen",
              "norm:vsxlen"
            ]
          },
          {
            "title": "Hypervisor Instructions",
            "id": "_hypervisor_instructions",
            "children": [
              {
                "title": "Hypervisor Virtual-Machine Load and Store Instructions",
                "id": "_hypervisor_virtual_machine_load_and_store_instructions",
                "children": [],
                "tags": [
                  "norm:hlsv_mode",
                  "norm:hlsv_priv",
                  "norm:hlsv_trans",
                  "norm:hlsv_sstatus-mxr",
                  "norm:hlsv_vsstatus-mxr",
                  "norm:hlsv_op",
                  "norm:hlsv_u_op",
                  "norm:hlvx-wu_valid32",
                  "norm:hlsv_virtinst",
                  "norm:hlsv_illegalinst"
                ]
              },
              {
                "title": "Hypervisor Memory-Management Fence Instructions",
                "id": "hfence.vma",
                "children": [],
                "tags": [
                  "norm:hfence-vvma_hfence-gvma_op",
                  "norm:hfence-vvma_mode",
                  "norm:hfence-vvma_limits",
                  "norm:hfence-vvma_asid",
                  "norm:hfence-vvma_tvm",
                  "norm:hfence-gvma_op",
                  "norm:hfence-gvma_vmid",
                  "norm:hfence-gvma_mode",
                  "norm:hfence-vvma_hfence-gvma_exceptions"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Machine-Level CSRs",
            "id": "_machine_level_csrs_2",
            "children": [
              {
                "title": "Machine Status (mstatus and mstatush) Registers",
                "id": "_machine_status_mstatus_and_mstatush_registers_2",
                "children": [],
                "tags": [
                  "norm:mstatus_mpv_op",
                  "norm:mstatus_gva_op",
                  "norm:mstatus_modes",
                  "norm:mstatus_tvm_hs",
                  "norm:mstatus_mprv_hypervisor",
                  "norm:mstatus_mprv_hlsv"
                ]
              },
              {
                "title": "Machine Interrupt Delegation (mideleg) Register",
                "id": "_machine_interrupt_delegation_mideleg_register",
                "children": [],
                "tags": [
                  "norm:mideleg_acc_h",
                  "norm:mideleg_hroz"
                ]
              },
              {
                "title": "Machine Interrupt (mip and mie) Registers",
                "id": "_machine_interrupt_mip_and_mie_registers_2",
                "children": [],
                "tags": [
                  "norm:mip_mie_vs",
                  "norm:mip_mie_alias"
                ]
              },
              {
                "title": "Machine Second Trap Value (mtval2) Register",
                "id": "_machine_second_trap_value_mtval2_register",
                "children": [],
                "tags": [
                  "norm:mtval2_sz_acc_op",
                  "norm:mtval2_trapval",
                  "norm:mtval2_trapval_vstrans",
                  "norm:mtval2_trapval_other",
                  "norm:mtval2_val",
                  "norm:mtval2_Ssdbltrap"
                ]
              },
              {
                "title": "Machine Trap Instruction (mtinst) Register",
                "id": "_machine_trap_instruction_mtinst_register",
                "children": [],
                "tags": [
                  "norm:mtinst_sz_acc_op",
                  "norm:mtinst_val"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Two-Stage Address Translation",
            "id": "two-stage-translation",
            "children": [
              {
                "title": "Guest Physical Address Translation",
                "id": "guest-addr-translation",
                "children": [],
                "tags": [
                  "norm:hgatp-mode_bare_trans",
                  "norm:hgatp-mode_x4",
                  "norm:hgatp-mode_sv32x4",
                  "norm:hgatp-mode_sv39x4",
                  "norm:hgatp-mode_sv48x4",
                  "norm:hgatp-mode_sv57x4",
                  "norm:H_vm_gpatrans",
                  "norm:H_vm_gpapriv",
                  "norm:H_vm_gpa_g"
                ]
              },
              {
                "title": "Guest-Page Faults",
                "id": "_guest_page_faults",
                "children": [],
                "tags": [
                  "norm:H_guest_page_fault",
                  "norm:H_straddle",
                  "norm:mtval2_htval_virtaddr"
                ]
              },
              {
                "title": "Memory-Management Fences",
                "id": "hyp-mm-fences",
                "children": [],
                "tags": [
                  "norm:sfence-vma_v0",
                  "norm:sfence-vma_v1"
                ]
              },
              {
                "title": "Interaction with Pointer Masking",
                "id": "pm-two-stage",
                "children": [],
                "tags": []
              }
            ],
            "tags": [
              "norm:H_vm_twostage",
              "norm:vsstatus-mxr_vm",
              "norm:sstatus-mxr_vm",
              "norm:H_vm_gstagetrans",
              "norm:H_pmp"
            ]
          },
          {
            "title": "Traps",
            "id": "_traps",
            "children": [
              {
                "title": "Trap Cause Codes",
                "id": "sec:hcauses",
                "children": [],
                "tags": [
                  "norm:H_cause",
                  "norm:H_cause_ecall",
                  "norm:H_cause_virtual_instruction",
                  "norm:H_cause_virtual_instruction_high",
                  "norm:H_illegal_high_half",
                  "norm:H_virtinst_vs_nonhighctr_h0_m1",
                  "norm:H_virtinst_vs32_highctr_h0_m1",
                  "norm:H_virtinst_vu_nonhighctr_h0_s0_m1",
                  "norm:H_virtinst_vu32_highctr_h0_s0_m1",
                  "norm:H_virtinst_vu_vs_hinst",
                  "norm:H_virtinst_vu_vs_nonhigh_allowedhs_tvm0",
                  "norm:H_virtinst_vu_vs32_high_allowedhs_tvm0",
                  "norm:H_virtinst_vu_wfi_tw0",
                  "norm:H_virtinst_vu_sret_sfence",
                  "norm:H_virtinst_vu_nonhigh_supervisor_allowedhs_tvm0",
                  "norm:H_virtinst_vu32_high_supervisor_allowedhs_tvm0",
                  "norm:H_virtinst_wfi_vtw1_tw0",
                  "norm:H_virtinst_vs_sret_vtsr1",
                  "norm:H_virtinst_vs_sfence_sinval_satp_vtvm1",
                  "norm:H_virtinst_xtval",
                  "norm:H_illegalinst_xstatus_fs_vs",
                  "norm:H_exception_priority"
                ]
              },
              {
                "title": "Trap Entry",
                "id": "_trap_entry",
                "children": [],
                "tags": [
                  "norm:H_trap_deleg",
                  "norm:H_trap_m_csrwrites",
                  "norm:H_trap_hs_csrwrites",
                  "norm:H_trap_vs_csrwrites"
                ]
              },
              {
                "title": "Transformed Instruction or Pseudoinstruction for mtinst or htinst",
                "id": "tinst-vals",
                "children": [],
                "tags": [
                  "norm:H_trap_xtinst",
                  "norm:H_trap_xtinst_interrupt",
                  "norm:H_trap_xtinst_exception_lead-in",
                  "norm:H_trap_xtinst_exception_list",
                  "norm:H_trap_xtinst_val",
                  "norm:H_trap_xtinst_guestpage",
                  "norm:H_trap_xtinst_guestpage_rw"
                ]
              },
              {
                "title": "Trap Return",
                "id": "_trap_return",
                "children": [],
                "tags": [
                  "norm:mret_h",
                  "norm:sret_h",
                  "norm:mret_v0",
                  "norm:mret_v1",
                  "norm:mret_dt"
                ]
              }
            ],
            "tags": []
          }
        ],
        "tags": [
          "norm:H_mtval_nrz",
          "norm:H_vm_supported",
          "norm:misa-h_op"
        ]
      },
      {
        "title": "Control-flow Integrity (CFI)",
        "id": "priv-cfi",
        "children": [
          {
            "title": "Landing Pad (Zicfilp)",
            "id": "priv-forward",
            "children": [
              {
                "title": "Landing-Pad-Enabled (LPE) State",
                "id": "FCFIACT",
                "children": [],
                "tags": []
              },
              {
                "title": "Preserving Expected Landing Pad State on Traps",
                "id": "ZICFILP_FORWARD_TRAPS",
                "children": [],
                "tags": [
                  "norm:Zicfilp_forward_traps",
                  "norm:Zicfilp_forward_trap_async_interrupt",
                  "norm:Zicfilp_forward_trap_async_exception",
                  "norm:Zicfilp_exception_priority",
                  "norm:lpad_sw_exception",
                  "norm:mstatus-mpelp_op",
                  "norm:mstatus-spelp_op",
                  "norm:sstatus-spelp_op",
                  "norm:vsstatus-spelp_op2",
                  "norm:dcsr-pelp_op",
                  "norm:Zicfilp_pelp_trap",
                  "norm:Zicfilp_pelp_trap_return",
                  "norm:Zicfilp_pelp_debug_mode"
                ]
              }
            ],
            "tags": []
          },
          {
            "title": "Shadow Stack (Zicfiss)",
            "id": "priv-backward",
            "children": [
              {
                "title": "Shadow Stack Pointer (ssp) CSR access control",
                "id": "_shadow_stack_pointer_ssp_csr_access_control",
                "children": [],
                "tags": [
                  "norm:zicfiss_ssp_csr",
                  "norm:zicfiss_m_menvcfg-sse",
                  "norm:zicfiss_u_senvcfg-sse",
                  "norm:zicfiss_vs_henvcfg-sse",
                  "norm:zicfiss_vu_henvcfg_senvcfg-sse",
                  "norm:zicfiss_sse_access"
                ]
              },
              {
                "title": "Shadow-Stack-Enabled (SSE) State",
                "id": "_shadow_stack_enabled_sse_state",
                "children": [],
                "tags": [
                  "norm:zicfiss_smode-xsse"
                ]
              },
              {
                "title": "Shadow Stack Memory Protection",
                "id": "SSMP",
                "children": [],
                "tags": [
                  "norm:ss_page_enc",
                  "norm:ssmp_menvcfg-sse",
                  "norm:ssmp_henvcfg-sse",
                  "norm:satp-mode_bare",
                  "norm:ssmp_ssamoswap",
                  "norm:ssmp_ss_page_access_fault",
                  "norm:ssmp_ss_cache_block_access_fault",
                  "norm:ssmp_ss_implicit_access_fault",
                  "norm:ssmp_ss_load",
                  "norm:ss_fault_exception_code",
                  "norm:ssmp_ss_page_illegeal_access",
                  "norm:ssmp_ss_read_only_page",
                  "norm:ssp_xlen_aligned",
                  "norm:ssmp_ss_idempotent_memory",
                  "norm:active_g_stage_pte"
                ]
              }
            ],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "\"Ssdbltrp\" Double Trap Extension, Version 1.0",
        "id": "ssdbltrp",
        "children": [],
        "tags": [
          "norm:HS-mode_invoke_error",
          "norm:M-mode_invoke_error",
          "norm:menvcfg_DTE",
          "norm:sstatus_SDT",
          "norm:henvcfg_DTE",
          "norm:vsstatus_SDT"
        ]
      },
      {
        "title": "Pointer Masking Extensions, Version 1.0.0",
        "id": "Zpm",
        "children": [
          {
            "title": "Introduction",
            "id": "_introduction_4",
            "children": [],
            "tags": [
              "norm:pm_ignore_upper_bits",
              "norm:pm_all_priv_modes",
              "norm:pm_tag_check_impl"
            ]
          },
          {
            "title": "Background",
            "id": "_background",
            "children": [
              {
                "title": "Definitions",
                "id": "_definitions",
                "children": [],
                "tags": []
              },
              {
                "title": "The “Ignore” Transformation",
                "id": "sec-ignore-transform",
                "children": [],
                "tags": [
                  "norm:pm_ignore_va",
                  "norm:pm_ignore_pa",
                  "norm:pm_apply_explicit",
                  "norm:pm_not_apply_implicit",
                  "norm:pm_deterministic_effect"
                ]
              },
              {
                "title": "Example",
                "id": "_example",
                "children": [],
                "tags": []
              },
              {
                "title": "Determining the Value of PMLEN",
                "id": "_determining_the_value_of_pmlen",
                "children": [],
                "tags": [
                  "norm:pmlen_supported_values",
                  "norm:pmlen_future_reserved"
                ]
              },
              {
                "title": "Pointer Masking and Privilege Modes",
                "id": "_pointer_masking_and_privilege_modes",
                "children": [],
                "tags": [
                  "norm:pm_per_mode_control",
                  "norm:pm_auto_apply_active_mode",
                  "norm:pm_config_next_higher",
                  "norm:pm_mode_only_dependency"
                ]
              },
              {
                "title": "Memory Accesses Subject to Pointer Masking",
                "id": "_memory_accesses_subject_to_pointer_masking",
                "children": [],
                "tags": [
                  "norm:pm_mprv_spvp",
                  "norm:pm_mxr_exception",
                  "norm:pm_cpu_only",
                  "norm:pm_misaligned_equivalence",
                  "norm:pm_no_csr_sw",
                  "norm:pm_warl_unaffected",
                  "norm:pm_csr_hw_apply",
                  "norm:pm_debug_trigger",
                  "norm:pm_no_trap_vector_mask"
                ]
              },
              {
                "title": "Pointer Masking Extensions",
                "id": "_pointer_masking_extensions",
                "children": [],
                "tags": [
                  "norm:pm_family_extensions",
                  "norm:ssnpm_definition",
                  "norm:smnpm_definition",
                  "norm:smmpm_definition",
                  "norm:sspm_definition",
                  "norm:supm_definition",
                  "norm:pm_rv64_only",
                  "norm:pm_rv32_illegal",
                  "norm:pm_uxl_clear"
                ]
              },
              {
                "title": "Number of Masked Bits",
                "id": "_number_of_masked_bits",
                "children": [],
                "tags": [
                  "norm:pmlen_mode_depend",
                  "norm:pmlen_illegal_warl"
                ]
              }
            ],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "RISC-V Privileged Instruction Set Listings",
        "id": "_risc_v_privileged_instruction_set_listings",
        "children": [],
        "tags": []
      },
      {
        "title": "History",
        "id": "_history",
        "children": [
          {
            "title": "Research Funding at UC Berkeley",
            "id": "_research_funding_at_uc_berkeley",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      },
      {
        "title": "Historical Rationale for Extensions",
        "id": "_historical_rationale_for_extensions",
        "children": [
          {
            "title": "\"Smepmp\" Extension for PMP Enhancements for memory access and execution prevention in Machine mode",
            "id": "smepmp_rationale",
            "children": [],
            "tags": []
          }
        ],
        "tags": []
      }
    ],
    "tags": []
  }
}
